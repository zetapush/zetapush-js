{"version":3,"file":"zetapush.min.js","sources":["../node_modules/zetapush-cometd/lib/FetchLongPollingTransport.js","../node_modules/zetapush-cometd/lib/WebSocketTransport.js","../src/mapping/core.js","../src/mapping/authentications.js","../src/authentication/handshake.js","../src/connection/connection-status.js","../node_modules/zetapush-cometd/lib/TransportRegistry.js","../node_modules/zetapush-cometd/lib/Utils.js","../node_modules/zetapush-cometd/lib/CometD.js","../node_modules/zetapush-cometd/lib/Transport.js","../node_modules/zetapush-cometd/lib/RequestTransport.js","../node_modules/zetapush-cometd/lib/LongPollingTransport.js","../node_modules/zetapush-cometd/lib/browser/Transports.js","../node_modules/zetapush-cometd/index.js","../src/mapping/services.js","../src/utils/index.js","../src/client/helper.js","../src/client/basic.js","../src/utils/storage.js","../src/utils/session-persistence.js","../src/client/smart.js","../src/client/weak.js","../src/index.js"],"sourcesContent":["var Transport = require('./Transport')\nvar LongPollingTransport = require('./LongPollingTransport')\n\n/**\n * Implements LongPollingTransport using borwser fetch() API\n * @access private\n * @return {FetchLongPollingTransport}\n */\nfunction FetchLongPollingTransport() {\n  var _super = new LongPollingTransport()\n  var that = Transport.derive(_super)\n\n  /**\n   * Implements transport via fetch() API\n   * @param {Object} packet\n   */\n  that.xhrSend = function (packet) {\n    FetchLongPollingTransport.fetch(packet.url, {\n      method: 'post',\n      body: packet.body,\n      headers: Object.assign(packet.headers, {\n        'Content-Type': 'application/json;charset=UTF-8'\n      })\n    })\n    .then(function (response) {\n      return response.json()\n    })\n    .then(packet.onSuccess)\n    .catch(packet.onError)\n  }\n\n  return that\n}\n\n// Reference global WebSocket \nFetchLongPollingTransport.fetch = 'Abstract'\n\n// Export FetchLongPollingTransport\nmodule.exports = FetchLongPollingTransport;\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\nfunction WebSocketTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _cometd;\n    // By default WebSocket is supported\n    var _webSocketSupported = true;\n    // Whether we were able to establish a WebSocket connection\n    var _webSocketConnected = false;\n    var _stickyReconnect = true;\n    // The context contains the envelopes that have been sent\n    // and the timeouts for the messages that have been sent.\n    var _context = null;\n    var _connecting = null;\n    var _connected = false;\n    var _successCallback = null;\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _webSocketSupported = true;\n        if (init) {\n            _webSocketConnected = false;\n        }\n        _stickyReconnect = true;\n        _context = null;\n        _connecting = null;\n        _connected = false;\n    };\n\n    function _forceClose(context, event) {\n        if (context) {\n            this.webSocketClose(context, event.code, event.reason);\n            // Force immediate failure of pending messages to trigger reconnect.\n            // This is needed because the server may not reply to our close()\n            // and therefore the onclose function is never called.\n            this.onClose(context, event);\n        }\n    }\n\n    function _sameContext(context) {\n        return context === _connecting || context === _context;\n    }\n\n    function _storeEnvelope(context, envelope, metaConnect) {\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            var message = envelope.messages[i];\n            if (message.id) {\n                messageIds.push(message.id);\n            }\n        }\n        context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n    }\n\n    function _websocketConnect(context) {\n        // We may have multiple attempts to open a WebSocket\n        // connection, for example a /meta/connect request that\n        // may take time, along with a user-triggered publish.\n        // Early return if we are already connecting.\n        if (_connecting) {\n            return;\n        }\n\n        // Mangle the URL, changing the scheme from 'http' to 'ws'.\n        var url = _cometd.getURL().replace(/^http/, 'ws');\n        this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n        try {\n            var protocol = _cometd.getConfiguration().protocol;\n            var WebSocket = WebSocketTransport.WebSocket;\n            context.webSocket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);\n            _connecting = context;\n        } catch (x) {\n            _webSocketSupported = false;\n            this._debug('Exception while creating WebSocket object', x);\n            throw x;\n        }\n\n        // By default use sticky reconnects.\n        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\n        var self = this;\n        var connectTimeout = _cometd.getConfiguration().connectTimeout;\n        if (connectTimeout > 0) {\n            context.connectTimer = self.setTimeout(function() {\n                _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n                // The connection was not opened, close anyway.\n                _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n            }, connectTimeout);\n        }\n\n        var onopen = function() {\n            _cometd._debug('WebSocket onopen', context);\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            if (_sameContext(context)) {\n                _connecting = null;\n                _context = context;\n                _webSocketConnected = true;\n                self.onOpen(context);\n            } else {\n                // We have a valid connection already, close this one.\n                _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n                _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n            }\n        };\n\n        // This callback is invoked when the server sends the close frame.\n        // The close frame for a connection may arrive *after* another\n        // connection has been opened, so we must make sure that actions\n        // are performed only if it's the same connection.\n        var onclose = function(event) {\n            event = event || {code: 1000};\n            _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            self.onClose(context, event);\n        };\n\n        var onmessage = function(wsMessage) {\n            _cometd._debug('WebSocket onmessage', wsMessage, context);\n            self.onMessage(context, wsMessage);\n        };\n\n        context.webSocket.onopen = onopen;\n        context.webSocket.onclose = onclose;\n        context.webSocket.onerror = function() {\n            // Clients should call onclose(), but if they do not we do it here for safety.\n            onclose({code: 1000, reason: 'Error'});\n        };\n        context.webSocket.onmessage = onmessage;\n\n        this._debug('Transport', this.getType(), 'configured callbacks on', context);\n    }\n\n    function _webSocketSend(context, envelope, metaConnect) {\n        var json = JSON.stringify(envelope.messages);\n        context.webSocket.send(json);\n        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);\n\n        // Manage the timeout waiting for the response.\n        var maxDelay = this.getConfiguration().maxNetworkDelay;\n        var delay = maxDelay;\n        if (metaConnect) {\n            delay += this.getAdvice().timeout;\n            _connected = true;\n        }\n\n        var self = this;\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            (function() {\n                var message = envelope.messages[i];\n                if (message.id) {\n                    messageIds.push(message.id);\n                    context.timeouts[message.id] = self.setTimeout(function() {\n                        _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n                        _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n                    }, delay);\n                }\n            })();\n        }\n\n        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n    }\n\n    _self._notifySuccess = function(fn, messages) {\n        fn.call(this, messages);\n    };\n\n    _self._notifyFailure = function(fn, context, messages, failure) {\n        fn.call(this, context, messages, failure);\n    };\n\n    function _send(context, envelope, metaConnect) {\n        try {\n            if (context === null) {\n                context = _connecting || {\n                        envelopes: {},\n                        timeouts: {}\n                    };\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _websocketConnect.call(this, context);\n            } else {\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        } catch (x) {\n            // Keep the semantic of calling response callbacks asynchronously after the request.\n            var self = this;\n            self.setTimeout(function() {\n                _forceClose.call(self, context, {\n                    code: 1000,\n                    reason: 'Exception',\n                    exception: x\n                });\n            }, 0);\n        }\n    }\n\n    _self.onOpen = function(context) {\n        var envelopes = context.envelopes;\n        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var element = envelopes[key];\n                var envelope = element[0];\n                var metaConnect = element[1];\n                // Store the success callback, which is independent from the envelope,\n                // so that it can be used to notify arrival of messages.\n                _successCallback = envelope.onSuccess;\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        }\n    };\n\n    _self.onMessage = function(context, wsMessage) {\n        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n        var close = false;\n        var messages = this.convertToMessages(wsMessage.data);\n        var messageIds = [];\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n\n            // Detect if the message is a response to a request we made.\n            // If it's a meta message, for sure it's a response; otherwise it's\n            // a publish message and publish responses don't have the data field.\n            if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n                if (message.id) {\n                    messageIds.push(message.id);\n\n                    var timeout = context.timeouts[message.id];\n                    if (timeout) {\n                        this.clearTimeout(timeout);\n                        delete context.timeouts[message.id];\n                        this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n                    }\n                }\n            }\n\n            if ('/meta/connect' === message.channel) {\n                _connected = false;\n            }\n            if ('/meta/disconnect' === message.channel && !_connected) {\n                close = true;\n            }\n        }\n\n        // Remove the envelope corresponding to the messages.\n        var removed = false;\n        var envelopes = context.envelopes;\n        for (var j = 0; j < messageIds.length; ++j) {\n            var id = messageIds[j];\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var ids = key.split(',');\n                    var index = Utils.inArray(id, ids);\n                    if (index >= 0) {\n                        removed = true;\n                        ids.splice(index, 1);\n                        var envelope = envelopes[key][0];\n                        var metaConnect = envelopes[key][1];\n                        delete envelopes[key];\n                        if (ids.length > 0) {\n                            envelopes[ids.join(',')] = [envelope, metaConnect];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if (removed) {\n            this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n        }\n\n        this._notifySuccess(_successCallback, messages);\n\n        if (close) {\n            this.webSocketClose(context, 1000, 'Disconnect');\n        }\n    };\n\n    _self.onClose = function(context, event) {\n        this._debug('Transport', this.getType(), 'closed', context, event);\n\n        if (_sameContext(context)) {\n            // Remember if we were able to connect.\n            // This close event could be due to server shutdown,\n            // and if it restarts we want to try websocket again.\n            _webSocketSupported = _stickyReconnect && _webSocketConnected;\n            _connecting = null;\n            _context = null;\n        }\n\n        var timeouts = context.timeouts;\n        context.timeouts = {};\n        for (var id in timeouts) {\n            if (timeouts.hasOwnProperty(id)) {\n                this.clearTimeout(timeouts[id]);\n            }\n        }\n\n        var envelopes = context.envelopes;\n        context.envelopes = {};\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var envelope = envelopes[key][0];\n                var metaConnect = envelopes[key][1];\n                if (metaConnect) {\n                    _connected = false;\n                }\n                var failure = {\n                    websocketCode: event.code,\n                    reason: event.reason\n                };\n                if (event.exception) {\n                    failure.exception = event.exception;\n                }\n                this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n            }\n        }\n    };\n\n    _self.registered = function(type, cometd) {\n        _super.registered(type, cometd);\n        _cometd = cometd;\n    };\n\n    _self.accept = function(version, crossDomain, url) {\n        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n        // Using !! to return a boolean (and not the WebSocket object).\n        return _webSocketSupported && !('undefined' === typeof WebSocket) && _cometd.websocketEnabled !== false;\n    };\n\n    _self.send = function(envelope, metaConnect) {\n        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);\n        _send.call(this, _context, envelope, metaConnect);\n    };\n\n    _self.webSocketClose = function(context, code, reason) {\n        try {\n            if (context.webSocket) {\n                context.webSocket.close(code, reason);\n            }\n        } catch (x) {\n            this._debug(x);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n        this.reset(true);\n    };\n\n    return _self;\n};\n\n// Reference global WebSocket \nWebSocketTransport.WebSocket = 'Abstract';\n\n// Export WebSocketTransport\nmodule.exports = WebSocketTransport;\n","/**\n * @access protected\n */\nexport class Service {\n  constructor({ $publish }) {\n    this.$publish = $publish\n  }\n}\n","import { Service } from './core'\n/**\n * Delegating authentication\n *\n * This authentication delegates authentication to an external auth provider\n * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL\n * <br>The response must be in JSON format\n *  Each key of the response will be considered a user information field name\n * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)\n * */\n/**\n * End-user API for the delegating authentication\n *\n * Provisionning verbs.\n * @access public\n * */\nexport class Delegating extends Service {\n\t/**\n\t * Get default deployment id associated to Delegating service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'delegating_0'\n\t}\n}\n/**\n * Local authentication\n *\n * Zetapush local authentication\n *  The configurer can choose the primary key and mandatory user fields for account creation\n *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)\n * */\n/**\n * End-user API for the simple local authentication\n *\n * These API verbs allow end-users to manage their account.\n * @access public\n * */\nexport class Simple extends Service {\n\t/**\n\t * Get default deployment id associated to Simple service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'simple_0'\n\t}\n}\n/**\n * Weak authentication\n *\n * The weak authentication allows for anonymous authentication of devices\n *  Such devices can display a qrcode to allow regular users to take control of them\n * */\n/**\n * User API for weak devices control\n *\n * User API for control and release of weakly authenticated user sessions.\n * @access public\n * */\nexport class Weak extends Service {\n\t/**\n\t * Get default deployment id associated to Weak service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'weak_0'\n\t}\n\t/**\n\t * Controls a session\n\t *\n\t * Takes control of a weak user session, identified by the given public token.\n\t * The public token has been previously made available by the controlled device, for example by displaying a QRCode.\n\t * Upon control notification, the client SDK of the controlled session is expected to re-handshake.\n\t * */\n\tcontrol({publicToken,fullRights}) { return this.$publish('control', {publicToken,fullRights})}\n\t/**\n\t * Returns the current token\n\t *\n\t * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.\n\t * The token can be used to log in as the same weak user another time.\n\t * */\n\tgetToken() { return this.$publish('getToken', {})}\n\t/**\n\t * Releases a session\n\t *\n\t * Releases control of a weak user session, identified by the given public token.\n\t * The weak user session must have been previously controlled by a call to 'control'.\n\t * */\n\trelease({publicToken,fullRights}) { return this.$publish('release', {publicToken,fullRights})}\n}\n","import { Delegating, Simple, Weak } from '../mapping/authentications'\n\n/**\n * ZetaPush deployables names\n */\nconst DeployableNames = {\n  AUTH_SIMPLE: 'simple',\n  AUTH_WEAK: 'weak',\n  AUTH_DELEGATING: 'delegating'\n}\n\n/**\n * Provide abstraction over CometD handshake data structure\n * @access protected\n */\nclass AbstractHandshake {\n  /**\n   * Create a new handshake manager\n   * @param {{authType: string, sandboxId: string, deploymentId: string}} parameters\n   */\n  constructor({ authType, sandboxId, deploymentId }) {\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.authType = authType\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.deploymentId = deploymentId\n  }\n  /**\n   * @param {ClientHelper} client\n   * @return {Object}\n   */\n  getHandshakeFields(client) {\n    const authentication = {\n      data: this.authData,\n      type: `${client.getSandboxId()}.${this.deploymentId}.${this.authType}`,\n      version: this.authVersion\n    }\n    if (client.getResource()) {\n      authentication.resource = client.getResource()\n    }\n    return {\n      ext: {\n        authentication\n      }\n    }\n  }\n  /**\n   * Get auth version\n   * @return {string}\n   */\n  get authVersion() {\n    return 'none'\n  }\n}\n\n/**\n * Provide abstraction over CometD token base handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass TokenHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, token: string}} parameters\n   */\n  constructor({ authType, deploymentId, token }) {\n    super({ deploymentId, authType })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.token = token\n  }\n  /**\n   * @return {token: string}\n   */\n  get authData() {\n    const { token } = this\n    return {\n      token\n    }\n  }\n}\n\n/**\n * Provide abstraction over CometD credentials based handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass CredentialsHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   */\n  constructor({ authType, deploymentId, login, password }) {\n    super({ authType, deploymentId })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.login = login\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.password = password\n  }\n  /**\n   * Get auth data\n   * @return {login: string, password: string}\n   */\n  get authData() {\n    const { login, password } = this\n    return {\n      login, password\n    }\n  }\n}\n\n/**\n * Factory to create handshake\n * @access public\n */\nexport class Authentication {\n  /**\n   * @param {{deploymentId: string, login: string, password: string}} parameters\n   * @return {CredentialsHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   login: <USER-LOGIN>,\n   *   password: '<USER-PASSWORD>'\n   * })\n   */\n  static simple({ deploymentId = Simple.DEFAULT_DEPLOYMENT_ID, login, password }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_SIMPLE,\n      deploymentId,\n      login,\n      password\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static weak({ deploymentId = Weak.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_WEAK,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-DELEGATING-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static delegating({ deploymentId = Delegating.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_DELEGATING,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   * @return {TokenHandshake|CredentialsHandshake}\n   */\n  static create({ authType, deploymentId, login, password }) {\n    if (password === null) {\n      return new TokenHandshake({ authType, deploymentId, token: login })\n    }\n    return new CredentialsHandshake({ authType, deploymentId, login, password })\n  }\n}\n","/**\n * Define life cycle connection methods\n * @access public\n */\nexport class ConnectionStatusListener {\n  /**\n   * Callback fired when connection is broken\n   */\n  onConnectionBroken() {}\n  /**\n   * Callback fired when connection is closed\n   */\n  onConnectionClosed() {}\n  /**\n   * Callback fired when connection is established\n   */\n  onConnectionEstablished() {}\n  /**\n   * Callback fired when an error occurs in connection to server step\n   * @param {Object} failure\n   */\n  onConnectionToServerFail(failure) {}\n  /**\n   * Callback fired when negociation with server failed\n   * @param {Object} failure\n   */\n  onNegotiationFailed(failure) {}\n  /**\n   * Callback no server url avaibale\n   */\n  onNoServerUrlAvailable() {}\n  /**\n  * Callback fired when connection will close\n  */\n  onConnectionWillClose() {}\n  /**\n   * Callback fired when an error occurs in handshake step\n   * @param {Object} failure\n   */\n  onFailedHandshake(failure) {}\n  /**\n   * Callback fired when a message is lost\n   */\n  onMessageLost() {}\n  /**\n   * Callback fired when handshake step succeed\n   * @param {Object} authentication\n   */\n  onSuccessfulHandshake(authentication) {}\n}\n","/**\n * A registry for transports used by the CometD object.\n */\nmodule.exports = function TransportRegistry() {\n    var _types = [];\n    var _transports = {};\n\n    this.getTransportTypes = function() {\n        return _types.slice(0);\n    };\n\n    this.findTransportTypes = function(version, crossDomain, url) {\n        var result = [];\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            if (_transports[type].accept(version, crossDomain, url) === true) {\n                result.push(type);\n            }\n        }\n        return result;\n    };\n\n    this.negotiateTransport = function(types, version, crossDomain, url) {\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            for (var j = 0; j < types.length; ++j) {\n                if (type === types[j]) {\n                    var transport = _transports[type];\n                    if (transport.accept(version, crossDomain, url) === true) {\n                        return transport;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    this.add = function(type, transport, index) {\n        var existing = false;\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                existing = true;\n                break;\n            }\n        }\n\n        if (!existing) {\n            if (typeof index !== 'number') {\n                _types.push(type);\n            } else {\n                _types.splice(index, 0, type);\n            }\n            _transports[type] = transport;\n        }\n\n        return !existing;\n    };\n\n    this.find = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                return _transports[type];\n            }\n        }\n        return null;\n    };\n\n    this.remove = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                _types.splice(i, 1);\n                var transport = _transports[type];\n                delete _transports[type];\n                return transport;\n            }\n        }\n        return null;\n    };\n\n    this.clear = function() {\n        _types = [];\n        _transports = {};\n    };\n\n    this.reset = function(init) {\n        for (var i = 0; i < _types.length; ++i) {\n            _transports[_types[i]].reset(init);\n        }\n    };\n};\n","exports.isString = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return typeof value === 'string' || value instanceof String;\n};\n\nexports.isArray = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return value instanceof Array;\n};\n\n/**\n * Returns whether the given element is contained into the given array.\n * @param element the element to check presence for\n * @param array the array to check for the element presence\n * @return the index of the element, if present, or a negative index if the element is not present\n */\nexports.inArray = function (element, array) {\n    for (var i = 0; i < array.length; ++i) {\n        if (element === array[i]) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nexports.setTimeout = function (cometd, funktion, delay) {\n    return setTimeout(function() {\n        try {\n            cometd._debug('Invoking timed function', funktion);\n            funktion();\n        } catch (x) {\n            cometd._debug('Exception invoking timed function', funktion, x);\n        }\n    }, delay);\n};\n\nexports.clearTimeout = function (timeoutHandle) {\n    clearTimeout(timeoutHandle);\n};\n","var TransportRegistry = require('./TransportRegistry');\nvar Utils = require('./Utils');\n/**\n * The constructor for a CometD object, identified by an optional name.\n * The default name is the string 'default'.\n * In the rare case a page needs more than one Bayeux conversation,\n * a new instance can be created via:\n * <pre>\n * var bayeuxUrl2 = ...;\n *\n * // Dojo style\n * var cometd2 = new dojox.CometD('another_optional_name');\n *\n * // jQuery style\n * var cometd2 = new $.CometD('another_optional_name');\n *\n * cometd2.init({url: bayeuxUrl2});\n * </pre>\n * @param name the optional name of this cometd object\n */\nmodule.exports = function CometD(name) {\n    var _cometd = this;\n    var _name = name || 'default';\n    var _crossDomain = false;\n    var _transports = new TransportRegistry();\n    var _transport;\n    var _status = 'disconnected';\n    var _messageId = 0;\n    var _clientId = null;\n    var _batch = 0;\n    var _messageQueue = [];\n    var _internalBatch = false;\n    var _listeners = {};\n    var _backoff = 0;\n    var _scheduledSend = null;\n    var _extensions = [];\n    var _advice = {};\n    var _handshakeProps;\n    var _handshakeCallback;\n    var _callbacks = {};\n    var _remoteCalls = {};\n    var _reestablish = false;\n    var _connected = false;\n    var _unconnectTime = 0;\n    var _handshakeMessages = 0;\n    var _config = {\n        protocol: null,\n        stickyReconnect: true,\n        connectTimeout: 0,\n        maxConnections: 2,\n        backoffIncrement: 1000,\n        maxBackoff: 60000,\n        logLevel: 'info',\n        reverseIncomingExtensions: true,\n        maxNetworkDelay: 10000,\n        requestHeaders: {},\n        appendMessageTypeToURL: true,\n        autoBatch: false,\n        urls: {},\n        maxURILength: 2000,\n        advice: {\n            timeout: 60000,\n            interval: 0,\n            reconnect: 'retry',\n            maxInterval: 0\n        }\n    };\n\n    function _fieldValue(object, name) {\n        try {\n            return object[name];\n        } catch (x) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Mixes in the given objects into the target object by copying the properties.\n     * @param deep if the copy must be deep\n     * @param target the target object\n     * @param objects the objects whose properties are copied into the target\n     */\n    this._mixin = function(deep, target, objects) {\n        var result = target || {};\n\n        // Skip first 2 parameters (deep and target), and loop over the others\n        for (var i = 2; i < arguments.length; ++i) {\n            var object = arguments[i];\n\n            if (object === undefined || object === null) {\n                continue;\n            }\n\n            for (var propName in object) {\n                if (object.hasOwnProperty(propName)) {\n                    var prop = _fieldValue(object, propName);\n                    var targ = _fieldValue(result, propName);\n\n                    // Avoid infinite loops\n                    if (prop === target) {\n                        continue;\n                    }\n                    // Do not mixin undefined values\n                    if (prop === undefined) {\n                        continue;\n                    }\n\n                    if (deep && typeof prop === 'object' && prop !== null) {\n                        if (prop instanceof Array) {\n                            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n                        } else {\n                            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                            result[propName] = this._mixin(deep, source, prop);\n                        }\n                    } else {\n                        result[propName] = prop;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    function _isString(value) {\n        return Utils.isString(value);\n    }\n\n    function _isFunction(value) {\n        if (value === undefined || value === null) {\n            return false;\n        }\n        return typeof value === 'function';\n    }\n\n    function _zeroPad(value, length) {\n        var result = '';\n        while (--length > 0) {\n            if (value >= Math.pow(10, length)) {\n                break;\n            }\n            result += '0';\n        }\n        result += value;\n        return result;\n    }\n\n    function _log(level, args) {\n        if ('undefined' !== typeof console) {\n            var logger = console[level];\n            if (_isFunction(logger)) {\n                var now = new Date();\n                [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n                logger.apply(console, args);\n            }\n        }\n    }\n\n    this._warn = function() {\n        _log('warn', arguments);\n    };\n\n    this._info = function() {\n        if (_config.logLevel !== 'warn') {\n            _log('info', arguments);\n        }\n    };\n\n    this._debug = function() {\n        if (_config.logLevel === 'debug') {\n            _log('debug', arguments);\n        }\n    };\n\n    function _splitURL(url) {\n        // [1] = protocol://,\n        // [2] = host:port,\n        // [3] = host,\n        // [4] = IPv6_host,\n        // [5] = IPv4_host,\n        // [6] = :port,\n        // [7] = port,\n        // [8] = uri,\n        // [9] = rest (query / fragment)\n        return /(^https?:\\/\\/)?(((\\[[^\\]]+\\])|([^:\\/\\?#]+))(:(\\d+))?)?([^\\?#]*)(.*)?/.exec(url);\n    }\n\n    /**\n     * Returns whether the given hostAndPort is cross domain.\n     * The default implementation checks against window.location.host\n     * but this function can be overridden to make it work in non-browser\n     * environments.\n     *\n     * @param hostAndPort the host and port in format host:port\n     * @return whether the given hostAndPort is cross domain\n     */\n    this._isCrossDomain = function(hostAndPort) {\n        var host = typeof location === 'undefined' ? hostAndPort : location.host;\n        return hostAndPort && hostAndPort !== host;\n    };\n\n    function _configure(configuration) {\n        _cometd._debug('Configuring cometd object with', configuration);\n        // Support old style param, where only the Bayeux server URL was passed\n        if (_isString(configuration)) {\n            configuration = { url: configuration };\n        }\n        if (!configuration) {\n            configuration = {};\n        }\n\n        _config = _cometd._mixin(false, _config, configuration);\n\n        var url = _cometd.getURL();\n        if (!url) {\n            throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n        }\n\n        // Check if we're cross domain.\n        var urlParts = _splitURL(url);\n        var hostAndPort = urlParts[2];\n        var uri = urlParts[8];\n        var afterURI = urlParts[9];\n        _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\n        // Check if appending extra path is supported\n        if (_config.appendMessageTypeToURL) {\n            if (afterURI !== undefined && afterURI.length > 0) {\n                _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                _config.appendMessageTypeToURL = false;\n            } else {\n                var uriSegments = uri.split('/');\n                var lastSegmentIndex = uriSegments.length - 1;\n                if (uri.match(/\\/$/)) {\n                    lastSegmentIndex -= 1;\n                }\n                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n                    // It will be difficult to add the extra path in this case\n                    _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                    _config.appendMessageTypeToURL = false;\n                }\n            }\n        }\n    }\n\n    function _removeListener(subscription) {\n        if (subscription) {\n            var subscriptions = _listeners[subscription.channel];\n            if (subscriptions && subscriptions[subscription.id]) {\n                delete subscriptions[subscription.id];\n                _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n            }\n        }\n    }\n\n    function _removeSubscription(subscription) {\n        if (subscription && !subscription.listener) {\n            _removeListener(subscription);\n        }\n    }\n\n    function _clearSubscriptions() {\n        for (var channel in _listeners) {\n            if (_listeners.hasOwnProperty(channel)) {\n                var subscriptions = _listeners[channel];\n                if (subscriptions) {\n                    for (var i = 0; i < subscriptions.length; ++i) {\n                        _removeSubscription(subscriptions[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    function _setStatus(newStatus) {\n        if (_status !== newStatus) {\n            _cometd._debug('Status', _status, '->', newStatus);\n            _status = newStatus;\n        }\n    }\n\n    function _isDisconnected() {\n        return _status === 'disconnecting' || _status === 'disconnected';\n    }\n\n    function _nextMessageId() {\n        var result = ++_messageId;\n        return '' + result;\n    }\n\n    function _applyExtension(scope, callback, name, message, outgoing) {\n        try {\n            return callback.call(scope, message);\n        } catch (x) {\n            var handler = _cometd.onExtensionException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking extension exception handler', name, x);\n                try {\n                    handler.call(_cometd, x, name, outgoing, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of extension exception handler', name, xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of extension', name, x);\n            }\n            return message;\n        }\n    }\n\n    function _applyIncomingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;\n            var extension = _extensions[index];\n            var callback = extension.extension.incoming;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _applyOutgoingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var extension = _extensions[i];\n            var callback = extension.extension.outgoing;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _notify(channel, message) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions && subscriptions.length > 0) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                var subscription = subscriptions[i];\n                // Subscriptions may come and go, so the array may have 'holes'\n                if (subscription) {\n                    try {\n                        subscription.callback.call(subscription.scope, message);\n                    } catch (x) {\n                        var handler = _cometd.onListenerException;\n                        if (_isFunction(handler)) {\n                            _cometd._debug('Invoking listener exception handler', subscription, x);\n                            try {\n                                handler.call(_cometd, x, subscription, subscription.listener, message);\n                            } catch (xx) {\n                                _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                            }\n                        } else {\n                            _cometd._info('Exception during execution of listener', subscription, message, x);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function _notifyListeners(channel, message) {\n        // Notify direct listeners\n        _notify(channel, message);\n\n        // Notify the globbing listeners\n        var channelParts = channel.split('/');\n        var last = channelParts.length - 1;\n        for (var i = last; i > 0; --i) {\n            var channelPart = channelParts.slice(0, i).join('/') + '/*';\n            // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n            // so we stop at the first non recursive globbing\n            if (i === last) {\n                _notify(channelPart, message);\n            }\n            // Add the recursive globber and notify\n            channelPart += '*';\n            _notify(channelPart, message);\n        }\n    }\n\n    function _cancelDelayedSend() {\n        if (_scheduledSend !== null) {\n            Utils.clearTimeout(_scheduledSend);\n        }\n        _scheduledSend = null;\n    }\n\n    function _delayedSend(operation, delay) {\n        if ('undefined' === typeof delay) {\n          delay = _backoff\n        }\n        _cancelDelayedSend();\n        var time = _advice.interval + delay;\n        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n        _scheduledSend = Utils.setTimeout(_cometd, operation, time);\n    }\n\n    // Needed to break cyclic dependencies between function definitions\n    var _handleMessages;\n    var _handleFailure;\n\n    /**\n     * Delivers the messages to the CometD server\n     * @param sync whether the send is synchronous\n     * @param messages the array of messages to send\n     * @param metaConnect true if this send is on /meta/connect\n     * @param extraPath an extra path to append to the Bayeux server URL\n     */\n    function _send(sync, messages, metaConnect, extraPath) {\n        // We must be sure that the messages have a clientId.\n        // This is not guaranteed since the handshake may take time to return\n        // (and hence the clientId is not known yet) and the application\n        // may create other messages.\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var messageId = message.id;\n\n            if (_clientId) {\n                message.clientId = _clientId;\n            }\n\n            message = _applyOutgoingExtensions(message);\n            if (message !== undefined && message !== null) {\n                // Extensions may have modified the message id, but we need to own it.\n                message.id = messageId;\n                messages[i] = message;\n            } else {\n                delete _callbacks[messageId];\n                messages.splice(i--, 1);\n            }\n        }\n\n        if (messages.length === 0) {\n            return;\n        }\n\n        var url = _cometd.getURL();\n        if (_config.appendMessageTypeToURL) {\n            // If url does not end with '/', then append it\n            if (!url.match(/\\/$/)) {\n                url = url + '/';\n            }\n            if (extraPath) {\n                url = url + extraPath;\n            }\n        }\n\n        var envelope = {\n            url: url,\n            sync: sync,\n            messages: messages,\n            onSuccess: function(rcvdMessages) {\n                try {\n                    _handleMessages.call(_cometd, rcvdMessages);\n                } catch (x) {\n                    _cometd._info('Exception during handling of messages', x);\n                }\n            },\n            onFailure: function(conduit, messages, failure) {\n                try {\n                    var transport = _cometd.getTransport();\n                    failure.connectionType = transport ? transport.getType() : \"unknown\";\n                    _handleFailure.call(_cometd, conduit, messages, failure);\n                } catch (x) {\n                    _cometd._info('Exception during handling of failure', x);\n                }\n            }\n        };\n        _cometd._debug('Send', envelope);\n        _transport.send(envelope, metaConnect);\n    }\n\n    function _queueSend(message) {\n        if (_batch > 0 || _internalBatch === true) {\n            _messageQueue.push(message);\n        } else {\n            _send(false, [message], false);\n        }\n    }\n\n    /**\n     * Sends a complete bayeux message.\n     * This method is exposed as a public so that extensions may use it\n     * to send bayeux message directly, for example in case of re-sending\n     * messages that have already been sent but that for some reason must\n     * be resent.\n     */\n    this.send = _queueSend;\n\n    function _resetBackoff() {\n        _backoff = 0;\n    }\n\n    function _increaseBackoff() {\n        if (_backoff < _config.maxBackoff) {\n            _backoff += _config.backoffIncrement;\n        }\n        return _backoff;\n    }\n\n    /**\n     * Starts a the batch of messages to be sent in a single request.\n     * @see #_endBatch(sendMessages)\n     */\n    function _startBatch() {\n        ++_batch;\n        _cometd._debug('Starting batch, depth', _batch);\n    }\n\n    function _flushBatch() {\n        var messages = _messageQueue;\n        _messageQueue = [];\n        if (messages.length > 0) {\n            _send(false, messages, false);\n        }\n    }\n\n    /**\n     * Ends the batch of messages to be sent in a single request,\n     * optionally sending messages present in the message queue depending\n     * on the given argument.\n     * @see #_startBatch()\n     */\n    function _endBatch() {\n        --_batch;\n        _cometd._debug('Ending batch, depth', _batch);\n        if (_batch < 0) {\n            throw 'Calls to startBatch() and endBatch() are not paired';\n        }\n\n        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n            _flushBatch();\n        }\n    }\n\n    /**\n     * Sends the connect message\n     */\n    function _connect() {\n        if (!_isDisconnected()) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/connect',\n                connectionType: _transport.getType()\n            };\n\n            // In case of reload or temporary loss of connection\n            // we want the next successful connect to return immediately\n            // instead of being held by the server, so that connect listeners\n            // can be notified that the connection has been re-established\n            if (!_connected) {\n                bayeuxMessage.advice = { timeout: 0 };\n            }\n\n            _setStatus('connecting');\n            _cometd._debug('Connect sent', bayeuxMessage);\n            _send(false, [bayeuxMessage], true, 'connect');\n            _setStatus('connected');\n        }\n    }\n\n    function _delayedConnect(delay) {\n        _setStatus('connecting');\n        _delayedSend(function() {\n            _connect();\n        }, delay);\n    }\n\n    function _updateAdvice(newAdvice) {\n        if (newAdvice) {\n            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n            _cometd._debug('New advice', _advice);\n        }\n    }\n\n    function _disconnect(abort) {\n        _cancelDelayedSend();\n        if (abort && _transport) {\n            _transport.abort();\n        }\n        _clientId = null;\n        _setStatus('disconnected');\n        _batch = 0;\n        _resetBackoff();\n        _transport = null;\n\n        // Fail any existing queued message\n        if (_messageQueue.length > 0) {\n            var messages = _messageQueue;\n            _messageQueue = [];\n            _handleFailure.call(_cometd, undefined, messages, {\n                reason: 'Disconnected'\n            });\n        }\n    }\n\n    function _notifyTransportFailure(oldTransport, newTransport, failure) {\n        var handler = _cometd.onTransportException;\n        if (_isFunction(handler)) {\n            _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n            try {\n                handler.call(_cometd, failure, oldTransport, newTransport);\n            } catch (x) {\n                _cometd._info('Exception during execution of transport exception handler', x);\n            }\n        }\n    }\n\n    /**\n     * Sends the initial handshake message\n     */\n    function _handshake(handshakeProps, handshakeCallback) {\n        if (_isFunction(handshakeProps)) {\n            handshakeCallback = handshakeProps;\n            handshakeProps = undefined;\n        }\n\n        _clientId = null;\n\n        _clearSubscriptions();\n\n        // Reset the transports if we're not retrying the handshake\n        if (_isDisconnected()) {\n            _transports.reset(true);\n            _updateAdvice(_config.advice);\n        } else {\n            // We are retrying the handshake, either because another handshake failed\n            // and we're backing off, or because the server timed us out and asks us to\n            // re-handshake: in both cases, make sure that if the handshake succeeds\n            // the next action is a connect.\n            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));\n        }\n\n        _batch = 0;\n\n        // Mark the start of an internal batch.\n        // This is needed because handshake and connect are async.\n        // It may happen that the application calls init() then subscribe()\n        // and the subscribe message is sent before the connect message, if\n        // the subscribe message is not held until the connect message is sent.\n        // So here we start a batch to hold temporarily any message until\n        // the connection is fully established.\n        _internalBatch = true;\n\n        // Save the properties provided by the user, so that\n        // we can reuse them during automatic re-handshake\n        _handshakeProps = handshakeProps;\n        _handshakeCallback = handshakeCallback;\n\n        var version = '1.0';\n\n        // Figure out the transports to send to the server\n        var url = _cometd.getURL();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            version: version,\n            minimumVersion: version,\n            channel: '/meta/handshake',\n            supportedConnectionTypes: transportTypes,\n            advice: {\n                timeout: _advice.timeout,\n                interval: _advice.interval\n            }\n        };\n        // Do not allow the user to override important fields.\n        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, handshakeCallback);\n\n        // Pick up the first available transport as initial transport\n        // since we don't know if the server supports it\n        if (!_transport) {\n            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n            if (!_transport) {\n                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                _cometd._warn(failure);\n                throw failure;\n            }\n        }\n\n        _cometd._debug('Initial transport is', _transport.getType());\n\n        // We started a batch to hold the application messages,\n        // so here we must bypass it and send immediately.\n        _setStatus('handshaking');\n        _cometd._debug('Handshake sent', message);\n        _send(false, [message], false, 'handshake');\n    }\n\n    function _delayedHandshake(delay) {\n        _setStatus('handshaking');\n\n        // We will call _handshake() which will reset _clientId, but we want to avoid\n        // that between the end of this method and the call to _handshake() someone may\n        // call publish() (or other methods that call _queueSend()).\n        _internalBatch = true;\n\n        _delayedSend(function() {\n            _handshake(_handshakeProps, _handshakeCallback);\n        }, delay);\n    }\n\n    function _notifyCallback(callback, message) {\n        try {\n            callback.call(_cometd, message);\n        } catch (x) {\n            var handler = _cometd.onCallbackException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking callback exception handler', x);\n                try {\n                    handler.call(_cometd, x, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of callback exception handler', xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of message callback', x);\n            }\n        }\n    }\n\n    this._getCallback = function(messageId) {\n        return _callbacks[messageId];\n    };\n\n    this._putCallback = function(messageId, callback) {\n        var result = this._getCallback(messageId);\n        if (_isFunction(callback)) {\n            _callbacks[messageId] = callback;\n        }\n        return result;\n    };\n\n    function _handleCallback(message) {\n        var callback = _cometd._getCallback([message.id]);\n        if (_isFunction(callback)) {\n            delete _callbacks[message.id];\n            _notifyCallback(callback, message);\n        }\n    }\n\n    function _handleRemoteCall(message) {\n        var context = _remoteCalls[message.id];\n        delete _remoteCalls[message.id];\n        _cometd._debug('Handling remote call response for', message, 'with context', context);\n        if (context) {\n            // Clear the timeout, if present.\n            var timeout = context.timeout;\n            if (timeout) {\n                Utils.clearTimeout(timeout);\n            }\n\n            var callback = context.callback;\n            if (_isFunction(callback)) {\n                _notifyCallback(callback, message);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _failHandshake(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/handshake', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // Only try again if we haven't been disconnected and\n        // the advice permits us to retry the handshake\n        var retry = !_isDisconnected() && _advice.reconnect !== 'none';\n        if (retry) {\n            _increaseBackoff();\n            _delayedHandshake();\n        } else {\n            _disconnect(true);\n        }\n    }\n\n    function _handshakeResponse(message) {\n        if (message.successful) {\n            // Save clientId, figure out transport, then follow the advice to connect\n            _clientId = message.clientId;\n\n            var url = _cometd.getURL();\n            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);\n            if (newTransport === null) {\n                var failure = 'Could not negotiate transport with server; client=[' +\n                    _transports.findTransportTypes(message.version, _crossDomain, url) +\n                    '], server=[' + message.supportedConnectionTypes + ']';\n                var oldTransport = _cometd.getTransport();\n                _notifyTransportFailure(oldTransport.getType(), null, {\n                    reason: failure,\n                    connectionType: oldTransport.getType(),\n                    transport: oldTransport\n                });\n                _cometd._warn(failure);\n                _disconnect(true);\n                return;\n            } else if (_transport !== newTransport) {\n                _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n                _transport = newTransport;\n            }\n\n            // End the internal batch and allow held messages from the application\n            // to go to the server (see _handshake() where we start the internal batch).\n            _internalBatch = false;\n            _flushBatch();\n\n            // Here the new transport is in place, as well as the clientId, so\n            // the listeners can perform a publish() if they want.\n            // Notify the listeners before the connect below.\n            message.reestablish = _reestablish;\n            _reestablish = true;\n\n            _handleCallback(message);\n            _notifyListeners('/meta/handshake', message);\n\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    _disconnect(true);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failHandshake(message);\n        }\n    }\n\n    function _handshakeFailure(message) {\n        var version = '1.0';\n        var url = _cometd.getURL();\n        var oldTransport = _cometd.getTransport();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n        var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n        if (!newTransport) {\n            _notifyTransportFailure(oldTransport.getType(), null, message.failure);\n            _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');\n            _disconnect(true);\n            _failHandshake(message);\n        } else {\n            _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());\n            _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);\n            _failHandshake(message);\n            _transport = newTransport;\n        }\n    }\n\n    function _failConnect(message) {\n        // Notify the listeners after the status change but before the next action\n        _notifyListeners('/meta/connect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // This may happen when the server crashed, the current clientId\n        // will be invalid, and the server will ask to handshake again\n        // Listeners can call disconnect(), so check the state after they run\n        var action = _isDisconnected() ? 'none' : _advice.reconnect;\n        switch (action) {\n            case 'retry':\n                _delayedConnect();\n                _increaseBackoff();\n                break;\n            case 'handshake':\n                // The current transport may be failed (e.g. network disconnection)\n                // Reset the transports so the new handshake picks up the right one\n                _transports.reset(true);\n                _resetBackoff();\n                _delayedHandshake();\n                break;\n            case 'none':\n                _disconnect(true);\n                break;\n            default:\n                throw 'Unrecognized advice action' + action;\n        }\n    }\n\n    function _connectResponse(message) {\n        _connected = message.successful;\n\n        if (_connected) {\n            _notifyListeners('/meta/connect', message);\n\n            // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n            // and the server will hold the request, so when a response returns\n            // we immediately call the server again (long polling)\n            // Listeners can call disconnect(), so check the state after they run\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    // Wait for the /meta/disconnect to arrive.\n                    _disconnect(false);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failConnect(message);\n        }\n    }\n\n    function _connectFailure(message) {\n        _connected = false;\n        _failConnect(message);\n    }\n\n    function _failDisconnect(message) {\n        _disconnect(true);\n        _handleCallback(message);\n        _notifyListeners('/meta/disconnect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _disconnectResponse(message) {\n        if (message.successful) {\n            // Wait for the /meta/connect to arrive.\n            _disconnect(false);\n            _handleCallback(message);\n            _notifyListeners('/meta/disconnect', message);\n        } else {\n            _failDisconnect(message);\n        }\n    }\n\n    function _disconnectFailure(message) {\n        _failDisconnect(message);\n    }\n\n    function _failSubscribe(message) {\n        var subscriptions = _listeners[message.subscription];\n        if (subscriptions) {\n            for (var i = subscriptions.length - 1; i >= 0; --i) {\n                var subscription = subscriptions[i];\n                if (subscription && !subscription.listener) {\n                    delete subscriptions[i];\n                    _cometd._debug('Removed failed subscription', subscription);\n                    break;\n                }\n            }\n        }\n        _handleCallback(message);\n        _notifyListeners('/meta/subscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _subscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/subscribe', message);\n        } else {\n            _failSubscribe(message);\n        }\n    }\n\n    function _subscribeFailure(message) {\n        _failSubscribe(message);\n    }\n\n    function _failUnsubscribe(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/unsubscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _unsubscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/unsubscribe', message);\n        } else {\n            _failUnsubscribe(message);\n        }\n    }\n\n    function _unsubscribeFailure(message) {\n        _failUnsubscribe(message);\n    }\n\n    function _failMessage(message) {\n        if (!_handleRemoteCall(message)) {\n            _handleCallback(message);\n            _notifyListeners('/meta/publish', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n    }\n\n    function _messageResponse(message) {\n        if (message.data !== undefined) {\n            if (!_handleRemoteCall(message)) {\n                _notifyListeners(message.channel, message);\n                if (_handshakeMessages > 0) {\n                    --_handshakeMessages;\n                    if (_handshakeMessages === 0) {\n                        _cometd._debug('Processed last handshake-delivered message');\n                        _delayedConnect(0);\n                    }\n                }\n            }\n        } else {\n            if (message.successful === undefined) {\n                _cometd._warn('Unknown Bayeux Message', message);\n            } else {\n                if (message.successful) {\n                    _handleCallback(message);\n                    _notifyListeners('/meta/publish', message);\n                } else {\n                    _failMessage(message);\n                }\n            }\n        }\n    }\n\n    function _messageFailure(failure) {\n        _failMessage(failure);\n    }\n\n    function _receive(message) {\n        _unconnectTime = 0;\n\n        message = _applyIncomingExtensions(message);\n        if (message === undefined || message === null) {\n            return;\n        }\n\n        _updateAdvice(message.advice);\n\n        var channel = message.channel;\n        switch (channel) {\n            case '/meta/handshake':\n                _handshakeResponse(message);\n                break;\n            case '/meta/connect':\n                _connectResponse(message);\n                break;\n            case '/meta/disconnect':\n                _disconnectResponse(message);\n                break;\n            case '/meta/subscribe':\n                _subscribeResponse(message);\n                break;\n            case '/meta/unsubscribe':\n                _unsubscribeResponse(message);\n                break;\n            default:\n                _messageResponse(message);\n                break;\n        }\n    }\n\n    /**\n     * Receives a message.\n     * This method is exposed as a public so that extensions may inject\n     * messages simulating that they had been received.\n     */\n    this.receive = _receive;\n\n    _handleMessages = function(rcvdMessages) {\n        _cometd._debug('Received', rcvdMessages);\n\n        for (var i = 0; i < rcvdMessages.length; ++i) {\n            var message = rcvdMessages[i];\n            _receive(message);\n        }\n    };\n\n    _handleFailure = function(conduit, messages, failure) {\n        _cometd._debug('handleFailure', conduit, messages, failure);\n\n        failure.transport = conduit;\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var failureMessage = {\n                id: message.id,\n                successful: false,\n                channel: message.channel,\n                failure: failure\n            };\n            failure.message = message;\n            switch (message.channel) {\n                case '/meta/handshake':\n                    _handshakeFailure(failureMessage);\n                    break;\n                case '/meta/connect':\n                    _connectFailure(failureMessage);\n                    break;\n                case '/meta/disconnect':\n                    _disconnectFailure(failureMessage);\n                    break;\n                case '/meta/subscribe':\n                    failureMessage.subscription = message.subscription;\n                    _subscribeFailure(failureMessage);\n                    break;\n                case '/meta/unsubscribe':\n                    failureMessage.subscription = message.subscription;\n                    _unsubscribeFailure(failureMessage);\n                    break;\n                default:\n                    _messageFailure(failureMessage);\n                    break;\n            }\n        }\n    };\n\n    function _hasSubscriptions(channel) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                if (subscriptions[i]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function _resolveScopedCallback(scope, callback) {\n        var delegate = {\n            scope: scope,\n            method: callback\n        };\n        if (_isFunction(scope)) {\n            delegate.scope = undefined;\n            delegate.method = scope;\n        } else {\n            if (_isString(callback)) {\n                if (!scope) {\n                    throw 'Invalid scope ' + scope;\n                }\n                delegate.method = scope[callback];\n                if (!_isFunction(delegate.method)) {\n                    throw 'Invalid callback ' + callback + ' for scope ' + scope;\n                }\n            } else if (!_isFunction(callback)) {\n                throw 'Invalid callback ' + callback;\n            }\n        }\n        return delegate;\n    }\n\n    function _addListener(channel, scope, callback, isListener) {\n        // The data structure is a map<channel, subscription[]>, where each subscription\n        // holds the callback to be called and its scope.\n\n        var delegate = _resolveScopedCallback(scope, callback);\n        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n        var subscription = {\n            channel: channel,\n            scope: delegate.scope,\n            callback: delegate.method,\n            listener: isListener\n        };\n\n        var subscriptions = _listeners[channel];\n        if (!subscriptions) {\n            subscriptions = [];\n            _listeners[channel] = subscriptions;\n        }\n\n        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.\n        // Note that if:\n        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');\n        // then:\n        // hc==3, a.join()=='a',,'c', a.length==3\n        subscription.id = subscriptions.push(subscription) - 1;\n\n        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n        // For backward compatibility: we used to return [channel, subscription.id]\n        subscription[0] = channel;\n        subscription[1] = subscription.id;\n\n        return subscription;\n    }\n\n    //\n    // PUBLIC API\n    //\n\n    /**\n     * Registers the given transport under the given transport type.\n     * The optional index parameter specifies the \"priority\" at which the\n     * transport is registered (where 0 is the max priority).\n     * If a transport with the same type is already registered, this function\n     * does nothing and returns false.\n     * @param type the transport type\n     * @param transport the transport object\n     * @param index the index at which this transport is to be registered\n     * @return true if the transport has been registered, false otherwise\n     * @see #unregisterTransport(type)\n     */\n    this.registerTransport = function(type, transport, index) {\n        var result = _transports.add(type, transport, index);\n        if (result) {\n            this._debug('Registered transport', type);\n\n            if (_isFunction(transport.registered)) {\n                transport.registered(type, this);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Unregisters the transport with the given transport type.\n     * @param type the transport type to unregister\n     * @return the transport that has been unregistered,\n     * or null if no transport was previously registered under the given transport type\n     */\n    this.unregisterTransport = function(type) {\n        var transport = _transports.remove(type);\n        if (transport !== null) {\n            this._debug('Unregistered transport', type);\n\n            if (_isFunction(transport.unregistered)) {\n                transport.unregistered();\n            }\n        }\n        return transport;\n    };\n\n    this.unregisterTransports = function() {\n        _transports.clear();\n    };\n\n    /**\n     * @return an array of all registered transport types\n     */\n    this.getTransportTypes = function() {\n        return _transports.getTransportTypes();\n    };\n\n    this.findTransport = function(name) {\n        return _transports.find(name);\n    };\n\n    /**\n     * @returns the TransportRegistry object\n     */\n    this.getTransportRegistry = function() {\n        return _transports;\n    };\n\n    /**\n     * Configures the initial Bayeux communication with the Bayeux server.\n     * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n     * of type string containing the URL of the Bayeux server.\n     * @param configuration the configuration object\n     */\n    this.configure = function(configuration) {\n        _configure.call(this, configuration);\n    };\n\n    /**\n     * Configures and establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param configuration the configuration object\n     * @param handshakeProps an object to be merged with the handshake message\n     * @see #configure(configuration)\n     * @see #handshake(handshakeProps)\n     */\n    this.init = function(configuration, handshakeProps) {\n        this.configure(configuration);\n        this.handshake(handshakeProps);\n    };\n\n    /**\n     * Establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param handshakeProps an object to be merged with the handshake message\n     * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n     */\n    this.handshake = function(handshakeProps, handshakeCallback) {\n        _setStatus('disconnected');\n        _reestablish = false;\n        _handshake(handshakeProps, handshakeCallback);\n    };\n\n    /**\n     * Disconnects from the Bayeux server.\n     * It is possible to suggest to attempt a synchronous disconnect, but this feature\n     * may only be available in certain transports (for example, long-polling may support\n     * it, callback-polling certainly does not).\n     * @param sync whether attempt to perform a synchronous disconnect\n     * @param disconnectProps an object to be merged with the disconnect message\n     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n     */\n    this.disconnect = function(sync, disconnectProps, disconnectCallback) {\n        if (_isDisconnected()) {\n            return;\n        }\n\n        if (typeof sync !== 'boolean') {\n            disconnectCallback = disconnectProps;\n            disconnectProps = sync;\n            sync = false;\n        }\n        if (_isFunction(disconnectProps)) {\n            disconnectCallback = disconnectProps;\n            disconnectProps = undefined;\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: '/meta/disconnect'\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, disconnectCallback);\n\n        _setStatus('disconnecting');\n        _send(sync === true, [message], false, 'disconnect');\n    };\n\n    /**\n     * Marks the start of a batch of application messages to be sent to the server\n     * in a single request, obtaining a single response containing (possibly) many\n     * application reply messages.\n     * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n     * If startBatch() is called multiple times, then an equal number of endBatch()\n     * calls must be made to close and send the batch of messages.\n     * @see #endBatch()\n     */\n    this.startBatch = function() {\n        _startBatch();\n    };\n\n    /**\n     * Marks the end of a batch of application messages to be sent to the server\n     * in a single request.\n     * @see #startBatch()\n     */\n    this.endBatch = function() {\n        _endBatch();\n    };\n\n    /**\n     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n     * and {@link #endBatch()} calls.\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n     */\n    this.batch = function(scope, callback) {\n        var delegate = _resolveScopedCallback(scope, callback);\n        this.startBatch();\n        try {\n            delegate.method.call(delegate.scope);\n            this.endBatch();\n        } catch (x) {\n            this._info('Exception during execution of batch', x);\n            this.endBatch();\n            throw x;\n        }\n    };\n\n    /**\n     * Adds a listener for bayeux messages, performing the given callback in the given scope\n     * when a message for the given channel arrives.\n     * @param channel the channel the listener is interested to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @returns the subscription handle to be passed to {@link #removeListener(object)}\n     * @see #removeListener(subscription)\n     */\n    this.addListener = function(channel, scope, callback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n\n        return _addListener(channel, scope, callback, true);\n    };\n\n    /**\n     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @see #addListener(channel, scope, callback)\n     */\n    this.removeListener = function(subscription) {\n        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n        if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n            throw 'Invalid argument: expected subscription, not ' + subscription;\n        }\n\n        _removeListener(subscription);\n    };\n\n    /**\n     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n     * {@link #subscribe(channel, scope, callback)}.\n     */\n    this.clearListeners = function() {\n        _listeners = {};\n    };\n\n    /**\n     * Subscribes to the given channel, performing the given callback in the given scope\n     * when a message for the channel arrives.\n     * @param channel the channel to subscribe to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @param subscribeProps an object to be merged with the subscribe message\n     * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n     * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n     */\n    this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        // Normalize arguments\n        if (_isFunction(scope)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = callback;\n            callback = scope;\n            scope = undefined;\n        }\n        if (_isFunction(subscribeProps)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = undefined;\n        }\n\n        // Only send the message to the server if this client has not yet subscribed to the channel\n        var send = !_hasSubscriptions(channel);\n\n        var subscription = _addListener(channel, scope, callback, false);\n\n        if (send) {\n            // Send the subscription message after the subscription registration to avoid\n            // races where the server would send a message to the subscribers, but here\n            // on the client the subscription has not been added yet to the data structures\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/subscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, subscribeCallback);\n\n            _queueSend(message);\n        }\n\n        return subscription;\n    };\n\n    /**\n     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @param unsubscribeProps an object to be merged with the unsubscribe message\n     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n     */\n    this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(unsubscribeProps)) {\n            unsubscribeCallback = unsubscribeProps;\n            unsubscribeProps = undefined;\n        }\n\n        // Remove the local listener before sending the message\n        // This ensures that if the server fails, this client does not get notifications\n        this.removeListener(subscription);\n\n        var channel = subscription.channel;\n        // Only send the message to the server if this client unsubscribes the last subscription\n        if (!_hasSubscriptions(channel)) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/unsubscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, unsubscribeCallback);\n\n            _queueSend(message);\n        }\n    };\n\n    this.resubscribe = function(subscription, subscribeProps) {\n        _removeSubscription(subscription);\n        if (subscription) {\n            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n        }\n        return undefined;\n    };\n\n    /**\n     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n     */\n    this.clearSubscriptions = function() {\n        _clearSubscriptions();\n    };\n\n    /**\n     * Publishes a message on the given channel, containing the given content.\n     * @param channel the channel to publish the message to\n     * @param content the content of the message\n     * @param publishProps an object to be merged with the publish message\n     * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n     */\n    this.publish = function(channel, content, publishProps, publishCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (/^\\/meta\\//.test(channel)) {\n            throw 'Illegal argument: cannot publish to meta channels';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            publishCallback = content;\n            content = publishProps = {};\n        } else if (_isFunction(publishProps)) {\n            publishCallback = publishProps;\n            publishProps = {};\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, publishCallback);\n\n        _queueSend(message);\n    };\n\n    this.remoteCall = function(target, content, timeout, callback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(target)) {\n            throw 'Illegal argument type: target must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            callback = content;\n            content = {};\n            timeout = _config.maxNetworkDelay;\n        } else if (_isFunction(timeout)) {\n            callback = timeout;\n            timeout = _config.maxNetworkDelay;\n        }\n\n        if (typeof timeout !== 'number') {\n            throw 'Illegal argument type: timeout must be a number';\n        }\n\n        if (!target.match(/^\\//)) {\n            target = '/' + target;\n        }\n        var channel = '/service' + target;\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n\n        var context = {\n            callback: callback\n        };\n        if (timeout > 0) {\n            context.timeout = Utils.setTimeout(_cometd, function() {\n                _cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');\n                _failMessage({\n                    id: bayeuxMessage.id,\n                    error: '406::timeout',\n                    successful: false,\n                    failure: {\n                        message : bayeuxMessage,\n                        reason: 'Remote Call Timeout'\n                    }\n                });\n            }, timeout);\n            _cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');\n        }\n        _remoteCalls[bayeuxMessage.id] = context;\n\n        _queueSend(bayeuxMessage);\n    };\n\n    /**\n     * Returns a string representing the status of the bayeux communication with the Bayeux server.\n     */\n    this.getStatus = function() {\n        return _status;\n    };\n\n    /**\n     * Returns whether this instance has been disconnected.\n     */\n    this.isDisconnected = _isDisconnected;\n\n    /**\n     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * Default value is 1 second, which means if there is a persistent failure the retries will happen\n     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n     * @param period the backoff period to set\n     * @see #getBackoffIncrement()\n     */\n    this.setBackoffIncrement = function(period) {\n        _config.backoffIncrement = period;\n    };\n\n    /**\n     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * @see #setBackoffIncrement(period)\n     */\n    this.getBackoffIncrement = function() {\n        return _config.backoffIncrement;\n    };\n\n    /**\n     * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n     */\n    this.getBackoffPeriod = function() {\n        return _backoff;\n    };\n\n    /**\n     * Increases the backoff period up to the maximum value configured.\n     * @returns the backoff period after increment\n     * @see getBackoffIncrement\n     */\n    this.increaseBackoffPeriod = function() {\n        return _increaseBackoff();\n    };\n\n    /**\n     * Resets the backoff period to zero.\n     */\n    this.resetBackoffPeriod = function() {\n        _resetBackoff();\n    };\n\n    /**\n     * Sets the log level for console logging.\n     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n     * less verbose to more verbose.\n     * @param level the log level string\n     */\n    this.setLogLevel = function(level) {\n        _config.logLevel = level;\n    };\n\n    /**\n     * Registers an extension whose callbacks are called for every incoming message\n     * (that comes from the server to this client implementation) and for every\n     * outgoing message (that originates from this client implementation for the\n     * server).\n     * The format of the extension object is the following:\n     * <pre>\n     * {\n     *     incoming: function(message) { ... },\n     *     outgoing: function(message) { ... }\n     * }\n     * </pre>\n     * Both properties are optional, but if they are present they will be called\n     * respectively for each incoming message and for each outgoing message.\n     * @param name the name of the extension\n     * @param extension the extension to register\n     * @return true if the extension was registered, false otherwise\n     * @see #unregisterExtension(name)\n     */\n    this.registerExtension = function(name, extension) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var existing = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var existingExtension = _extensions[i];\n            if (existingExtension.name === name) {\n                existing = true;\n                break;\n            }\n        }\n        if (!existing) {\n            _extensions.push({\n                name: name,\n                extension: extension\n            });\n            this._debug('Registered extension', name);\n\n            // Callback for extensions\n            if (_isFunction(extension.registered)) {\n                extension.registered(name, this);\n            }\n\n            return true;\n        } else {\n            this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n            return false;\n        }\n    };\n\n    /**\n     * Unregister an extension previously registered with\n     * {@link #registerExtension(name, extension)}.\n     * @param name the name of the extension to unregister.\n     * @return true if the extension was unregistered, false otherwise\n     */\n    this.unregisterExtension = function(name) {\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var unregistered = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                _extensions.splice(i, 1);\n                unregistered = true;\n                this._debug('Unregistered extension', name);\n\n                // Callback for extensions\n                var ext = extension.extension;\n                if (_isFunction(ext.unregistered)) {\n                    ext.unregistered();\n                }\n\n                break;\n            }\n        }\n        return unregistered;\n    };\n\n    /**\n     * Find the extension registered with the given name.\n     * @param name the name of the extension to find\n     * @return the extension found or null if no extension with the given name has been registered\n     */\n    this.getExtension = function(name) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                return extension.extension;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns the name assigned to this CometD object, or the string 'default'\n     * if no name has been explicitly passed as parameter to the constructor.\n     */\n    this.getName = function() {\n        return _name;\n    };\n\n    /**\n     * Returns the clientId assigned by the Bayeux server during handshake.\n     */\n    this.getClientId = function() {\n        return _clientId;\n    };\n\n    /**\n     * Returns the URL of the Bayeux server.\n     */\n    this.getURL = function() {\n        if (_transport) {\n            var url = _transport.getURL();\n            if (url) {\n                return url;\n            }\n            url = _config.urls[_transport.getType()];\n            if (url) {\n                return url;\n            }\n        }\n        return _config.url;\n    };\n\n    this.getTransport = function() {\n        return _transport;\n    };\n\n    this.getConfiguration = function() {\n        return this._mixin(true, {}, _config);\n    };\n\n    this.getAdvice = function() {\n        return this._mixin(true, {}, _advice);\n    };\n};\n","var Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports.\n */\nmodule.exports = function Transport() {\n    var _type;\n    var _cometd;\n    var _url;\n\n    /**\n     * Function invoked just after a transport has been successfully registered.\n     * @param type the type of transport (for example 'long-polling')\n     * @param cometd the cometd object this transport has been registered to\n     * @see #unregistered()\n     */\n    this.registered = function(type, cometd) {\n        _type = type;\n        _cometd = cometd;\n    };\n\n    /**\n     * Function invoked just after a transport has been successfully unregistered.\n     * @see #registered(type, cometd)\n     */\n    this.unregistered = function() {\n        _type = null;\n        _cometd = null;\n    };\n\n    this._debug = function() {\n        _cometd._debug.apply(_cometd, arguments);\n    };\n\n    this._mixin = function() {\n        return _cometd._mixin.apply(_cometd, arguments);\n    };\n\n    this.getConfiguration = function() {\n        return _cometd.getConfiguration();\n    };\n\n    this.getAdvice = function() {\n        return _cometd.getAdvice();\n    };\n\n    this.setTimeout = function(funktion, delay) {\n        return Utils.setTimeout(_cometd, funktion, delay);\n    };\n\n    this.clearTimeout = function(handle) {\n        Utils.clearTimeout(handle);\n    };\n\n    /**\n     * Converts the given response into an array of bayeux messages\n     * @param response the response to convert\n     * @return an array of bayeux messages obtained by converting the response\n     */\n    this.convertToMessages = function(response) {\n        if (Utils.isString(response)) {\n            try {\n                return JSON.parse(response);\n            } catch (x) {\n                this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n                throw x;\n            }\n        }\n        if (Utils.isArray(response)) {\n            return response;\n        }\n        if (response === undefined || response === null) {\n            return [];\n        }\n        if (response instanceof Object) {\n            return [response];\n        }\n        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n    };\n\n    /**\n     * Returns whether this transport can work for the given version and cross domain communication case.\n     * @param version a string indicating the transport version\n     * @param crossDomain a boolean indicating whether the communication is cross domain\n     * @param url the URL to connect to\n     * @return true if this transport can work for the given version and cross domain communication case,\n     * false otherwise\n     */\n    this.accept = function(version, crossDomain, url) {\n        throw 'Abstract';\n    };\n\n    /**\n     * Returns the type of this transport.\n     * @see #registered(type, cometd)\n     */\n    this.getType = function() {\n        return _type;\n    };\n\n    this.getURL = function() {\n        return _url;\n    };\n\n    this.setURL = function(url) {\n        _url = url;\n    };\n\n    this.send = function(envelope, metaConnect) {\n        throw 'Abstract';\n    };\n\n    this.reset = function(init) {\n        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n    };\n\n    this.abort = function() {\n        this._debug('Transport', _type, 'aborted');\n    };\n\n    this.toString = function() {\n        return this.getType();\n    };\n};\n\nmodule.exports.derive = function(baseObject) {\n    function F() {\n    }\n\n    F.prototype = baseObject;\n    return new F();\n};\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports based on requests.\n * The key responsibility is to allow at most 2 outstanding requests to the server,\n * to avoid that requests are sent behind a long poll.\n * To achieve this, we have one reserved request for the long poll, and all other\n * requests are serialized one after the other.\n */\nmodule.exports = function RequestTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _requestIds = 0;\n    var _metaConnectRequest = null;\n    var _requests = [];\n    var _envelopes = [];\n\n    function _coalesceEnvelopes(envelope) {\n        while (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes[0];\n            var newEnvelope = envelopeAndRequest[0];\n            var newRequest = envelopeAndRequest[1];\n            if (newEnvelope.url === envelope.url &&\n                newEnvelope.sync === envelope.sync) {\n                _envelopes.shift();\n                envelope.messages = envelope.messages.concat(newEnvelope.messages);\n                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n                continue;\n            }\n            break;\n        }\n    }\n\n    function _transportSend(envelope, request) {\n        this.transportSend(envelope, request);\n        request.expired = false;\n\n        if (!envelope.sync) {\n            var maxDelay = this.getConfiguration().maxNetworkDelay;\n            var delay = maxDelay;\n            if (request.metaConnect === true) {\n                delay += this.getAdvice().timeout;\n            }\n\n            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n            var self = this;\n            request.timeout = self.setTimeout(function() {\n                request.expired = true;\n                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n                var failure = {\n                    reason: errorMessage\n                };\n                var xhr = request.xhr;\n                failure.httpCode = self.xhrStatus(xhr);\n                self.abortXHR(xhr);\n                self._debug(errorMessage);\n                self.complete(request, false, request.metaConnect);\n                envelope.onFailure(xhr, envelope.messages, failure);\n            }, delay);\n        }\n    }\n\n    function _queueSend(envelope) {\n        var requestId = ++_requestIds;\n        var request = {\n            id: requestId,\n            metaConnect: false,\n            envelope: envelope\n        };\n\n        // Consider the metaConnect requests which should always be present\n        if (_requests.length < this.getConfiguration().maxConnections - 1) {\n            _requests.push(request);\n            _transportSend.call(this, envelope, request);\n        } else {\n            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n            _envelopes.push([envelope, request]);\n        }\n    }\n\n    function _metaConnectComplete(request) {\n        var requestId = request.id;\n        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);\n        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n            throw 'Longpoll request mismatch, completing request ' + requestId;\n        }\n\n        // Reset metaConnect request\n        _metaConnectRequest = null;\n    }\n\n    function _complete(request, success) {\n        var index = Utils.inArray(request, _requests);\n        // The index can be negative if the request has been aborted\n        if (index >= 0) {\n            _requests.splice(index, 1);\n        }\n\n        if (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes.shift();\n            var nextEnvelope = envelopeAndRequest[0];\n            var nextRequest = envelopeAndRequest[1];\n            this._debug('Transport dequeued request', nextRequest.id);\n            if (success) {\n                if (this.getConfiguration().autoBatch) {\n                    _coalesceEnvelopes.call(this, nextEnvelope);\n                }\n                _queueSend.call(this, nextEnvelope);\n                this._debug('Transport completed request', request.id, nextEnvelope);\n            } else {\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                var self = this;\n                self.setTimeout(function() {\n                    self.complete(nextRequest, false, nextRequest.metaConnect);\n                    var failure = {\n                        reason: 'Previous request failed'\n                    };\n                    var xhr = nextRequest.xhr;\n                    failure.httpCode = self.xhrStatus(xhr);\n                    nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n                }, 0);\n            }\n        }\n    }\n\n    _self.complete = function(request, success, metaConnect) {\n        if (metaConnect) {\n            _metaConnectComplete.call(this, request);\n        } else {\n            _complete.call(this, request, success);\n        }\n    };\n\n    /**\n     * Performs the actual send depending on the transport type details.\n     * @param envelope the envelope to send\n     * @param request the request information\n     */\n    _self.transportSend = function(envelope, request) {\n        throw 'Abstract';\n    };\n\n    _self.transportSuccess = function(envelope, request, responses) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, true, request.metaConnect);\n            if (responses && responses.length > 0) {\n                envelope.onSuccess(responses);\n            } else {\n                envelope.onFailure(request.xhr, envelope.messages, {\n                    httpCode: 204\n                });\n            }\n        }\n    };\n\n    _self.transportFailure = function(envelope, request, failure) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, false, request.metaConnect);\n            envelope.onFailure(request.xhr, envelope.messages, failure);\n        }\n    };\n\n    function _metaConnectSend(envelope) {\n        if (_metaConnectRequest !== null) {\n            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n        }\n\n        var requestId = ++_requestIds;\n        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);\n        var request = {\n            id: requestId,\n            metaConnect: true,\n            envelope: envelope\n        };\n        _transportSend.call(this, envelope, request);\n        _metaConnectRequest = request;\n    }\n\n    _self.send = function(envelope, metaConnect) {\n        if (metaConnect) {\n            _metaConnectSend.call(this, envelope);\n        } else {\n            _queueSend.call(this, envelope);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        for (var i = 0; i < _requests.length; ++i) {\n            var request = _requests[i];\n            if (request) {\n                this._debug('Aborting request', request);\n                if (!this.abortXHR(request.xhr)) {\n                    this.transportFailure(request.envelope, request, {reason: 'abort'});\n                }\n            }\n        }\n        if (_metaConnectRequest) {\n            this._debug('Aborting metaConnect request', _metaConnectRequest);\n            if (!this.abortXHR(_metaConnectRequest.xhr)) {\n                this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});\n            }\n        }\n        this.reset(true);\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _metaConnectRequest = null;\n        _requests = [];\n        _envelopes = [];\n    };\n\n    _self.abortXHR = function(xhr) {\n        if (xhr) {\n            try {\n                var state = xhr.readyState;\n                xhr.abort();\n                return state !== XMLHttpRequest.UNSENT;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return false;\n    };\n\n    _self.xhrStatus = function(xhr) {\n        if (xhr) {\n            try {\n                return xhr.status;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return -1;\n    };\n\n    return _self;\n};\n","var Transport = require('./Transport');\nvar RequestTransport = require('./RequestTransport');\n\nmodule.exports = function LongPollingTransport() {\n    var _super = new RequestTransport();\n    var _self = Transport.derive(_super);\n    // By default, support cross domain\n    var _supportsCrossDomain = true;\n\n    _self.accept = function(version, crossDomain, url) {\n        return _supportsCrossDomain || !crossDomain;\n    };\n\n    _self.xhrSend = function(packet) {\n        throw 'Abstract';\n    };\n\n    _self.transportSend = function(envelope, request) {\n        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n        var self = this;\n        try {\n            var sameStack = true;\n            request.xhr = this.xhrSend({\n                transport: this,\n                url: envelope.url,\n                sync: envelope.sync,\n                headers: this.getConfiguration().requestHeaders,\n                body: JSON.stringify(envelope.messages),\n                onSuccess: function(response) {\n                    self._debug('Transport', self.getType(), 'received response', response);\n                    var success = false;\n                    try {\n                        var received = self.convertToMessages(response);\n                        if (received.length === 0) {\n                            _supportsCrossDomain = false;\n                            self.transportFailure(envelope, request, {\n                                httpCode: 204\n                            });\n                        } else {\n                            success = true;\n                            self.transportSuccess(envelope, request, received);\n                        }\n                    } catch (x) {\n                        self._debug(x);\n                        if (!success) {\n                            _supportsCrossDomain = false;\n                            var failure = {\n                                exception: x\n                            };\n                            failure.httpCode = self.xhrStatus(request.xhr);\n                            self.transportFailure(envelope, request, failure);\n                        }\n                    }\n                },\n                onError: function(reason, exception) {\n                    self._debug('Transport', self.getType(), 'received error', reason, exception);\n                    _supportsCrossDomain = false;\n                    var failure = {\n                        reason: reason,\n                        exception: exception\n                    };\n                    failure.httpCode = self.xhrStatus(request.xhr);\n                    if (sameStack) {\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        self.setTimeout(function() {\n                            self.transportFailure(envelope, request, failure);\n                        }, 0);\n                    } else {\n                        self.transportFailure(envelope, request, failure);\n                    }\n                }\n            });\n            sameStack = false;\n        } catch (x) {\n            _supportsCrossDomain = false;\n            // Keep the semantic of calling response callbacks asynchronously after the request\n            self.setTimeout(function() {\n                self.transportFailure(envelope, request, {\n                    exception: x\n                });\n            }, 0);\n        }\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _supportsCrossDomain = true;\n    };\n\n    return _self;\n};\n","var TRANSPORT_TYPES = require('../TransportTypes');\n\nvar FetchLongPollingTransport = require('../FetchLongPollingTransport');\nvar WebSocketTransport = require('../WebSocketTransport');\n\n// Use node-fetch implementation\nmodule.exports.fetch = FetchLongPollingTransport.fetch = function() {\n  return fetch.apply(window, arguments);\n};\n\n// Use node-websocket implementation\nmodule.exports.WebSocket = WebSocketTransport.WebSocket = typeof WebSocket === 'undefined' ? null : WebSocket;\n\n/**\n * Long polling transport layer\n */\nvar WEBSOCKET_TRANSPORT = {\n  type: TRANSPORT_TYPES.WEBSOCKET,\n  Transport: WebSocketTransport\n};\nmodule.exports.WEBSOCKET_TRANSPORT = WEBSOCKET_TRANSPORT;\n\n/**\n * Long polling transport layer\n */\nvar LONG_POLLING_TRANSPORT = {\n  type: TRANSPORT_TYPES.LONG_POLLING,\n  Transport: FetchLongPollingTransport\n};\nmodule.exports.LONG_POLLING_TRANSPORT = LONG_POLLING_TRANSPORT;\n\n/**\n * CometD Transports Layers map\n */\nvar ALL = [\n  WEBSOCKET_TRANSPORT,\n  LONG_POLLING_TRANSPORT\n];\nmodule.exports.ALL = ALL;\n","module.exports.CometD = require('./lib/CometD')\nmodule.exports.Transports = require('./lib/browser/Transports')\n","import { Service } from './core'\n/**\n * Data aggregation\n *\n * Provides data aggregation over time and across different items\n *  User devices push items data on developer-defined categories\n *  This service automatically aggregates the data\n * Raw data is not available for reading, only the generated aggregation result\n *\n * */\n/**\n * User API for item aggregation\n *\n * Users can push data and be notified of aggregated data.\n * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.\n * @access public\n * */\nexport class Aggreg extends Service {\n\t/**\n\t * Get default deployment id associated to Aggreg service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'aggreg_0'\n\t}\n\t/**\n\t * Pushes some data\n\t *\n\t * Pushes the given data.\n\t * All the items are processed according to the defined rules.\n\t * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.\n\t * */\n\tpush({items,owner}) { return this.$publish('push', {items,owner})}\n}\n/**\n * Data stacks\n *\n * Stacks are a per-user named persistent queue of data\n *  An administrator creates a stack service\n *  End-users can push data on an arbitrary number of their own arbitrary named stacks\n * */\n/**\n * Data stack user API\n *\n * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.\n * Stack names are arbitrary and do not need to be explicitly initialized.\n * @access public\n * */\nexport class Stack extends Service {\n\t/**\n\t * Get default deployment id associated to Stack service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'stack_0'\n\t}\n\t/**\n\t * Lists the listeners\n\t *\n\t * Returns the whole list of listeners for the given stack.\n\t * */\n\tgetListeners({stack,owner}) { return this.$publish('getListeners', {stack,owner})}\n\t/**\n\t * Lists content\n\t *\n\t * Returns a paginated list of contents for the given stack.\n\t * Content is sorted according to the statically configured order.\n\t * */\n\tlist({stack,owner,page}) { return this.$publish('list', {stack,owner,page})}\n\t/**\n\t * Empties a stack\n\t *\n\t * Removes all items from the given stack.\n\t * */\n\tpurge({stack,owner}) { return this.$publish('purge', {stack,owner})}\n\t/**\n\t * Pushes an item\n\t *\n\t * Pushes an item onto the given stack.\n\t * The stack does not need to be created.\n\t * */\n\tpush({stack,data,owner}) { return this.$publish('push', {stack,data,owner})}\n\t/**\n\t * Removes items\n\t *\n\t * Removes the item with the given guid from the given stack.\n\t * */\n\tremove({guids,stack,owner}) { return this.$publish('remove', {guids,stack,owner})}\n\t/**\n\t * Sets the listeners\n\t *\n\t * Sets the listeners for the given stack.\n\t * */\n\tsetListeners({listeners,stack,owner}) { return this.$publish('setListeners', {listeners,stack,owner})}\n\t/**\n\t * Updates an item\n\t *\n\t * Updates an existing item of the given stack.\n\t * The item MUST exist prior to the call.\n\t * */\n\tupdate({guid,stack,data,owner}) { return this.$publish('update', {guid,stack,data,owner})}\n}\n/**\n * Echo\n *\n * Echo\n * */\n/**\n * Echo service\n *\n * Simple echo service, for development purposes.\n * @access public\n * */\nexport class Echo extends Service {\n\t/**\n\t * Get default deployment id associated to Echo service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'echo_0'\n\t}\n\t/**\n\t * Echoes an object\n\t *\n\t * Echoes an object: the server will echo that object on channel 'echo' for the current user.\n\t * */\n\techo(parameter) { return this.$publish('echo', parameter)}\n}\n/**\n * Game engine\n *\n * Abstract Game Engine\n *  Concrete game engines are remote cometd clients or internal macros\n * */\n/**\n * User API for games\n *\n * Users can list, start, join games, and play.\n * @access public\n * */\nexport class Game extends Service {\n\t/**\n\t * Get default deployment id associated to Game service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Lists game types\n\t *\n\t * Returns the list of game types supported by the server and the currently registered game engines.\n\t * */\n\tavailable() { return this.$publish('available', {})}\n\t/**A user joins a game*/\n\tjoin({role,gameId,userId,userName}) { return this.$publish('join', {role,gameId,userId,userName})}\n\t/**Organizes a game*/\n\torganize({type,owner,options}) { return this.$publish('organize', {type,owner,options})}\n\t/**Gives some command to the game engine*/\n\tplay({gameId,userId,data}) { return this.$publish('play', {gameId,userId,data})}\n\t/**Starts a game*/\n\tstart({gameId}) { return this.$publish('start', {gameId})}\n\t/**A user cancels joining a game*/\n\tunjoin({role,gameId,userId,userName}) { return this.$publish('unjoin', {role,gameId,userId,userName})}\n}\n/**\n * Game Engine API\n *\n * The Game Engine API is for game engine clients, not end-users.\n * @access public\n * */\nexport class GameEngine extends Service {\n\t/**\n\t * Get default deployment id associated to GameEngine service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Notify the result for a join request\n\t *\n\t * A Game Engine notifies the STR of the result of a join request that it received on join_callback\n\t * */\n\tjoin_result({msgId,payload,error,callerId}) { return this.$publish('join_result', {msgId,payload,error,callerId})}\n\t/**\n\t * Notify the result for an organization request\n\t *\n\t * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback\n\t * */\n\torganize_result({msgId,payload,error,callerId}) { return this.$publish('organize_result', {msgId,payload,error,callerId})}\n\t/**\n\t * Registers a game engine\n\t *\n\t * A client registers itself to the STR as a Game Engine.\n\t * The STR may, from now on, dispatch game of the given game type to said client.\n\t * Unregistration is done automatically on logoff.\n\t * */\n\tregister({maxGames,gameInfo,location}) { return this.$publish('register', {maxGames,gameInfo,location})}\n\t/**\n\t * Notify the result for a start request\n\t *\n\t * A Game Engine notifies the STR of the result of a start request that it received on start_callback\n\t * */\n\tstart_result({gameId}) { return this.$publish('start_result', {gameId})}\n\t/**\n\t * Notify a game event\n\t *\n\t * A Game Engine notifies the STR of some arbitrary game event.\n\t * */\n\tstate({status,gameId,data}) { return this.$publish('state', {status,gameId,data})}\n\t/**\n\t * Notify the result for an unjoin request\n\t *\n\t * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback\n\t * */\n\tunjoin_result({msgId,payload,error,callerId}) { return this.$publish('unjoin_result', {msgId,payload,error,callerId})}\n}\n/**\n * Generic Data Access\n *\n * Generic Data Access Service : NoSQL storage\n * */\n/**\n * GDA User API\n *\n * User API for Generic Data Access.\n * The data are stored on a per-user basis.\n * Users can put, get, list their data.\n * @access public\n * */\nexport class Gda extends Service {\n\t/**\n\t * Get default deployment id associated to Gda service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'gda_0'\n\t}\n\t/**\n\t * Asks for a data row\n\t *\n\t * Returns a full data row.\n\t * */\n\tget({table,key,owner}) { return this.$publish('get', {table,key,owner})}\n\t/**\n\t * Asks for a data cell\n\t *\n\t * Returns a precise list of cells from a column in a data row.\n\t * */\n\tgetCells({table,key,key2,owner,column}) { return this.$publish('getCells', {table,key,key2,owner,column})}\n\t/**\n\t * Increments an integer value\n\t *\n\t * Increments a cell 64-bit signed integer value and returns the result in the data field.\n\t * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.\n\t * */\n\tinc({table,data,key,key2,owner,column}) { return this.$publish('inc', {table,data,key,key2,owner,column})}\n\t/**\n\t * Asks for a list of rows\n\t *\n\t * Returns a paginated list of rows from the given table.\n\t * */\n\tlist({columns,table,owner,page}) { return this.$publish('list', {columns,table,owner,page})}\n\t/**\n\t * Puts some data into a cell\n\t *\n\t * Creates or replaces the contents of a particular cell.\n\t * */\n\tput({table,data,key,key2,owner,column}) { return this.$publish('put', {table,data,key,key2,owner,column})}\n\t/**\n\t * Puts several rows\n\t *\n\t * Creates or replaces the (maybe partial) contents of a collection of rows.\n\t * This method only creates or replaces cells for non-null input values.\n\t * */\n\tputs({rows,table,owner}) { return this.$publish('puts', {rows,table,owner})}\n\t/**\n\t * Asks for a range of rows\n\t *\n\t * Returns a paginated range of rows from the given table.\n\t * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n\t * You can specify partial keys for the start and stop fields.\n\t * */\n\trange({columns,start,table,stop,owner,page}) { return this.$publish('range', {columns,start,table,stop,owner,page})}\n\t/**\n\t * Removes one cell inside a column of a row\n\t *\n\t * Removes only one cell of the given column of the given row from the given table.\n\t * */\n\tremoveCell({table,key,key2,owner,column}) { return this.$publish('removeCell', {table,key,key2,owner,column})}\n\t/**\n\t * Removes one full column of a row\n\t *\n\t * Removes all cells of the given column of the given row from the given table.\n\t * */\n\tremoveColumn({table,key,owner,column}) { return this.$publish('removeColumn', {table,key,owner,column})}\n\t/**\n\t * Removes a range of rows\n\t *\n\t * Removes the specified columns of the given range of rows from the given table.\n\t * */\n\tremoveRange({columns,start,table,stop,owner}) { return this.$publish('removeRange', {columns,start,table,stop,owner})}\n\t/**\n\t * Removes one full row\n\t *\n\t * Removes all columns of the given row from the given table.\n\t * */\n\tremoveRow({table,key,owner}) { return this.$publish('removeRow', {table,key,owner})}\n}\n/**\n * Groups Management\n *\n * Groups management for users, grants on resources, remote commands on devices\n *  This is where you can configure rights for any resource\n *\n * */\n/**\n * User API for remote control\n *\n * @access public\n * */\nexport class Remoting extends Service {\n\t/**\n\t * Get default deployment id associated to Remoting service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds a listener\n\t *\n\t * A user requests notifications from a device owned by anyone who granted him the right authorizations.\n\t * Whenever the device calls 'notify', notifications will be sent to the caller of this verb.\n\t * */\n\taddListener({resource,fromResource,cmd,from,data,owner}) { return this.$publish('addListener', {resource,fromResource,cmd,from,data,owner})}\n\t/**Response to 'getCapabilities'*/\n\tcapabilities({askingResource,capabilities,answeringResource}) { return this.$publish('capabilities', {askingResource,capabilities,answeringResource})}\n\t/**\n\t * Executes a command\n\t *\n\t * A user executes a command on a device owned by anyone who granted him the right authorizations.\n\t * The command is issued on channel 'command'\n\t * */\n\texecute({resource,cmd,data,owner}) { return this.$publish('execute', {resource,cmd,data,owner})}\n\t/**\n\t * Requests capabilities\n\t *\n\t * A user requests all his devices for the whole list of their capabilities.\n\t * Devices are expected to answer on channel 'capabilities'\n\t * */\n\tgetCapabilities() { return this.$publish('getCapabilities', {})}\n\t/**\n\t * Notifies of some event\n\t *\n\t * A device notifies the registered users/devices on this channel.\n\t * The server forwards the notification to said users.\n\t * */\n\tnotify({resource,fromResource,cmd,from,data,owner}) { return this.$publish('notify', {resource,fromResource,cmd,from,data,owner})}\n\t/**\n\t * Pings devices\n\t *\n\t * A user requests all devices (of all owners) on which he has authorizations to respond on channel 'pong'\n\t * */\n\tping({action}) { return this.$publish('ping', {action})}\n\t/**Response to ping*/\n\tpong({user,resource,available,uid,owner,action}) { return this.$publish('pong', {user,resource,available,uid,owner,action})}\n\t/**\n\t * Removes a listener\n\t *\n\t * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations\n\t * */\n\tremoveListener({resource,fromResource,cmd,from,data,owner}) { return this.$publish('removeListener', {resource,fromResource,cmd,from,data,owner})}\n}\n/**\n * User API for groups and rights.\n *\n * Groups are stored per user.\n * This means that two users can own a group with the same identifier. A couple (owner, group) is needed to uniquely identify a group inside a group management service.\n * The triplet (deploymentId, owner, group) is actually needed to fully qualify a group outside of the scope of this service.\n * @access public\n * */\nexport class GroupManagement extends Service {\n\t/**\n\t * Get default deployment id associated to GroupManagement service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds me to a group\n\t *\n\t * Adds me (the caller) to a group.\n\t * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\taddMe({group,owner}) { return this.$publish('addMe', {group,owner})}\n\t/**\n\t * Adds a user to a group\n\t *\n\t * Adds the given user to the given group.\n\t * Addition may fail if the given group does not already exist.\n\t * */\n\taddUser({user,group,owner}) { return this.$publish('addUser', {user,group,owner})}\n\t/**Adds users to a group*/\n\taddUsers({users,group,owner}) { return this.$publish('addUsers', {users,group,owner})}\n\t/**\n\t * Lists my owned groups, with details\n\t *\n\t * Returns the whole list of groups owned by the current user, with their members\n\t * */\n\tallGroups({owner}) { return this.$publish('allGroups', {owner})}\n\t/**\n\t * Creates a group\n\t *\n\t * Creates a group owned by the current user.\n\t * Group creation may fail if the group already exists.\n\t * */\n\tcreateGroup({group,groupName,owner}) { return this.$publish('createGroup', {group,groupName,owner})}\n\t/**\n\t * Removes a group\n\t *\n\t * Removes the given group owned by the current user or the given owner.\n\t * Also removes all grants to that group.\n\t * */\n\tdelGroup({group,owner}) { return this.$publish('delGroup', {group,owner})}\n\t/**Removes a user from a group*/\n\tdelUser({user,group,owner}) { return this.$publish('delUser', {user,group,owner})}\n\t/**Removes users from a group*/\n\tdelUsers({users,group,groupName,owner}) { return this.$publish('delUsers', {users,group,groupName,owner})}\n\t/**\n\t * Tests for a group's existence\n\t *\n\t * Returns whether a group exists or not.\n\t * */\n\texists({group,owner}) { return this.$publish('exists', {group,owner})}\n\t/**\n\t * Grants a right to a group\n\t *\n\t * The granting API does not do any check when storing permissions.\n\t * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.\n\t * */\n\tgrant({resource,group,owner,action}) { return this.$publish('grant', {resource,group,owner,action})}\n\t/**\n\t * Lists the group users\n\t *\n\t * Returns the whole list of users configured inside the given group.\n\t * */\n\tgroupUsers({group,owner}) { return this.$publish('groupUsers', {group,owner})}\n\t/**\n\t * Lists my owned groups\n\t *\n\t * Returns the whole list of groups owned by the current user\n\t * */\n\tgroups({owner}) { return this.$publish('groups', {owner})}\n\t/**\n\t * Lists rights for a group\n\t *\n\t * This API lists explicitly configured rights.\n\t * Effective rights include configured rights, implicit rights and inherited rights.\n\t * */\n\tlistGrants({group,owner}) { return this.$publish('listGrants', {group,owner})}\n\t/**\n\t * Lists presences for a group\n\t *\n\t * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.\n\t * The current implementation does not include information about the particular devices users are connected with.\n\t * If a user is connected twice with two different devices, two identical entries will be returned.\n\t * */\n\tlistPresences({group,owner}) { return this.$publish('listPresences', {group,owner})}\n\t/**\n\t * Tests membership\n\t *\n\t * Tests whether I (the caller) am a member of the given group.\n\t * This verb exists so that users can determine if they are part of a group without being granted particular rights.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\tmemberOf({hardFail,group,owner}) { return this.$publish('memberOf', {hardFail,group,owner})}\n\t/**\n\t * Grants rights to a group\n\t *\n\t * Grant several rights at once.\n\t * */\n\tmgrant({resource,actions,group,owner}) { return this.$publish('mgrant', {resource,actions,group,owner})}\n\t/**Revokes rights for a group*/\n\tmrevoke({resource,actions,group,owner}) { return this.$publish('mrevoke', {resource,actions,group,owner})}\n\t/**\n\t * Lists the groups I am part of\n\t *\n\t * Returns the whole list of groups the current user is part of.\n\t * Groups may be owned by anyone, including the current user.\n\t * */\n\tmyGroups({owner}) { return this.$publish('myGroups', {owner})}\n\t/**Revokes a right for a group*/\n\trevoke({resource,group,owner,action}) { return this.$publish('revoke', {resource,group,owner,action})}\n}\n/**\n * HTTP client\n *\n * Web-service client\n *  An admin records URL templates that can be called by users\n *  Calls are not configurable by end-users\n *  However an admin may leverage the macro service to achieve URL, headers and body configurability\n * */\n/**\n * User API for http requests\n *\n * @access public\n * */\nexport class Httpclient extends Service {\n\t/**\n\t * Get default deployment id associated to Httpclient service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'httpclient_0'\n\t}\n\t/**\n\t * Makes a predefined request\n\t *\n\t * Lookups a predefined request by name, and executes it.\n\t * */\n\tcall({name,requestId}) { return this.$publish('call', {name,requestId})}\n}\n/**\n * Macros\n *\n * Macro-command service\n *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc\n *\n *\n *  End-users play them, with contextual parameters\n * */\n/**\n * User API for macro debugging\n *\n * Debugger API for macro.\n * These API verbs are not intended for use by most developers.\n * @access public\n * */\nexport class MacroDebug extends Service {\n\t/**\n\t * Get default deployment id associated to MacroDebug service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'macro_0'\n\t}\n\t/**Enables or disables a breakpoint*/\n\tbreakpoint({breakpoint,token,enabled}) { return this.$publish('breakpoint', {breakpoint,token,enabled})}\n\t/**Requests some information*/\n\tinfo({token,path,exp,requestId,frame}) { return this.$publish('info', {token,path,exp,requestId,frame})}\n\t/**\n\t * Debugs a previously recorded macro\n\t *\n\t * The given breakpoints will be honored, causing a suspension of the execution, resumable via 'resume'.\n\t * Only one debug session can be active at any given time.\n\t * */\n\tlivedebug({parameters,token,breakpoints,hardFail,name,requestId,debug}) { return this.$publish('livedebug', {parameters,token,breakpoints,hardFail,name,requestId,debug})}\n\t/**Resumes a paused macro*/\n\tresume({token,type}) { return this.$publish('resume', {token,type})}\n\t/**Sets a variable value*/\n\tvariable({token,name,frame,data}) { return this.$publish('variable', {token,name,frame,data})}\n}\n/**\n * User API for macro execution\n *\n * Simple errors are reported as usual.\n * However, the macro execution verbs treat most errors in a particular way : instead of reporting errors on the usual 'error' channel, errors are put in the returned 'MacroCompletion' result.\n * This behavior can be tuned on a per-call basis with the hardFail parameter.\n * Note that some particular errors will always behave as if hardFail were true, because they are related to programming errors, or prevent processing from ending gracefully : STACK_OVERFLOW, NO_SUCH_FUNCTION, RAM_EXCEEDED, CYCLES_EXCEEDED, TIME_EXCEEDED, QUOTA_EXCEEDED, RATE_EXCEEDED, BAD_COMPARATOR_VALUE\n * @access public\n * */\nexport class Macro extends Service {\n\t/**\n\t * Get default deployment id associated to Macro service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'macro_0'\n\t}\n\t/**\n\t * Plays a previously recorded macro\n\t *\n\t * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.\n\t * You can override the default notification channel when defining the macro.\n\t * */\n\tcall({parameters,hardFail,name,requestId,debug}) { return this.$publish('call', {parameters,hardFail,name,requestId,debug})}\n}\n/**\n * Mail sender\n *\n * Sends email through SMTP\n * */\n/**\n * Mail service user API\n *\n * This service is statically configured with an outgoing SMTP server.\n * Users call the API here to actually send emails.\n * @access public\n * */\nexport class Sendmail extends Service {\n\t/**\n\t * Get default deployment id associated to Sendmail service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sendmail_0'\n\t}\n}\n/**\n * Messaging service\n *\n * Messaging service\n * */\n/**\n * Messaging service\n *\n * Simple and flexible user-to-user or user-to-group messaging service.\n * @access public\n * */\nexport class Messaging extends Service {\n\t/**\n\t * Get default deployment id associated to Messaging service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'messaging_0'\n\t}\n\t/**\n\t * Sends a message to a target\n\t *\n\t * Sends the given message to the specified target on the given (optional) channel.\n\t * The administratively given default channel name is used when none is provided in the message itself.\n\t * */\n\tsend({target,channel,data}) { return this.$publish('send', {target,channel,data})}\n}\n/**\n * Producer consumer\n *\n * Producer consumer service\n *  Users can submit tasks and other users consume them\n * */\n/**\n * Producer / consumer real-time API\n *\n * Task producers submits their tasks.\n * The server dispatches the tasks.\n * Consumers process them and report completion back to the server.\n * Tasks are global to the service (i.e. NOT per user).\n * @access public\n * */\nexport class Queue extends Service {\n\t/**\n\t * Get default deployment id associated to Queue service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'queue_0'\n\t}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be returned to the caller.\n\t * When called from inside a macro, the comsumer generated result is available for further use.\n\t * */\n\tcall({description,originBusinessId,originDeploymentId,data,owner}) { return this.$publish('call', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Notifies completion of a task\n\t *\n\t * Consumer API.\n\t * The tasker notifies completion of the given task to the server.\n\t * The tasker can optionally include a result or an error code.\n\t * */\n\tdone({result,taskId,success}) { return this.$publish('done', {result,taskId,success})}\n\t/**\n\t * Registers a consumer\n\t *\n\t * Consumer API.\n\t * Registers the current user resource as an available task consumer.\n\t * Tasks will be then dispatched to that consumer.\n\t * */\n\tregister({capacity}) { return this.$publish('register', {capacity})}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).\n\t * This verb will return immediately : you can use this API to asynchronously submit a task.\n\t * */\n\tsubmit({description,originBusinessId,originDeploymentId,data,owner}) { return this.$publish('submit', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Unregisters a consumer\n\t *\n\t * Consumer API.\n\t * Unregisters the current user resource as an available task consumer.\n\t * All non finished tasks are returned to the server.\n\t * */\n\tunregister() { return this.$publish('unregister', {})}\n}\n/**\n * Push Notifications\n *\n * Native Push Notifications for Android, iOS\n *\n *\n *\n * */\n/**\n * Notification User API\n *\n * User API for notifications.\n * For notifications to work properly, it is imperative that the resource name of a device remain constant over time.\n * @access public\n * */\nexport class Notif extends Service {\n\t/**\n\t * Get default deployment id associated to Notif service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'notif_0'\n\t}\n}\n/**\n * RDBMS\n *\n * Relational Database : SQL storage\n * */\n/**\n * RDBMS User API\n *\n * User API for SQL queries.\n * Contrary to GDA or Stacks, the data are not stored on a per-user basis.\n * Users can store, get, list their data.\n * @access public\n * */\nexport class Rdbms extends Service {\n\t/**\n\t * Get default deployment id associated to Rdbms service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'rdbms_0'\n\t}\n}\n/**\n * SMS via OVH\n *\n * SMS sender, to send text messages to mobile phones\n * This SMS sending service uses the OVH API\n *\n * */\n/**\n * SMS service\n *\n * User API for SMS.\n * @access public\n * */\nexport class Sms_ovh extends Service {\n\t/**\n\t * Get default deployment id associated to Sms_ovh service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sms_ovh_0'\n\t}\n}\n/**\n * Scheduler\n *\n * Scheduler service\n *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)\n * */\n/**\n * User API for the Scheduler\n *\n * User endpoints for scheduling : users can schedule, list and delete tasks.\n * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.\n * Tasks are run on the server and thus can call api verbs marked as server-only.\n * @access public\n * */\nexport class Cron extends Service {\n\t/**\n\t * Get default deployment id associated to Cron service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'cron_0'\n\t}\n\t/**\n\t * List the configured tasks\n\t *\n\t * Returns a paginated list of the asking user's tasks.\n\t * */\n\tlist({start,stop,owner,page}) { return this.$publish('list', {start,stop,owner,page})}\n}\n/**\n * Search engine\n *\n * ElasticSearch engine, to index and search data\n *  An admin creates indices\n *  Users index and search documents\n *\n * */\n/**\n * ElasticSearch Service\n *\n * This API is a very thin wrapper around ElasticSearch's API.\n * @access public\n * */\nexport class Search extends Service {\n\t/**\n\t * Get default deployment id associated to Search service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'search_0'\n\t}\n\t/**\n\t * Deletes data\n\t *\n\t * Deletes a document from the elasticsearch engine by id.\n\t * */\n\tdelete({type,id,index}) { return this.$publish('delete', {type,id,index})}\n\t/**\n\t * Gets data\n\t *\n\t * Retrieves a document from the elasticsearch engine by id.\n\t * */\n\tget({type,id,index}) { return this.$publish('get', {type,id,index})}\n\t/**\n\t * Indexes data\n\t *\n\t * Inserts or updates a document into the elasticsearch engine.\n\t * */\n\tindex({type,id,index,data}) { return this.$publish('index', {type,id,index,data})}\n\t/**Searches for data*/\n\tsearch({indices,query,sort,page,types}) { return this.$publish('search', {indices,query,sort,page,types})}\n}\n/**\n * Template engine\n *\n * Template engine to produce documents from parameterized templates\n * <br>An admin creates templates\n * <br> Users produce documents\n * <br>The implementation uses the <a href='http://freemarker\n * org/'>freemarker</a> engine\n *\n * */\n/**\n * User API for templates\n *\n * Users use this API to evaluate pre-configured templates.\n * @access public\n * */\nexport class Template extends Service {\n\t/**\n\t * Get default deployment id associated to Template service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'template_0'\n\t}\n\t/**\n\t * Evaluates a template\n\t *\n\t * Evaluates the given template and returns the result as a string.\n\t * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.\n\t * */\n\tevaluate({languageTag,name,requestId,data}) { return this.$publish('evaluate', {languageTag,name,requestId,data})}\n}\n/**\n * Triggers\n *\n * Register callbacks for events and trigger them when needed\n *\n * */\n/**\n * Trigger service\n *\n * Register listeners and trigger events.\n * @access public\n * */\nexport class Trigger extends Service {\n\t/**\n\t * Get default deployment id associated to Trigger service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'trigger_0'\n\t}\n}\n/**\n * Upload: S3\n *\n * Upload service with S3 storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3 extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3 service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * Upload: local\n *\n * Upload service with local HDFS storage\n * */\n/**\n * User API for local file management\n *\n * User API for file content manipulation\n * @access public\n * */\nexport class Zpfs_hdfs extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_hdfs service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_hdfs_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * Upload: pseudo-S3\n *\n * Upload service with pseudo-S3compatible storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3compat extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3compat service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3compat_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * User directory service\n *\n * User directory service\n * */\n/**\n * User API for user information\n *\n * @access public\n * */\nexport class Userdir extends Service {\n\t/**\n\t * Get default deployment id associated to Userdir service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'userdir_0'\n\t}\n\t/**Searches for users matching the request*/\n\tsearch({requestId,query,page}) { return this.$publish('search', {requestId,query,page})}\n\t/**Requests public data for the specified users*/\n\tuserInfo({userKeys}) { return this.$publish('userInfo', {userKeys})}\n}\n","/**\n * Match unsecure pattern web\n * @type {RegExp}\n */\nconst HTTP_PATTERN = /^http:\\/\\/|^\\/\\//\n\n/**\n * Http protocol\n * @type {string}\n */\nconst HTTP_PROTOCOL = 'http:'\n\n/**\n * Https protocol\n * @type {string}\n */\nconst HTTPS_PROTOCOL = 'https:'\n\n/**\n * Alpha numeric dictionary\n */\nconst DICTIONARY = 'abcdefghijklmnopqrstuvwxyz0123456789'\n\n/**\n * Default ZetaPush API URL\n * @access private\n */\nexport const API_URL = 'https://api.zpush.io/'\n\n/**\n * Force ssl based protocol for network echange\n * Cross Env (Browser/Node) test\n * @access private\n * @type boolean\n */\nexport const FORCE_HTTPS = typeof location === 'undefined' ? false : location.protocol === HTTPS_PROTOCOL\n\n/**\n * @access private\n * @param {string} apiUrl\n * @return {string}\n */\nconst normalizeApiUrl = (apiUrl) => {\n  const last = apiUrl.charAt(apiUrl.length - 1)\n  const SLASH = '/'\n  return last === SLASH ? apiUrl : apiUrl + SLASH\n}\n\n/**\n * @access private\n * @param {Array<Object>} list\n * @return {Object}\n */\nexport const shuffle = (list) => {\n  const index = Math.floor(Math.random() * list.length)\n  return list[index]\n}\n\n/**\n * @access private\n * @param {string} url\n * @param {boolean} forceHttps\n * @return {string}\n */\nexport const getSecureUrl = (url, forceHttps) => {\n  return forceHttps ? url.replace(HTTP_PATTERN, `${HTTPS_PROTOCOL}//`) : url\n}\n\n/**\n * @access private\n * @param {{apiUrl: string, sandboxId: string, forceHttps: boolean, transports: Transports}} parameters\n * @return {Promise}\n */\nexport const getServers = ({ apiUrl, sandboxId, forceHttps, transports }) => {\n  const normalizedSecuresApiUrl = normalizeApiUrl(getSecureUrl(apiUrl, forceHttps))\n  const url = `${normalizedSecuresApiUrl}${sandboxId}`\n  const options = { protocol: forceHttps ? HTTPS_PROTOCOL : HTTP_PROTOCOL }\n  return transports.fetch(url, options)\n    .then((response) => response.json())\n    // TODO: Replace by a server side implementation when available\n    .then(({ servers }) => servers.map((server) => getSecureUrl(server, forceHttps)))\n}\n\n/**\n * @access private\n * @param Class Derived\n * @param Class Parent\n * @return {boolean}\n */\nexport const isDerivedOf = (Derived, Parent) => {\n  let prototype = Object.getPrototypeOf(Derived)\n  let is = false\n  while (!(is || prototype === null)) {\n    is = prototype === Parent\n    prototype = Object.getPrototypeOf(prototype)\n  }\n  return is\n}\n\n/**\n * Get random id\n * @return {string}\n */\nexport const uuid = (entropy = 7, dictionary = DICTIONARY) => Array.from(Array(entropy)).reduce((previous) => {\n  const next = dictionary.charAt(Math.floor(Math.random() * dictionary.length))\n  return `${previous}${next}`\n}, '')\n","import { CometD, Transports } from 'zetapush-cometd'\nimport { ConnectionStatusListener } from '../connection/connection-status'\nimport { Macro } from '../mapping/services'\nimport { getServers, isDerivedOf, shuffle, uuid } from '../utils/index'\n\n/**\n * CometD Messages enumeration\n * @type {Object}\n */\nconst Message = {\n  RECONNECT_HANDSHAKE_VALUE: 'handshake',\n  RECONNECT_NONE_VALUE: 'none',\n  RECONNECT_RETRY_VALUE: 'retry'\n}\n\n/**\n * Delay to update server url\n * @type {integer}\n */\nconst UPDATE_SERVER_URL_DELAY = 250\n\n/**\n * Default macro channel\n * @type {string}\n */\nconst DEFAULT_MACRO_CHANNEL = 'completed'\n\n/**\n * Provide utilities and abstraction on CometD Transport layer\n * @access private\n */\nexport class ClientHelper {\n  /**\n   * Create a new ZetaPush client helper\n   */\n  constructor({ apiUrl, sandboxId, forceHttps = false, authentication, resource = null, transports = Transports }) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access private\n     * @type {function():AbstractHandshake}\n     */\n    this.authentication = authentication\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.resource = resource\n    /**\n     * @access private\n     * @type {number}\n     */\n    this.requestId = 0\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.userId = null\n    /**\n     * @access private\n     * @type {Object}\n     */\n    this.userInfo = null\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.uniqId = uuid()\n    /**\n     * @access private\n     * @type {Promise}\n     */\n    this.servers = getServers({ apiUrl, sandboxId, forceHttps, transports }).catch((error) => {\n      // Notify error in connection to server step\n      this.connectionToServerFail(error)\n      // Return empty list\n      return []\n    })\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.connectionListeners = []\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.connected = false\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.wasConnected = false\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.serverUrl = null\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sessionId = null\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.subscribeQueue = []\n    /**\n     * @access private\n     * @type {CometD}\n     */\n    this.cometd = new CometD()\n\n    // Register transports layers\n    transports.ALL.forEach(({ type, Transport }) => {\n      this.cometd.registerTransport(type, new Transport())\n    })\n\n    // Handle transport exception\n    this.cometd.onTransportException = (cometd, transport) => {\n      // Try to find an other available server\n      // Remove the current one from the _serverList array\n      this.updateServerUrl()\n    }\n\n    this.cometd.addListener('/meta/handshake', ({ ext, successful, advice, error }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      if (successful) {\n        const { authentication = null } = ext\n        this.initialized(authentication)\n      } else {\n        this.handshakeFailure(error)\n      }\n    })\n\n    this.cometd.addListener('/meta/handshake', ({ advice, error, ext, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      // AuthNegotiation\n      if (!successful) {\n        if (typeof advice === 'undefined') {\n          return\n        }\n        if (Message.RECONNECT_NONE_VALUE === advice.reconnect) {\n          this.authenticationFailed(error)\n        } else if (Message.RECONNECT_HANDSHAKE_VALUE === advice.reconnect) {\n          this.negotiationFailed(error)\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/connect', ({ advice, channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/connect', { advice, channel, successful })\n      // ConnectionListener\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection will close\n        this.connectionWillClose()\n      } else {\n        this.wasConnected = this.connected\n        this.connected = successful\n        if (!this.wasConnected && this.connected) {\n          this.cometd.batch(this, () => {\n            // Unqueue subscriptions\n            this.subscribeQueue.forEach(({ prefix, listener, subscriptions }) => {\n              this.subscribe(prefix, listener, subscriptions)\n            })\n          })\n          // Notify connection is established\n          this.connectionEstablished()\n        } else if (this.wasConnected && !this.connected) {\n          // Notify connection is broken\n          this.connectionBroken()\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/disconnect', ({ channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/disconnect', { channel, successful })\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection is closed\n        this.connectionClosed()\n      }\n    })\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    this.connectionListeners.push({\n      enabled: true,\n      listener: Object.assign(new ConnectionStatusListener(), listener)\n    })\n    return this.connectionListeners.length - 1\n  }\n  /**\n   * Notify listeners when handshake step succeed\n   */\n  authenticationFailed(error) {\n    this.userId = null\n    this.userInfo = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onFailedHandshake(error)\n      })\n  }\n  /**\n   * Connect client using CometD Transport\n   */\n  connect() {\n    this.servers.then((servers) => {\n      if (servers.length > 0) {\n        // Get a random server url\n        this.serverUrl = shuffle(servers)\n        // Configure CometD\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`,\n          backoffIncrement: 1000,\n          maxBackoff: 60000,\n          appendMessageTypeToURL: false\n        })\n        // Send handshake fields\n        this.cometd.handshake(this.getHandshakeFields())\n      } else {\n        // No servers available\n        this.noServerUrlAvailable()\n      }\n    })\n  }\n  /**\n   * Notify listeners when connection is broken\n   */\n  connectionBroken() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionBroken()\n      })\n  }\n  /**\n   * Notify listeners when connection is closed\n   */\n  connectionClosed() {\n    this.userId = null\n    this.userInfo = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionClosed()\n      })\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  connectionEstablished() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionEstablished()\n      })\n  }\n  /**\n   * Notify listeners when connection to server fail\n   */\n  connectionToServerFail(failure) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionToServerFail(failure)\n      })\n  }\n  /**\n   * Notify listeners when connection will close\n   */\n  connectionWillClose() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionWillClose()\n      })\n  }\n  /**\n   * Create a promise based macro service\n   * @experimental\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createAsyncMacroService({ listener, Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`\n    const $publish = this.getAsyncMacroPublisher(prefix)\n    // Create service by publisher\n    return this.createServiceByPublisher({ listener, prefix, Type, $publish })\n  }\n  /**\n   * Create a publish/subscribe service\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createService({ listener, Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const isMacroType = isDerivedOf(Type, Macro)\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`\n    const $publish = isMacroType ? this.getMacroPublisher(prefix) : this.getServicePublisher(prefix)\n    // Create service by publisher\n    return this.createServiceByPublisher({ listener, prefix, Type, $publish })\n  }\n  /**\n   * @param {{listener: Object, prefix: string, Type: class, $publish: Function}} parameters\n   * @return {Object} service\n   */\n  createServiceByPublisher({ listener, prefix, Type, $publish }) {\n    const service = new Type({ $publish })\n    // Store subscription in service instance\n    service.$subscriptions = this.subscribe(prefix, listener)\n    return service\n  }\n  /**\n   * Disconnect CometD client\n   */\n  disconnect() {\n    this.cometd.disconnect(true)\n  }\n  /**\n   * Get a publisher for a macro service that return a promise\n   * @experimental\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getAsyncMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`\n      const uniqRequestId = this.getUniqRequestId()\n      const subscriptions = {}\n      return new Promise((resolve, reject) => {\n        const handler = ({ data = {} }) => {\n          const { result = {}, errors = [], requestId } = data\n          if (requestId === uniqRequestId) {\n            // Handle errors\n            if (errors.length > 0) {\n              reject(errors)\n            } else {\n              resolve(result)\n            }\n            this.unsubscribe(subscriptions)\n          }\n        }\n        // Create dynamic listener method\n        const listener = {\n          [name]: handler,\n          [DEFAULT_MACRO_CHANNEL]: handler\n        }\n        // Ad-Hoc subscription\n        this.subscribe(prefix, listener, subscriptions)\n        // Publish message on channel\n        this.publish(channel, {\n          debug,\n          hardFail,\n          name,\n          parameters,\n          requestId: uniqRequestId\n        })\n      })\n    }\n  }\n  /**\n   * Get client id\n   * @return {string} clientId\n   */\n  getClientId() {\n    return this.cometd.getClientId()\n  }\n  /**\n   * Get CometD handshake parameters\n   * @return {Object}\n   */\n  getHandshakeFields() {\n    const handshake = this.authentication()\n    return handshake.getHandshakeFields(this)\n  }\n  /**\n   * Get a publisher for a macro service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`\n      const requestId = this.getUniqRequestId()\n      return this.publish(channel, {\n        debug,\n        hardFail,\n        name,\n        parameters,\n        requestId\n      })\n    }\n  }\n  /**\n   * Get queued subscription index\n   * @return {Object} index\n   */\n  getQueuedSubscription(subscriptions = {}) {\n    const index = this.subscribeQueue.findIndex((element) => subscriptions === element.subscriptions)\n    return {\n      index,\n      queued: index > -1\n    }\n  }\n  /**\n   * Get resource\n   * @return {string}\n   */\n  getResource() {\n    return this.resource\n  }\n  /**\n   * Get sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.sandboxId\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.servers\n  }\n  /**\n   * Get a publisher for a service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getServicePublisher(prefix) {\n    return (method, parameters) => {\n      const channel = `${prefix}/${method}`\n      return this.publish(channel, parameters)\n    }\n  }\n  /**\n   * Get uniq request id\n   * @return {string}\n   */\n  getUniqRequestId() {\n    return `${this.getClientId()}:${this.uniqId}:${++this.requestId}`\n  }\n  /**\n   * Get user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.userId\n  }\n  /**\n   * Get user info\n   * @return {Objet}\n   */\n  getUserInfo() {\n    return this.userInfo\n  }\n  /**\n   * Manage handshake failure case\n   */\n  handshakeFailure() {\n    this.userId = null\n    this.userInfo = null\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  initialized(authentication) {\n    if (authentication) {\n      this.userId = authentication.userId\n      this.userInfo = authentication.userInfo\n    }\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onSuccessfulHandshake(authentication)\n      })\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return !this.cometd.isDisconnected()\n  }\n  /**\n   * Notify listeners when a message is lost\n   */\n  messageLost(channel, data) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onMessageLost(channel, data)\n      })\n  }\n  /**\n   * Negociate authentication\n   * @param {error} error\n   */\n  negotiationFailed(error) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onNegotiationFailed(error)\n      })\n  }\n  /**\n   * Notify listeners when no server url available\n   */\n  noServerUrlAvailable() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onNoServerUrlAvailable()\n      })\n  }\n  /**\n   * Wrap CometdD publish method\n   * @param {String} channel\n   * @param {Object} parameters\n   * @return {Object}\n   */\n  publish(channel, parameters = {}) {\n    this.cometd.publish(channel, parameters)\n    return { channel, parameters }\n  }\n  /**\n   * Remove a connection status listener\n   */\n  removeConnectionStatusListener(handler) {\n    const listener = this.connectionListeners[handler]\n    if (listener) {\n      listener.enabled = false\n    }\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.authentication = authentication\n  }\n  /**\n   * Set logging level for CometD client\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.cometd.setLogLevel(level)\n  }\n  /**\n   * Subsribe all methods defined in the listener for the given prefixed channel\n   * @param {string} prefix - Channel prefix\n   * @param {Object} listener\n   * @param {Object} subscriptions\n   * @return {Object} subscriptions\n   */\n  subscribe(prefix, listener = {}, subscriptions = {}) {\n    const { queued } = this.getQueuedSubscription(subscriptions)\n    if (!queued) {\n      // Store arguments to renew subscriptions on connection\n      this.subscribeQueue.push({ prefix, listener, subscriptions })\n    }\n    // Subscribe if user is connected\n    if (!this.cometd.isDisconnected()) {\n      for (let method in listener) {\n        if (listener.hasOwnProperty(method)) {\n          const channel = `${prefix}/${method}`\n          subscriptions[method] = this.cometd.subscribe(channel, listener[method])\n        }\n      }\n    }\n    return subscriptions\n  }\n  /**\n  * Remove current server url from the server list and shuffle for another one\n  */\n  updateServerUrl() {\n    this.servers.then((servers) => {\n      const index = servers.indexOf(this.serverUrl)\n      if (index > -1) {\n        servers.splice(index, 1)\n      }\n      if (servers.length === 0) {\n        // No more server available\n        this.noServerUrlAvailable()\n      } else {\n        this.serverUrl = shuffle(servers)\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`\n        })\n        setTimeout(() => {\n          this.cometd.handshake(this.getHandshakeFields())\n        }, UPDATE_SERVER_URL_DELAY)\n      }\n    })\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} subscriptions\n   */\n  unsubscribe(subscriptions = {}) {\n    // Unsubscribe\n    for (let method in subscriptions) {\n      if (subscriptions.hasOwnProperty(method)) {\n        const subscription = subscriptions[method]\n        this.cometd.unsubscribe(subscription)\n      }\n    }\n    // Remove subscription from queue\n    const { index, queued } = this.getQueuedSubscription(subscriptions)\n    if (queued) {\n      this.subscribeQueue.splice(index, 1)\n    }\n  }\n}\n","import { ClientHelper } from './helper'\nimport { API_URL, FORCE_HTTPS } from '../utils/index'\nimport { ConnectionStatusListener } from '../connection/connection-status'\n\n/**\n * Client config object.\n * @typedef {Object} ClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {function():AbstractHandshake} authentication - Return authentication properties\n * @property {string} resource - Client resource id\n * @property {Transports} transports - Client transports implementation\n */\n\n/**\n * ZetaPush Client to connect\n * @access public\n * @example\n * // Securized client with token based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       token: null\n *    })\n *   }\n * })\n * @example\n * // Client with authentication based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * @example\n * // Explicit deploymentId\n * const clientSimple = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * const clientWeak = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n *       token: '<SESSION-TOKEN>'\n *    })\n *   }\n * })\n */\nexport class Client {\n  /**\n   * Create a new ZetaPush Client\n   * @param {ClientConfig} config\n   */\n  constructor({ apiUrl = API_URL, sandboxId, forceHttps = FORCE_HTTPS, authentication, resource, transports }) {\n    /**\n     * @access private\n     * @type {ClientHelper}\n     */\n    this.helper = new ClientHelper({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      authentication,\n      resource,\n      transports\n    })\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    return this.helper.addConnectionStatusListener(listener)\n  }\n  /**\n   * Safely connect client to ZetaPush\n   */\n  connect() {\n    if (this.isConnected()) {\n      const handler = this.addConnectionStatusListener({\n        onConnectionClosed: () => {\n          this.removeConnectionStatusListener(handler)\n          this.helper.connect()\n        }\n      })\n      this.disconnect()\n    } else {\n      this.helper.connect()\n    }\n  }\n  /**\n   * Create a promise based service instance\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const api = client.createAsyncMacroService({\n   *   Type: WelcomeMacro\n   * })\n   * api.welcome({\n   *   message: Hello'\n   * }).then(({ message }) => {\n   *   console.log(message)\n   * })\n   */\n  createAsyncMacroService({ deploymentId, listener, Type }) {\n    return this.helper.createAsyncMacroService({ deploymentId, listener, Type })\n  }\n  /**\n   * Create a publish/subscribe for a service type\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const service = client.createService({\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * const service = client.createService({\n   *   deploymentId: 'stack_0'\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   */\n  createService({ deploymentId, listener, Type }) {\n    return this.helper.createService({ deploymentId, listener, Type })\n  }\n  /**\n   * Disonnect client from ZetaPush\n   */\n  disconnect() {\n    if (this.isConnected()) {\n      this.helper.disconnect()\n    }\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return this.helper.isConnected()\n  }\n  /**\n   * Get the client sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.helper.getSandboxId()\n  }\n  /**\n   * Get the client resource\n   * @return {string}\n   */\n  getResource() {\n    return this.helper.getResource()\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.helper.getServers()\n  }\n  /**\n   * Get the client user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.helper.getUserId()\n  }\n  /*\n   * Get the client user info\n   * @return {Object}\n   * @example\n   * // Create new ZetaPush Client\n   * const client = new Client({\n   *   sandboxId: '<YOUR-SANDBOX-ID>',\n   *   authentication: () => Authentication.simple({\n   *     login: '<YOUR-USER-LOGIN>',\n   *     password: '<YOUR-USER-PASSWORD>'\n   *   })\n   * })\n   * // Add connection establised listener\n   * client.onConnectionEstablished(() => {\n   *   console.log('onConnectionEstablished')\n   *   const profile = client.getUserInfo()\n   *   console.log('Your profile', profile)\n   * })\n   * client.connect()\n   */\n  getUserInfo() {\n    return this.helper.getUserInfo()\n  }\n  /**\n   * Remove a connection status listener\n   * @param {number} handler\n   */\n  removeConnectionStatusListener(handler) {\n    return this.helper.removeConnectionStatusListener(handler)\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.helper.setAuthentication(authentication)\n  }\n  /**\n   * Set logging level\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.helper.setLogLevel(level)\n  }\n  /**\n   * Set new client resource value\n   * @param {string} resource\n   */\n  setResource(resource) {\n    this.helper.setResource(resource)\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} service\n   */\n  unsubscribe(service) {\n    if (!service.$subscriptions) {\n      throw new TypeError('Missing $subscriptions property in service')\n    }\n    return this.helper.unsubscribe(service.$subscriptions)\n  }\n}\n\n/**\n * Add shorthand connection status method\n */\nObject.getOwnPropertyNames(ConnectionStatusListener.prototype).forEach((method) => {\n  // Only implements unsupported methods\n  if (!Client.prototype.hasOwnProperty(method)) {\n    Client.prototype[method] = function addListener(listener) {\n      return this.addConnectionStatusListener({\n        [method]: listener\n      })\n    }\n  }\n})\n","/**\n * Provide fallback for DOMStorage\n * @access protected\n */\nclass MemoryStorage {\n  constructor() {\n    this._map = new Map()\n  }\n  getItem(key) {\n    return this._map.get(key)\n  }\n  setItem(key, value) {\n    return this._map.get(key)\n  }\n  removeItem(key) {\n    this._map.delete(key)\n  }\n  clear() {\n    this._map = new Map()\n  }\n  key(n) {\n    return Array.from(this._map.keys())[n]\n  }\n  get length() {\n    return this._map.size\n  }\n}\n\n/**\n * @type {Storage}\n * @access protected\n */\nexport const platformStorage = typeof localStorage === 'undefined' ? new MemoryStorage() : localStorage\n","import { platformStorage } from './storage'\n\n/**\n * @type {string}\n */\nexport const ZETAPUSH_SESSION_KEY = 'zetapush.token'\n\n/**\n * Provide abstraction for token persistence\n * @access protected\n */\nexport class SessionPersistenceStrategy {\n  /**\n   * @param {{sandboxId: string, storage: DOMStorage}} parameters\n   */\n  constructor({ sandboxId, storage = platformStorage } = {}) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.key = `${ZETAPUSH_SESSION_KEY}.${sandboxId}`\n    /**\n     * @access private\n     * @type {DOMStorage}\n     */\n    this.storage = storage\n  }\n  /**\n   * @return {string} session The stored session\n   */\n  get() {\n    const { key, storage } = this\n    const json = storage.getItem(key) || '{}'\n    let session = {}\n    try {\n      session = JSON.parse(json)\n    } catch (e) { }\n    return session\n  }\n  /**\n   * @param {Object} session The session to store\n   */\n  set(session = {}) {\n    const { key, storage } = this\n    const json = JSON.stringify(session)\n    try {\n      storage.setItem(key, json)\n    } catch (e) { }\n    return session\n  }\n}\n","import { Client } from './basic'\nimport { Authentication } from '../authentication/handshake'\nimport { SessionPersistenceStrategy } from '../utils/session-persistence'\n\n/**\n * SmartClient config object.\n * @typedef {Object} SmartClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.SmartClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class SmartClient extends Client {\n  /**\n   * Create a new ZetaPush SmartClient\n   * @param {SmartClientConfig} config\n   */\n  constructor({ apiUrl, sandboxId, forceHttps, resource, transports }) {\n    const persistence = new SessionPersistenceStrategy({ sandboxId })\n\n    /**\n     * @return {AbstractHandshakeManager}\n     */\n    const authentication = () => {\n      const session = persistence.get()\n      const { token } = session\n\n      if (this.hasCredentials()) {\n        const { login, password } = this.getCredentials()\n        this.setCredentials({})\n        return Authentication.simple({\n          login,\n          password\n        })\n      } else {\n        if (this.isStronglyAuthenticated(session)) {\n          return Authentication.simple({\n            login: token,\n            password: null\n          })\n        } else {\n          return Authentication.weak({\n            token\n          })\n        }\n      }\n    }\n    // Initialize base client\n    super({\n      apiUrl, sandboxId, authentication, forceHttps, resource, transports\n    })\n    /**\n     * @access protected\n     * @type {SessionPersistenceStrategy}\n     */\n    this.persistence = persistence\n    /**\n     * @access protected\n     * @type {Object}\n     */\n    this.credentials = {}\n    /**\n     * Handle connection lifecycle events\n     * @access protected\n     * @type {Object}\n     */\n    this.lifeCycleConnectionHandler = this.addConnectionStatusListener({\n      onConnectionClosed() {\n        persistence.set({})\n      },\n      onSuccessfulHandshake(session) {\n        if (session.token) {\n          persistence.set(session)\n        }\n      }\n    })\n    // Properly disconnect client to avoir ghost connections\n    /*\n    window.addEventListener('beforeunload', () => {\n      this.removeConnectionStatusListener(this.lifeCycleConnectionHandler)\n      super.disconnect()\n    })\n    */\n  }\n  /**\n   * Disconnect client from ZetaPush backend\n   */\n  disconnect() {\n    super.disconnect()\n  }\n  /**\n   * @return {Object}\n   */\n  getCredentials() {\n    return this.credentials\n  }\n  /**\n   * @return {Object}\n   */\n  getSession() {\n    return this.persistence.get()\n  }\n  /**\n   * @return {boolean}\n   */\n  hasCredentials() {\n    const { login, password } = this.getCredentials()\n    return login && password\n  }\n  /**\n   * @return {boolean}\n   */\n  isStronglyAuthenticated(session = this.persistence.get()) {\n    return !this.isWeaklyAuthenticated(session) && typeof session.token === 'string'\n  }\n  /**\n   * @return {boolean}\n   */\n  isWeaklyAuthenticated(session = this.persistence.get()) {\n    return typeof session.publicToken === 'string'\n  }\n  /**\n   * @param {{login: string, password: string}} parameters\n   */\n  setCredentials({ login, password }) {\n    this.credentials = { login, password }\n  }\n}\n","import { Client } from './basic'\nimport { Authentication } from '../authentication/handshake'\nimport { SessionPersistenceStrategy } from '../utils/session-persistence'\n\n/**\n * WeakClient config object.\n * @typedef {Object} WeakClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} deploymentId - Authentication deployment id, default value is 'weak_0'\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.WeakClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n * @example\n * // Explicit deploymentId\n * // WeakClient provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n * // deploymentId default value is weak_0\n * const client = new ZetaPush.WeakClient({\n *   deploymentId: 'weak_0',\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class WeakClient extends Client {\n  /**\n   * Create a new ZetaPush WeakClient\n   * @param {WeakClientConfig} config\n   */\n  constructor({ apiUrl, sandboxId, deploymentId, forceHttps, resource, transports }) {\n    const authentication = () => {\n      const token = this.getToken()\n      const handshake = Authentication.weak({\n        deploymentId,\n        token\n      })\n      return handshake\n    }\n    /**\n     * Call Client constructor with specific parameters\n     */\n    super({ apiUrl, sandboxId, forceHttps, authentication, resource, transports })\n    // Handle successful handshake\n    const onSuccessfulHandshake = ({ publicToken, userId, token }) => {\n      if (token) {\n        this.strategy.set({ publicToken, userId, token })\n      }\n    }\n    this.addConnectionStatusListener({ onSuccessfulHandshake })\n    /**\n     * @access private\n     * @type {SessionPersistenceStrategy}\n     */\n    this.strategy = new SessionPersistenceStrategy({ sandboxId })\n  }\n  /**\n   * @return {string} The stored token\n   */\n  getToken() {\n    const { token } = this.strategy.get()\n    return token\n  }\n}\n","export { Authentication } from './authentication/handshake'\nexport { ConnectionStatusListener } from './connection/connection-status'\n\nexport { Client } from './client/basic'\nexport { SmartClient } from './client/smart'\nexport { WeakClient } from './client/weak'\n\nexport { services } from './mapping'\n\n/**\n * SDK Version\n * @type {string}\n */\nexport const VERSION = '3.2.0'\n"],"names":["FetchLongPollingTransport","_super","LongPollingTransport","that","Transport","derive","xhrSend","packet","fetch","url","method","body","headers","Object","assign","Content-Type","then","response","json","onSuccess","catch","onError","WebSocketTransport","_forceClose","context","event","this","webSocketClose","code","reason","onClose","_sameContext","_connecting","_context","_storeEnvelope","envelope","metaConnect","messageIds","i","messages","length","message","id","push","envelopes","join","_debug","getType","_websocketConnect","_cometd","getURL","replace","protocol","getConfiguration","WebSocket","webSocket","x","_webSocketSupported","_stickyReconnect","stickyReconnect","self","connectTimeout","connectTimer","setTimeout","call","onopen","clearTimeout","_webSocketConnected","onOpen","_warn","onclose","onmessage","wsMessage","onMessage","onerror","_webSocketSend","JSON","stringify","send","maxDelay","maxNetworkDelay","delay","getAdvice","timeout","_connected","timeouts","_send","exception","_self","_successCallback","reset","init","_notifySuccess","fn","_notifyFailure","failure","key","hasOwnProperty","element","close","convertToMessages","data","test","channel","undefined","removed","j","ids","split","index","Utils","inArray","splice","websocketCode","onFailure","registered","type","cometd","accept","version","crossDomain","websocketEnabled","abort","Service","$publish","Delegating","Simple","Weak","publicToken","fullRights","AbstractHandshake","authType","sandboxId","deploymentId","client","authentication","authData","getSandboxId","authVersion","getResource","resource","TokenHandshake","token","CredentialsHandshake","login","password","Authentication","DEFAULT_DEPLOYMENT_ID","create","DeployableNames","ConnectionStatusListener","_types","_transports","getTransportTypes","slice","findTransportTypes","result","negotiateTransport","types","transport","add","existing","find","remove","clear","value","String","Array","array","funktion","timeoutHandle","name","_fieldValue","object","_isString","isString","_isFunction","_zeroPad","Math","pow","_log","level","args","console","logger","now","Date","getHours","getMinutes","getSeconds","getMilliseconds","apply","_splitURL","exec","_configure","configuration","_config","_mixin","urlParts","hostAndPort","uri","afterURI","_crossDomain","_isCrossDomain","appendMessageTypeToURL","_info","uriSegments","lastSegmentIndex","match","indexOf","_removeListener","subscription","subscriptions","_listeners","listener","_removeSubscription","_clearSubscriptions","_setStatus","newStatus","_status","_isDisconnected","_nextMessageId","_messageId","_applyExtension","scope","callback","outgoing","handler","onExtensionException","xx","_applyIncomingExtensions","_extensions","extension","reverseIncomingExtensions","incoming","_applyOutgoingExtensions","_notify","onListenerException","_notifyListeners","channelParts","last","channelPart","_cancelDelayedSend","_scheduledSend","_delayedSend","operation","_backoff","time","_advice","interval","sync","extraPath","messageId","_clientId","clientId","_callbacks","rcvdMessages","_handleMessages","conduit","getTransport","connectionType","_handleFailure","_transport","_queueSend","_batch","_internalBatch","_messageQueue","_resetBackoff","_increaseBackoff","maxBackoff","backoffIncrement","_startBatch","_flushBatch","_endBatch","_connect","bayeuxMessage","advice","_delayedConnect","_updateAdvice","newAdvice","_disconnect","_notifyTransportFailure","oldTransport","newTransport","onTransportException","_handshake","handshakeProps","handshakeCallback","reconnect","_handshakeProps","_handshakeCallback","transportTypes","minimumVersion","supportedConnectionTypes","_putCallback","_delayedHandshake","_notifyCallback","onCallbackException","_handleCallback","_getCallback","_handleRemoteCall","_remoteCalls","_failHandshake","_handshakeResponse","successful","reestablish","_reestablish","action","_handshakeFailure","_failConnect","_connectResponse","_connectFailure","_failDisconnect","_disconnectResponse","_disconnectFailure","_failSubscribe","_subscribeResponse","_subscribeFailure","_failUnsubscribe","_unsubscribeResponse","_unsubscribeFailure","_failMessage","_messageResponse","_handshakeMessages","_messageFailure","_receive","_unconnectTime","_hasSubscriptions","_resolveScopedCallback","delegate","_addListener","isListener","_name","TransportRegistry","maxConnections","logLevel","requestHeaders","autoBatch","urls","maxURILength","maxInterval","deep","target","objects","arguments","propName","prop","targ","source","host","location","receive","failureMessage","registerTransport","unregisterTransport","unregistered","unregisterTransports","findTransport","getTransportRegistry","configure","handshake","disconnect","disconnectProps","disconnectCallback","startBatch","endBatch","batch","addListener","removeListener","clearListeners","subscribe","subscribeProps","subscribeCallback","unsubscribe","unsubscribeProps","unsubscribeCallback","resubscribe","clearSubscriptions","publish","content","publishProps","publishCallback","remoteCall","error","getStatus","isDisconnected","setBackoffIncrement","period","getBackoffIncrement","getBackoffPeriod","increaseBackoffPeriod","resetBackoffPeriod","setLogLevel","registerExtension","unregisterExtension","ext","getExtension","getName","getClientId","_type","_url","handle","parse","isArray","setURL","toString","baseObject","F","prototype","_coalesceEnvelopes","_envelopes","envelopeAndRequest","newEnvelope","newRequest","shift","concat","_transportSend","request","transportSend","expired","errorMessage","xhr","httpCode","xhrStatus","abortXHR","complete","requestId","_requestIds","_requests","_metaConnectComplete","_metaConnectRequest","_complete","success","nextEnvelope","nextRequest","_metaConnectSend","transportSuccess","responses","transportFailure","state","readyState","XMLHttpRequest","UNSENT","status","RequestTransport","_supportsCrossDomain","sameStack","received","window","WEBSOCKET_TRANSPORT","TRANSPORT_TYPES","LONG_POLLING_TRANSPORT","require$$0","Aggreg","items","owner","Stack","stack","page","guids","listeners","guid","Echo","parameter","Game","role","gameId","userId","userName","options","GameEngine","msgId","payload","callerId","maxGames","gameInfo","Gda","table","key2","column","columns","rows","start","stop","Remoting","fromResource","cmd","from","askingResource","capabilities","answeringResource","user","available","uid","GroupManagement","group","users","groupName","hardFail","actions","Httpclient","MacroDebug","breakpoint","enabled","path","exp","frame","parameters","breakpoints","debug","Macro","Sendmail","Messaging","Queue","description","originBusinessId","originDeploymentId","taskId","capacity","Notif","Rdbms","Sms_ovh","Cron","Search","indices","query","sort","Template","languageTag","Trigger","Zpfs_s3","oldPath","folder","parents","tags","metadata","contentType","flatten","metadataFiles","Zpfs_hdfs","Zpfs_s3compat","Userdir","userKeys","HTTP_PATTERN","API_URL","FORCE_HTTPS","normalizeApiUrl","apiUrl","charAt","shuffle","list","floor","random","getSecureUrl","forceHttps","HTTPS_PROTOCOL","getServers","transports","servers","map","server","isDerivedOf","Derived","Parent","getPrototypeOf","is","uuid","entropy","dictionary","reduce","previous","Message","ClientHelper","Transports","userInfo","uniqId","connectionToServerFail","connectionListeners","connected","wasConnected","serverUrl","sessionId","subscribeQueue","CometD","ALL","forEach","updateServerUrl","initialized","handshakeFailure","RECONNECT_NONE_VALUE","authenticationFailed","RECONNECT_HANDSHAKE_VALUE","negotiationFailed","_this","connectionWillClose","prefix","connectionEstablished","connectionBroken","connectionClosed","filter","onFailedHandshake","_this2","getHandshakeFields","noServerUrlAvailable","onConnectionBroken","onConnectionClosed","onConnectionEstablished","onConnectionToServerFail","onConnectionWillClose","Type","getAsyncMacroPublisher","createServiceByPublisher","isMacroType","getMacroPublisher","getServicePublisher","service","$subscriptions","uniqRequestId","_this3","getUniqRequestId","Promise","resolve","reject","errors","_this4","findIndex","_this5","onSuccessfulHandshake","onMessageLost","onNegotiationFailed","onNoServerUrlAvailable","getQueuedSubscription","queued","_this6","Client","helper","addConnectionStatusListener","isConnected","removeConnectionStatusListener","connect","createAsyncMacroService","createService","getUserId","getUserInfo","setAuthentication","setResource","TypeError","getOwnPropertyNames","MemoryStorage","_map","Map","get","delete","n","keys","size","platformStorage","localStorage","ZETAPUSH_SESSION_KEY","SessionPersistenceStrategy","storage","getItem","session","e","setItem","SmartClient","persistence","hasCredentials","getCredentials","setCredentials","simple","isStronglyAuthenticated","weak","credentials","lifeCycleConnectionHandler","set","isWeaklyAuthenticated","WeakClient","getToken","strategy"],"mappings":"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"}