{"version":3,"file":"zetapush.min.js","sources":["../node_modules/zetapush-cometd/lib/FetchLongPollingTransport.js","../node_modules/zetapush-cometd/lib/WebSocketTransport.js","../src/mapping/core.js","../src/mapping/authentications.js","../src/authentication/handshake.js","../src/connection/connection-status.js","../node_modules/zetapush-cometd/lib/TransportRegistry.js","../node_modules/zetapush-cometd/lib/Utils.js","../node_modules/zetapush-cometd/lib/Transport.js","../node_modules/zetapush-cometd/lib/RequestTransport.js","../node_modules/zetapush-cometd/lib/LongPollingTransport.js","../node_modules/zetapush-cometd/lib/browser/Transports.js","../node_modules/zetapush-cometd/lib/CometD.js","../src/mapping/services.js","../src/utils/index.js","../src/client/helper.js","../src/client/basic.js","../src/utils/storage.js","../src/utils/session-persistence.js","../src/client/smart.js","../src/client/weak.js","../src/index.js"],"sourcesContent":["var Transport = require('./Transport')\nvar LongPollingTransport = require('./LongPollingTransport')\n\n/**\n * Implements LongPollingTransport using borwser fetch() API\n * @access private\n * @return {FetchLongPollingTransport}\n */\nfunction FetchLongPollingTransport() {\n  var _super = new LongPollingTransport()\n  var that = Transport.derive(_super)\n\n  /**\n   * Implements transport via fetch() API\n   * @param {Object} packet\n   */\n  that.xhrSend = function (packet) {\n    FetchLongPollingTransport.fetch(packet.url, {\n      method: 'post',\n      body: packet.body,\n      headers: Object.assign(packet.headers, {\n        'Content-Type': 'application/json;charset=UTF-8'\n      })\n    })\n    .then(function (response) {\n      return response.json()\n    })\n    .then(packet.onSuccess)\n    .catch(packet.onError)\n  }\n\n  return that\n}\n\n// Reference global WebSocket \nFetchLongPollingTransport.fetch = 'Abstract'\n\n// Export FetchLongPollingTransport\nmodule.exports = FetchLongPollingTransport;\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\nfunction WebSocketTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _cometd;\n    // By default WebSocket is supported\n    var _webSocketSupported = true;\n    // Whether we were able to establish a WebSocket connection\n    var _webSocketConnected = false;\n    var _stickyReconnect = true;\n    // The context contains the envelopes that have been sent\n    // and the timeouts for the messages that have been sent.\n    var _context = null;\n    var _connecting = null;\n    var _connected = false;\n    var _successCallback = null;\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _webSocketSupported = true;\n        if (init) {\n            _webSocketConnected = false;\n        }\n        _stickyReconnect = true;\n        _context = null;\n        _connecting = null;\n        _connected = false;\n    };\n\n    function _forceClose(context, event) {\n        if (context) {\n            this.webSocketClose(context, event.code, event.reason);\n            // Force immediate failure of pending messages to trigger reconnect.\n            // This is needed because the server may not reply to our close()\n            // and therefore the onclose function is never called.\n            this.onClose(context, event);\n        }\n    }\n\n    function _sameContext(context) {\n        return context === _connecting || context === _context;\n    }\n\n    function _storeEnvelope(context, envelope, metaConnect) {\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            var message = envelope.messages[i];\n            if (message.id) {\n                messageIds.push(message.id);\n            }\n        }\n        context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n    }\n\n    function _websocketConnect(context) {\n        // We may have multiple attempts to open a WebSocket\n        // connection, for example a /meta/connect request that\n        // may take time, along with a user-triggered publish.\n        // Early return if we are already connecting.\n        if (_connecting) {\n            return;\n        }\n\n        // Mangle the URL, changing the scheme from 'http' to 'ws'.\n        var url = _cometd.getURL().replace(/^http/, 'ws');\n        this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n        try {\n            var protocol = _cometd.getConfiguration().protocol;\n            var WebSocket = WebSocketTransport.WebSocket;\n            context.webSocket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);\n            _connecting = context;\n        } catch (x) {\n            _webSocketSupported = false;\n            this._debug('Exception while creating WebSocket object', x);\n            throw x;\n        }\n\n        // By default use sticky reconnects.\n        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\n        var self = this;\n        var connectTimeout = _cometd.getConfiguration().connectTimeout;\n        if (connectTimeout > 0) {\n            context.connectTimer = self.setTimeout(function() {\n                _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n                // The connection was not opened, close anyway.\n                _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n            }, connectTimeout);\n        }\n\n        var onopen = function() {\n            _cometd._debug('WebSocket onopen', context);\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            if (_sameContext(context)) {\n                _connecting = null;\n                _context = context;\n                _webSocketConnected = true;\n                self.onOpen(context);\n            } else {\n                // We have a valid connection already, close this one.\n                _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n                _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n            }\n        };\n\n        // This callback is invoked when the server sends the close frame.\n        // The close frame for a connection may arrive *after* another\n        // connection has been opened, so we must make sure that actions\n        // are performed only if it's the same connection.\n        var onclose = function(event) {\n            event = event || {code: 1000};\n            _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            self.onClose(context, event);\n        };\n\n        var onmessage = function(wsMessage) {\n            _cometd._debug('WebSocket onmessage', wsMessage, context);\n            self.onMessage(context, wsMessage);\n        };\n\n        context.webSocket.onopen = onopen;\n        context.webSocket.onclose = onclose;\n        context.webSocket.onerror = function() {\n            // Clients should call onclose(), but if they do not we do it here for safety.\n            onclose({code: 1000, reason: 'Error'});\n        };\n        context.webSocket.onmessage = onmessage;\n\n        this._debug('Transport', this.getType(), 'configured callbacks on', context);\n    }\n\n    function _webSocketSend(context, envelope, metaConnect) {\n        var json = JSON.stringify(envelope.messages);\n        context.webSocket.send(json);\n        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);\n\n        // Manage the timeout waiting for the response.\n        var maxDelay = this.getConfiguration().maxNetworkDelay;\n        var delay = maxDelay;\n        if (metaConnect) {\n            delay += this.getAdvice().timeout;\n            _connected = true;\n        }\n\n        var self = this;\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            (function() {\n                var message = envelope.messages[i];\n                if (message.id) {\n                    messageIds.push(message.id);\n                    context.timeouts[message.id] = self.setTimeout(function() {\n                        _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n                        _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n                    }, delay);\n                }\n            })();\n        }\n\n        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n    }\n\n    _self._notifySuccess = function(fn, messages) {\n        fn.call(this, messages);\n    };\n\n    _self._notifyFailure = function(fn, context, messages, failure) {\n        fn.call(this, context, messages, failure);\n    };\n\n    function _send(context, envelope, metaConnect) {\n        try {\n            if (context === null) {\n                context = _connecting || {\n                        envelopes: {},\n                        timeouts: {}\n                    };\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _websocketConnect.call(this, context);\n            } else {\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        } catch (x) {\n            // Keep the semantic of calling response callbacks asynchronously after the request.\n            var self = this;\n            self.setTimeout(function() {\n                _forceClose.call(self, context, {\n                    code: 1000,\n                    reason: 'Exception',\n                    exception: x\n                });\n            }, 0);\n        }\n    }\n\n    _self.onOpen = function(context) {\n        var envelopes = context.envelopes;\n        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var element = envelopes[key];\n                var envelope = element[0];\n                var metaConnect = element[1];\n                // Store the success callback, which is independent from the envelope,\n                // so that it can be used to notify arrival of messages.\n                _successCallback = envelope.onSuccess;\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        }\n    };\n\n    _self.onMessage = function(context, wsMessage) {\n        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n        var close = false;\n        var messages = this.convertToMessages(wsMessage.data);\n        var messageIds = [];\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n\n            // Detect if the message is a response to a request we made.\n            // If it's a meta message, for sure it's a response; otherwise it's\n            // a publish message and publish responses don't have the data field.\n            if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n                if (message.id) {\n                    messageIds.push(message.id);\n\n                    var timeout = context.timeouts[message.id];\n                    if (timeout) {\n                        this.clearTimeout(timeout);\n                        delete context.timeouts[message.id];\n                        this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n                    }\n                }\n            }\n\n            if ('/meta/connect' === message.channel) {\n                _connected = false;\n            }\n            if ('/meta/disconnect' === message.channel && !_connected) {\n                close = true;\n            }\n        }\n\n        // Remove the envelope corresponding to the messages.\n        var removed = false;\n        var envelopes = context.envelopes;\n        for (var j = 0; j < messageIds.length; ++j) {\n            var id = messageIds[j];\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var ids = key.split(',');\n                    var index = Utils.inArray(id, ids);\n                    if (index >= 0) {\n                        removed = true;\n                        ids.splice(index, 1);\n                        var envelope = envelopes[key][0];\n                        var metaConnect = envelopes[key][1];\n                        delete envelopes[key];\n                        if (ids.length > 0) {\n                            envelopes[ids.join(',')] = [envelope, metaConnect];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if (removed) {\n            this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n        }\n\n        this._notifySuccess(_successCallback, messages);\n\n        if (close) {\n            this.webSocketClose(context, 1000, 'Disconnect');\n        }\n    };\n\n    _self.onClose = function(context, event) {\n        this._debug('Transport', this.getType(), 'closed', context, event);\n\n        if (_sameContext(context)) {\n            // Remember if we were able to connect.\n            // This close event could be due to server shutdown,\n            // and if it restarts we want to try websocket again.\n            _webSocketSupported = _stickyReconnect && _webSocketConnected;\n            _connecting = null;\n            _context = null;\n        }\n\n        var timeouts = context.timeouts;\n        context.timeouts = {};\n        for (var id in timeouts) {\n            if (timeouts.hasOwnProperty(id)) {\n                this.clearTimeout(timeouts[id]);\n            }\n        }\n\n        var envelopes = context.envelopes;\n        context.envelopes = {};\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var envelope = envelopes[key][0];\n                var metaConnect = envelopes[key][1];\n                if (metaConnect) {\n                    _connected = false;\n                }\n                var failure = {\n                    websocketCode: event.code,\n                    reason: event.reason\n                };\n                if (event.exception) {\n                    failure.exception = event.exception;\n                }\n                this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n            }\n        }\n    };\n\n    _self.registered = function(type, cometd) {\n        _super.registered(type, cometd);\n        _cometd = cometd;\n    };\n\n    _self.accept = function(version, crossDomain, url) {\n        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n        // Using !! to return a boolean (and not the WebSocket object).\n        return _webSocketSupported && !('undefined' === typeof WebSocket) && _cometd.websocketEnabled !== false;\n    };\n\n    _self.send = function(envelope, metaConnect) {\n        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);\n        _send.call(this, _context, envelope, metaConnect);\n    };\n\n    _self.webSocketClose = function(context, code, reason) {\n        try {\n            if (context.webSocket) {\n                context.webSocket.close(code, reason);\n            }\n        } catch (x) {\n            this._debug(x);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n        this.reset(true);\n    };\n\n    return _self;\n};\n\n// Reference global WebSocket \nWebSocketTransport.WebSocket = 'Abstract';\n\n// Export WebSocketTransport\nmodule.exports = WebSocketTransport;\n","/**\n * @access protected\n */\nexport class Service {\n  constructor({ $publish }) {\n    this.$publish = $publish\n  }\n}\n","import { Service } from './core'\n/**\n * Delegating authentication\n *\n * This authentication delegates authentication to an external auth provider\n * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL\n * <br>The response must be in JSON format\n *  Each key of the response will be considered a user information field name\n * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)\n * */\n/**\n * End-user API for the delegating authentication\n *\n * Provisionning verbs.\n * @access public\n * */\nexport class Delegating extends Service {\n\t/**\n\t * Get default deployment id associated to Delegating service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'delegating_0'\n\t}\n}\n/**\n * Local authentication\n *\n * Zetapush local authentication\n *  The configurer can choose the primary key and mandatory user fields for account creation\n *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)\n * */\n/**\n * End-user API for the simple local authentication\n *\n * These API verbs allow end-users to manage their account.\n * @access public\n * */\nexport class Simple extends Service {\n\t/**\n\t * Get default deployment id associated to Simple service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'simple_0'\n\t}\n}\n/**\n * Weak authentication\n *\n * The weak authentication allows for anonymous authentication of devices\n *  Such devices can display a qrcode to allow regular users to take control of them\n * */\n/**\n * User API for weak devices control\n *\n * User API for control and release of weakly authenticated user sessions.\n * @access public\n * */\nexport class Weak extends Service {\n\t/**\n\t * Get default deployment id associated to Weak service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'weak_0'\n\t}\n\t/**\n\t * Controls a session\n\t *\n\t * Takes control of a weak user session, identified by the given public token.\n\t * The public token has been previously made available by the controlled device, for example by displaying a QRCode.\n\t * Upon control notification, the client SDK of the controlled session is expected to re-handshake.\n\t * */\n\tcontrol({publicToken,fullRights}) { return this.$publish('control', {publicToken,fullRights})}\n\t/**\n\t * Returns the current token\n\t *\n\t * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.\n\t * The token can be used to log in as the same weak user another time.\n\t * */\n\tgetToken() { return this.$publish('getToken', {})}\n\t/**\n\t * Releases a session\n\t *\n\t * Releases control of a weak user session, identified by the given public token.\n\t * The weak user session must have been previously controlled by a call to 'control'.\n\t * */\n\trelease({publicToken,fullRights}) { return this.$publish('release', {publicToken,fullRights})}\n}\n","import { Delegating, Simple, Weak } from '../mapping/authentications'\n\n/**\n * ZetaPush deployables names\n */\nconst DeployableNames = {\n  AUTH_SIMPLE: 'simple',\n  AUTH_WEAK: 'weak',\n  AUTH_DELEGATING: 'delegating'\n}\n\n/**\n * Provide abstraction over CometD handshake data structure\n * @access protected\n */\nclass AbstractHandshake {\n  /**\n   * Create a new handshake manager\n   * @param {{authType: string, sandboxId: string, deploymentId: string}} parameters\n   */\n  constructor({ authType, sandboxId, deploymentId }) {\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.authType = authType\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.deploymentId = deploymentId\n  }\n  /**\n   * @param {ClientHelper} client\n   * @return {Object}\n   */\n  getHandshakeFields(client) {\n    const authentication = {\n      data: this.authData,\n      type: `${client.getSandboxId()}.${this.deploymentId}.${this.authType}`,\n      version: this.authVersion\n    }\n    if (client.getResource()) {\n      authentication.resource = client.getResource()\n    }\n    return {\n      ext: {\n        authentication\n      }\n    }\n  }\n  /**\n   * Get auth version\n   * @return {string}\n   */\n  get authVersion() {\n    return 'none'\n  }\n}\n\n/**\n * Provide abstraction over CometD token base handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass TokenHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, token: string}} parameters\n   */\n  constructor({ authType, deploymentId, token }) {\n    super({ deploymentId, authType })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.token = token\n  }\n  /**\n   * @return {token: string}\n   */\n  get authData() {\n    const { token } = this\n    return {\n      token\n    }\n  }\n}\n\n/**\n * Provide abstraction over CometD credentials based handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass CredentialsHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   */\n  constructor({ authType, deploymentId, login, password }) {\n    super({ authType, deploymentId })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.login = login\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.password = password\n  }\n  /**\n   * Get auth data\n   * @return {login: string, password: string}\n   */\n  get authData() {\n    const { login, password } = this\n    return {\n      login, password\n    }\n  }\n}\n\n/**\n * Factory to create handshake\n * @access public\n */\nexport class Authentication {\n  /**\n   * @param {{deploymentId: string, login: string, password: string}} parameters\n   * @return {CredentialsHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   login: <USER-LOGIN>,\n   *   password: '<USER-PASSWORD>'\n   * })\n   */\n  static simple({ deploymentId = Simple.DEFAULT_DEPLOYMENT_ID, login, password }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_SIMPLE,\n      deploymentId,\n      login,\n      password\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static weak({ deploymentId = Weak.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_WEAK,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-DELEGATING-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static delegating({ deploymentId = Delegating.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_DELEGATING,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   * @return {TokenHandshake|CredentialsHandshake}\n   */\n  static create({ authType, deploymentId, login, password }) {\n    if (password === null) {\n      return new TokenHandshake({ authType, deploymentId, token: login })\n    }\n    return new CredentialsHandshake({ authType, deploymentId, login, password })\n  }\n}\n","/**\n * Define life cycle connection methods\n * @access public\n */\nexport class ConnectionStatusListener {\n  /**\n   * Callback fired when connection is broken\n   */\n  onConnectionBroken() {}\n  /**\n   * Callback fired when connection is closed\n   */\n  onConnectionClosed() {}\n  /**\n   * Callback fired when connection is established\n   */\n  onConnectionEstablished() {}\n  /**\n   * Callback fired when an error occurs in connection to server step\n   * @param {Object} failure\n   */\n  onConnectionToServerFail(failure) {}\n  /**\n   * Callback fired when negociation with server failed\n   * @param {Object} failure\n   */\n  onNegotiationFailed(failure) {}\n  /**\n   * Callback no server url avaibale\n   */\n  onNoServerUrlAvailable() {}\n  /**\n  * Callback fired when connection will close\n  */\n  onConnectionWillClose() {}\n  /**\n   * Callback fired when an error occurs in handshake step\n   * @param {Object} failure\n   */\n  onFailedHandshake(failure) {}\n  /**\n   * Callback fired when a message is lost\n   */\n  onMessageLost() {}\n  /**\n   * Callback fired when handshake step succeed\n   * @param {Object} authentication\n   */\n  onSuccessfulHandshake(authentication) {}\n}\n","/**\n * A registry for transports used by the CometD object.\n */\nmodule.exports = function TransportRegistry() {\n    var _types = [];\n    var _transports = {};\n\n    this.getTransportTypes = function() {\n        return _types.slice(0);\n    };\n\n    this.findTransportTypes = function(version, crossDomain, url) {\n        var result = [];\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            if (_transports[type].accept(version, crossDomain, url) === true) {\n                result.push(type);\n            }\n        }\n        return result;\n    };\n\n    this.negotiateTransport = function(types, version, crossDomain, url) {\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            for (var j = 0; j < types.length; ++j) {\n                if (type === types[j]) {\n                    var transport = _transports[type];\n                    if (transport.accept(version, crossDomain, url) === true) {\n                        return transport;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    this.add = function(type, transport, index) {\n        var existing = false;\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                existing = true;\n                break;\n            }\n        }\n\n        if (!existing) {\n            if (typeof index !== 'number') {\n                _types.push(type);\n            } else {\n                _types.splice(index, 0, type);\n            }\n            _transports[type] = transport;\n        }\n\n        return !existing;\n    };\n\n    this.find = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                return _transports[type];\n            }\n        }\n        return null;\n    };\n\n    this.remove = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                _types.splice(i, 1);\n                var transport = _transports[type];\n                delete _transports[type];\n                return transport;\n            }\n        }\n        return null;\n    };\n\n    this.clear = function() {\n        _types = [];\n        _transports = {};\n    };\n\n    this.reset = function(init) {\n        for (var i = 0; i < _types.length; ++i) {\n            _transports[_types[i]].reset(init);\n        }\n    };\n};\n","exports.isString = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return typeof value === 'string' || value instanceof String;\n};\n\nexports.isArray = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return value instanceof Array;\n};\n\n/**\n * Returns whether the given element is contained into the given array.\n * @param element the element to check presence for\n * @param array the array to check for the element presence\n * @return the index of the element, if present, or a negative index if the element is not present\n */\nexports.inArray = function (element, array) {\n    for (var i = 0; i < array.length; ++i) {\n        if (element === array[i]) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nexports.setTimeout = function (cometd, funktion, delay) {\n    return setTimeout(function() {\n        try {\n            cometd._debug('Invoking timed function', funktion);\n            funktion();\n        } catch (x) {\n            cometd._debug('Exception invoking timed function', funktion, x);\n        }\n    }, delay);\n};\n\nexports.clearTimeout = function (timeoutHandle) {\n    clearTimeout(timeoutHandle);\n};\n","var Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports.\n */\nmodule.exports = function Transport() {\n    var _type;\n    var _cometd;\n    var _url;\n\n    /**\n     * Function invoked just after a transport has been successfully registered.\n     * @param type the type of transport (for example 'long-polling')\n     * @param cometd the cometd object this transport has been registered to\n     * @see #unregistered()\n     */\n    this.registered = function(type, cometd) {\n        _type = type;\n        _cometd = cometd;\n    };\n\n    /**\n     * Function invoked just after a transport has been successfully unregistered.\n     * @see #registered(type, cometd)\n     */\n    this.unregistered = function() {\n        _type = null;\n        _cometd = null;\n    };\n\n    this._debug = function() {\n        _cometd._debug.apply(_cometd, arguments);\n    };\n\n    this._mixin = function() {\n        return _cometd._mixin.apply(_cometd, arguments);\n    };\n\n    this.getConfiguration = function() {\n        return _cometd.getConfiguration();\n    };\n\n    this.getAdvice = function() {\n        return _cometd.getAdvice();\n    };\n\n    this.setTimeout = function(funktion, delay) {\n        return Utils.setTimeout(_cometd, funktion, delay);\n    };\n\n    this.clearTimeout = function(handle) {\n        Utils.clearTimeout(handle);\n    };\n\n    /**\n     * Converts the given response into an array of bayeux messages\n     * @param response the response to convert\n     * @return an array of bayeux messages obtained by converting the response\n     */\n    this.convertToMessages = function(response) {\n        if (Utils.isString(response)) {\n            try {\n                return JSON.parse(response);\n            } catch (x) {\n                this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n                throw x;\n            }\n        }\n        if (Utils.isArray(response)) {\n            return response;\n        }\n        if (response === undefined || response === null) {\n            return [];\n        }\n        if (response instanceof Object) {\n            return [response];\n        }\n        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n    };\n\n    /**\n     * Returns whether this transport can work for the given version and cross domain communication case.\n     * @param version a string indicating the transport version\n     * @param crossDomain a boolean indicating whether the communication is cross domain\n     * @param url the URL to connect to\n     * @return true if this transport can work for the given version and cross domain communication case,\n     * false otherwise\n     */\n    this.accept = function(version, crossDomain, url) {\n        throw 'Abstract';\n    };\n\n    /**\n     * Returns the type of this transport.\n     * @see #registered(type, cometd)\n     */\n    this.getType = function() {\n        return _type;\n    };\n\n    this.getURL = function() {\n        return _url;\n    };\n\n    this.setURL = function(url) {\n        _url = url;\n    };\n\n    this.send = function(envelope, metaConnect) {\n        throw 'Abstract';\n    };\n\n    this.reset = function(init) {\n        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n    };\n\n    this.abort = function() {\n        this._debug('Transport', _type, 'aborted');\n    };\n\n    this.toString = function() {\n        return this.getType();\n    };\n};\n\nmodule.exports.derive = function(baseObject) {\n    function F() {\n    }\n\n    F.prototype = baseObject;\n    return new F();\n};\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports based on requests.\n * The key responsibility is to allow at most 2 outstanding requests to the server,\n * to avoid that requests are sent behind a long poll.\n * To achieve this, we have one reserved request for the long poll, and all other\n * requests are serialized one after the other.\n */\nmodule.exports = function RequestTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _requestIds = 0;\n    var _metaConnectRequest = null;\n    var _requests = [];\n    var _envelopes = [];\n\n    function _coalesceEnvelopes(envelope) {\n        while (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes[0];\n            var newEnvelope = envelopeAndRequest[0];\n            var newRequest = envelopeAndRequest[1];\n            if (newEnvelope.url === envelope.url &&\n                newEnvelope.sync === envelope.sync) {\n                _envelopes.shift();\n                envelope.messages = envelope.messages.concat(newEnvelope.messages);\n                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n                continue;\n            }\n            break;\n        }\n    }\n\n    function _transportSend(envelope, request) {\n        this.transportSend(envelope, request);\n        request.expired = false;\n\n        if (!envelope.sync) {\n            var maxDelay = this.getConfiguration().maxNetworkDelay;\n            var delay = maxDelay;\n            if (request.metaConnect === true) {\n                delay += this.getAdvice().timeout;\n            }\n\n            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n            var self = this;\n            request.timeout = self.setTimeout(function() {\n                request.expired = true;\n                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n                var failure = {\n                    reason: errorMessage\n                };\n                var xhr = request.xhr;\n                failure.httpCode = self.xhrStatus(xhr);\n                self.abortXHR(xhr);\n                self._debug(errorMessage);\n                self.complete(request, false, request.metaConnect);\n                envelope.onFailure(xhr, envelope.messages, failure);\n            }, delay);\n        }\n    }\n\n    function _queueSend(envelope) {\n        var requestId = ++_requestIds;\n        var request = {\n            id: requestId,\n            metaConnect: false,\n            envelope: envelope\n        };\n\n        // Consider the metaConnect requests which should always be present\n        if (_requests.length < this.getConfiguration().maxConnections - 1) {\n            _requests.push(request);\n            _transportSend.call(this, envelope, request);\n        } else {\n            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n            _envelopes.push([envelope, request]);\n        }\n    }\n\n    function _metaConnectComplete(request) {\n        var requestId = request.id;\n        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);\n        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n            throw 'Longpoll request mismatch, completing request ' + requestId;\n        }\n\n        // Reset metaConnect request\n        _metaConnectRequest = null;\n    }\n\n    function _complete(request, success) {\n        var index = Utils.inArray(request, _requests);\n        // The index can be negative if the request has been aborted\n        if (index >= 0) {\n            _requests.splice(index, 1);\n        }\n\n        if (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes.shift();\n            var nextEnvelope = envelopeAndRequest[0];\n            var nextRequest = envelopeAndRequest[1];\n            this._debug('Transport dequeued request', nextRequest.id);\n            if (success) {\n                if (this.getConfiguration().autoBatch) {\n                    _coalesceEnvelopes.call(this, nextEnvelope);\n                }\n                _queueSend.call(this, nextEnvelope);\n                this._debug('Transport completed request', request.id, nextEnvelope);\n            } else {\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                var self = this;\n                self.setTimeout(function() {\n                    self.complete(nextRequest, false, nextRequest.metaConnect);\n                    var failure = {\n                        reason: 'Previous request failed'\n                    };\n                    var xhr = nextRequest.xhr;\n                    failure.httpCode = self.xhrStatus(xhr);\n                    nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n                }, 0);\n            }\n        }\n    }\n\n    _self.complete = function(request, success, metaConnect) {\n        if (metaConnect) {\n            _metaConnectComplete.call(this, request);\n        } else {\n            _complete.call(this, request, success);\n        }\n    };\n\n    /**\n     * Performs the actual send depending on the transport type details.\n     * @param envelope the envelope to send\n     * @param request the request information\n     */\n    _self.transportSend = function(envelope, request) {\n        throw 'Abstract';\n    };\n\n    _self.transportSuccess = function(envelope, request, responses) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, true, request.metaConnect);\n            if (responses && responses.length > 0) {\n                envelope.onSuccess(responses);\n            } else {\n                envelope.onFailure(request.xhr, envelope.messages, {\n                    httpCode: 204\n                });\n            }\n        }\n    };\n\n    _self.transportFailure = function(envelope, request, failure) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, false, request.metaConnect);\n            envelope.onFailure(request.xhr, envelope.messages, failure);\n        }\n    };\n\n    function _metaConnectSend(envelope) {\n        if (_metaConnectRequest !== null) {\n            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n        }\n\n        var requestId = ++_requestIds;\n        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);\n        var request = {\n            id: requestId,\n            metaConnect: true,\n            envelope: envelope\n        };\n        _transportSend.call(this, envelope, request);\n        _metaConnectRequest = request;\n    }\n\n    _self.send = function(envelope, metaConnect) {\n        if (metaConnect) {\n            _metaConnectSend.call(this, envelope);\n        } else {\n            _queueSend.call(this, envelope);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        for (var i = 0; i < _requests.length; ++i) {\n            var request = _requests[i];\n            if (request) {\n                this._debug('Aborting request', request);\n                if (!this.abortXHR(request.xhr)) {\n                    this.transportFailure(request.envelope, request, {reason: 'abort'});\n                }\n            }\n        }\n        if (_metaConnectRequest) {\n            this._debug('Aborting metaConnect request', _metaConnectRequest);\n            if (!this.abortXHR(_metaConnectRequest.xhr)) {\n                this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});\n            }\n        }\n        this.reset(true);\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _metaConnectRequest = null;\n        _requests = [];\n        _envelopes = [];\n    };\n\n    _self.abortXHR = function(xhr) {\n        if (xhr) {\n            try {\n                var state = xhr.readyState;\n                xhr.abort();\n                return state !== XMLHttpRequest.UNSENT;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return false;\n    };\n\n    _self.xhrStatus = function(xhr) {\n        if (xhr) {\n            try {\n                return xhr.status;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return -1;\n    };\n\n    return _self;\n};\n","var Transport = require('./Transport');\nvar RequestTransport = require('./RequestTransport');\n\nmodule.exports = function LongPollingTransport() {\n    var _super = new RequestTransport();\n    var _self = Transport.derive(_super);\n    // By default, support cross domain\n    var _supportsCrossDomain = true;\n\n    _self.accept = function(version, crossDomain, url) {\n        return _supportsCrossDomain || !crossDomain;\n    };\n\n    _self.xhrSend = function(packet) {\n        throw 'Abstract';\n    };\n\n    _self.transportSend = function(envelope, request) {\n        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n        var self = this;\n        try {\n            var sameStack = true;\n            request.xhr = this.xhrSend({\n                transport: this,\n                url: envelope.url,\n                sync: envelope.sync,\n                headers: this.getConfiguration().requestHeaders,\n                body: JSON.stringify(envelope.messages),\n                onSuccess: function(response) {\n                    self._debug('Transport', self.getType(), 'received response', response);\n                    var success = false;\n                    try {\n                        var received = self.convertToMessages(response);\n                        if (received.length === 0) {\n                            _supportsCrossDomain = false;\n                            self.transportFailure(envelope, request, {\n                                httpCode: 204\n                            });\n                        } else {\n                            success = true;\n                            self.transportSuccess(envelope, request, received);\n                        }\n                    } catch (x) {\n                        self._debug(x);\n                        if (!success) {\n                            _supportsCrossDomain = false;\n                            var failure = {\n                                exception: x\n                            };\n                            failure.httpCode = self.xhrStatus(request.xhr);\n                            self.transportFailure(envelope, request, failure);\n                        }\n                    }\n                },\n                onError: function(reason, exception) {\n                    self._debug('Transport', self.getType(), 'received error', reason, exception);\n                    _supportsCrossDomain = false;\n                    var failure = {\n                        reason: reason,\n                        exception: exception\n                    };\n                    failure.httpCode = self.xhrStatus(request.xhr);\n                    if (sameStack) {\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        self.setTimeout(function() {\n                            self.transportFailure(envelope, request, failure);\n                        }, 0);\n                    } else {\n                        self.transportFailure(envelope, request, failure);\n                    }\n                }\n            });\n            sameStack = false;\n        } catch (x) {\n            _supportsCrossDomain = false;\n            // Keep the semantic of calling response callbacks asynchronously after the request\n            self.setTimeout(function() {\n                self.transportFailure(envelope, request, {\n                    exception: x\n                });\n            }, 0);\n        }\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _supportsCrossDomain = true;\n    };\n\n    return _self;\n};\n","var TRANSPORT_TYPES = require('../TransportTypes');\n\nvar FetchLongPollingTransport = require('../FetchLongPollingTransport');\nvar WebSocketTransport = require('../WebSocketTransport');\n\n// Use node-fetch implementation\nmodule.exports.fetch = FetchLongPollingTransport.fetch = function() {\n  return fetch.apply(window, arguments);\n};\n\n// Use node-websocket implementation\nmodule.exports.WebSocket = WebSocketTransport.WebSocket = typeof WebSocket === 'undefined' ? null : WebSocket;\n\n/**\n * Long polling transport layer\n */\nvar WEBSOCKET_TRANSPORT = {\n  type: TRANSPORT_TYPES.WEBSOCKET,\n  Transport: WebSocketTransport\n};\nmodule.exports.WEBSOCKET_TRANSPORT = WEBSOCKET_TRANSPORT;\n\n/**\n * Long polling transport layer\n */\nvar LONG_POLLING_TRANSPORT = {\n  type: TRANSPORT_TYPES.LONG_POLLING,\n  Transport: FetchLongPollingTransport\n};\nmodule.exports.LONG_POLLING_TRANSPORT = LONG_POLLING_TRANSPORT;\n\n/**\n * CometD Transports Layers map\n */\nvar ALL = [\n  WEBSOCKET_TRANSPORT,\n  LONG_POLLING_TRANSPORT\n];\nmodule.exports.ALL = ALL;\n","var TransportRegistry = require('./TransportRegistry');\nvar Utils = require('./Utils');\n/**\n * The constructor for a CometD object, identified by an optional name.\n * The default name is the string 'default'.\n * In the rare case a page needs more than one Bayeux conversation,\n * a new instance can be created via:\n * <pre>\n * var bayeuxUrl2 = ...;\n *\n * // Dojo style\n * var cometd2 = new dojox.CometD('another_optional_name');\n *\n * // jQuery style\n * var cometd2 = new $.CometD('another_optional_name');\n *\n * cometd2.init({url: bayeuxUrl2});\n * </pre>\n * @param name the optional name of this cometd object\n */\nmodule.exports = function CometD(name) {\n    var _cometd = this;\n    var _name = name || 'default';\n    var _crossDomain = false;\n    var _transports = new TransportRegistry();\n    var _transport;\n    var _status = 'disconnected';\n    var _messageId = 0;\n    var _clientId = null;\n    var _batch = 0;\n    var _messageQueue = [];\n    var _internalBatch = false;\n    var _listeners = {};\n    var _backoff = 0;\n    var _scheduledSend = null;\n    var _extensions = [];\n    var _advice = {};\n    var _handshakeProps;\n    var _handshakeCallback;\n    var _callbacks = {};\n    var _remoteCalls = {};\n    var _reestablish = false;\n    var _connected = false;\n    var _unconnectTime = 0;\n    var _handshakeMessages = 0;\n    var _config = {\n        protocol: null,\n        stickyReconnect: true,\n        connectTimeout: 0,\n        maxConnections: 2,\n        backoffIncrement: 1000,\n        maxBackoff: 60000,\n        logLevel: 'info',\n        reverseIncomingExtensions: true,\n        maxNetworkDelay: 10000,\n        requestHeaders: {},\n        appendMessageTypeToURL: true,\n        autoBatch: false,\n        urls: {},\n        maxURILength: 2000,\n        advice: {\n            timeout: 60000,\n            interval: 0,\n            reconnect: 'retry',\n            maxInterval: 0\n        }\n    };\n\n    function _fieldValue(object, name) {\n        try {\n            return object[name];\n        } catch (x) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Mixes in the given objects into the target object by copying the properties.\n     * @param deep if the copy must be deep\n     * @param target the target object\n     * @param objects the objects whose properties are copied into the target\n     */\n    this._mixin = function(deep, target, objects) {\n        var result = target || {};\n\n        // Skip first 2 parameters (deep and target), and loop over the others\n        for (var i = 2; i < arguments.length; ++i) {\n            var object = arguments[i];\n\n            if (object === undefined || object === null) {\n                continue;\n            }\n\n            for (var propName in object) {\n                if (object.hasOwnProperty(propName)) {\n                    var prop = _fieldValue(object, propName);\n                    var targ = _fieldValue(result, propName);\n\n                    // Avoid infinite loops\n                    if (prop === target) {\n                        continue;\n                    }\n                    // Do not mixin undefined values\n                    if (prop === undefined) {\n                        continue;\n                    }\n\n                    if (deep && typeof prop === 'object' && prop !== null) {\n                        if (prop instanceof Array) {\n                            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n                        } else {\n                            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                            result[propName] = this._mixin(deep, source, prop);\n                        }\n                    } else {\n                        result[propName] = prop;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    function _isString(value) {\n        return Utils.isString(value);\n    }\n\n    function _isFunction(value) {\n        if (value === undefined || value === null) {\n            return false;\n        }\n        return typeof value === 'function';\n    }\n\n    function _zeroPad(value, length) {\n        var result = '';\n        while (--length > 0) {\n            if (value >= Math.pow(10, length)) {\n                break;\n            }\n            result += '0';\n        }\n        result += value;\n        return result;\n    }\n\n    function _log(level, args) {\n        if ('undefined' !== typeof console) {\n            var logger = console[level];\n            if (_isFunction(logger)) {\n                var now = new Date();\n                [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n                logger.apply(console, args);\n            }\n        }\n    }\n\n    this._warn = function() {\n        _log('warn', arguments);\n    };\n\n    this._info = function() {\n        if (_config.logLevel !== 'warn') {\n            _log('info', arguments);\n        }\n    };\n\n    this._debug = function() {\n        if (_config.logLevel === 'debug') {\n            _log('debug', arguments);\n        }\n    };\n\n    function _splitURL(url) {\n        // [1] = protocol://,\n        // [2] = host:port,\n        // [3] = host,\n        // [4] = IPv6_host,\n        // [5] = IPv4_host,\n        // [6] = :port,\n        // [7] = port,\n        // [8] = uri,\n        // [9] = rest (query / fragment)\n        return /(^https?:\\/\\/)?(((\\[[^\\]]+\\])|([^:\\/\\?#]+))(:(\\d+))?)?([^\\?#]*)(.*)?/.exec(url);\n    }\n\n    /**\n     * Returns whether the given hostAndPort is cross domain.\n     * The default implementation checks against window.location.host\n     * but this function can be overridden to make it work in non-browser\n     * environments.\n     *\n     * @param hostAndPort the host and port in format host:port\n     * @return whether the given hostAndPort is cross domain\n     */\n    this._isCrossDomain = function(hostAndPort) {\n        var host = typeof location === 'undefined' ? hostAndPort : location.host;\n        return hostAndPort && hostAndPort !== host;\n    };\n\n    function _configure(configuration) {\n        _cometd._debug('Configuring cometd object with', configuration);\n        // Support old style param, where only the Bayeux server URL was passed\n        if (_isString(configuration)) {\n            configuration = { url: configuration };\n        }\n        if (!configuration) {\n            configuration = {};\n        }\n\n        _config = _cometd._mixin(false, _config, configuration);\n\n        var url = _cometd.getURL();\n        if (!url) {\n            throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n        }\n\n        // Check if we're cross domain.\n        var urlParts = _splitURL(url);\n        var hostAndPort = urlParts[2];\n        var uri = urlParts[8];\n        var afterURI = urlParts[9];\n        _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\n        // Check if appending extra path is supported\n        if (_config.appendMessageTypeToURL) {\n            if (afterURI !== undefined && afterURI.length > 0) {\n                _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                _config.appendMessageTypeToURL = false;\n            } else {\n                var uriSegments = uri.split('/');\n                var lastSegmentIndex = uriSegments.length - 1;\n                if (uri.match(/\\/$/)) {\n                    lastSegmentIndex -= 1;\n                }\n                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n                    // It will be difficult to add the extra path in this case\n                    _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                    _config.appendMessageTypeToURL = false;\n                }\n            }\n        }\n    }\n\n    function _removeListener(subscription) {\n        if (subscription) {\n            var subscriptions = _listeners[subscription.channel];\n            if (subscriptions && subscriptions[subscription.id]) {\n                delete subscriptions[subscription.id];\n                _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n            }\n        }\n    }\n\n    function _removeSubscription(subscription) {\n        if (subscription && !subscription.listener) {\n            _removeListener(subscription);\n        }\n    }\n\n    function _clearSubscriptions() {\n        for (var channel in _listeners) {\n            if (_listeners.hasOwnProperty(channel)) {\n                var subscriptions = _listeners[channel];\n                if (subscriptions) {\n                    for (var i = 0; i < subscriptions.length; ++i) {\n                        _removeSubscription(subscriptions[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    function _setStatus(newStatus) {\n        if (_status !== newStatus) {\n            _cometd._debug('Status', _status, '->', newStatus);\n            _status = newStatus;\n        }\n    }\n\n    function _isDisconnected() {\n        return _status === 'disconnecting' || _status === 'disconnected';\n    }\n\n    function _nextMessageId() {\n        var result = ++_messageId;\n        return '' + result;\n    }\n\n    function _applyExtension(scope, callback, name, message, outgoing) {\n        try {\n            return callback.call(scope, message);\n        } catch (x) {\n            var handler = _cometd.onExtensionException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking extension exception handler', name, x);\n                try {\n                    handler.call(_cometd, x, name, outgoing, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of extension exception handler', name, xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of extension', name, x);\n            }\n            return message;\n        }\n    }\n\n    function _applyIncomingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;\n            var extension = _extensions[index];\n            var callback = extension.extension.incoming;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _applyOutgoingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var extension = _extensions[i];\n            var callback = extension.extension.outgoing;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _notify(channel, message) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions && subscriptions.length > 0) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                var subscription = subscriptions[i];\n                // Subscriptions may come and go, so the array may have 'holes'\n                if (subscription) {\n                    try {\n                        subscription.callback.call(subscription.scope, message);\n                    } catch (x) {\n                        var handler = _cometd.onListenerException;\n                        if (_isFunction(handler)) {\n                            _cometd._debug('Invoking listener exception handler', subscription, x);\n                            try {\n                                handler.call(_cometd, x, subscription, subscription.listener, message);\n                            } catch (xx) {\n                                _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                            }\n                        } else {\n                            _cometd._info('Exception during execution of listener', subscription, message, x);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function _notifyListeners(channel, message) {\n        // Notify direct listeners\n        _notify(channel, message);\n\n        // Notify the globbing listeners\n        var channelParts = channel.split('/');\n        var last = channelParts.length - 1;\n        for (var i = last; i > 0; --i) {\n            var channelPart = channelParts.slice(0, i).join('/') + '/*';\n            // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n            // so we stop at the first non recursive globbing\n            if (i === last) {\n                _notify(channelPart, message);\n            }\n            // Add the recursive globber and notify\n            channelPart += '*';\n            _notify(channelPart, message);\n        }\n    }\n\n    function _cancelDelayedSend() {\n        if (_scheduledSend !== null) {\n            Utils.clearTimeout(_scheduledSend);\n        }\n        _scheduledSend = null;\n    }\n\n    function _delayedSend(operation, delay) {\n        if ('undefined' === typeof delay) {\n          delay = _backoff\n        }\n        _cancelDelayedSend();\n        var time = _advice.interval + delay;\n        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n        _scheduledSend = Utils.setTimeout(_cometd, operation, time);\n    }\n\n    // Needed to break cyclic dependencies between function definitions\n    var _handleMessages;\n    var _handleFailure;\n\n    /**\n     * Delivers the messages to the CometD server\n     * @param sync whether the send is synchronous\n     * @param messages the array of messages to send\n     * @param metaConnect true if this send is on /meta/connect\n     * @param extraPath an extra path to append to the Bayeux server URL\n     */\n    function _send(sync, messages, metaConnect, extraPath) {\n        // We must be sure that the messages have a clientId.\n        // This is not guaranteed since the handshake may take time to return\n        // (and hence the clientId is not known yet) and the application\n        // may create other messages.\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var messageId = message.id;\n\n            if (_clientId) {\n                message.clientId = _clientId;\n            }\n\n            message = _applyOutgoingExtensions(message);\n            if (message !== undefined && message !== null) {\n                // Extensions may have modified the message id, but we need to own it.\n                message.id = messageId;\n                messages[i] = message;\n            } else {\n                delete _callbacks[messageId];\n                messages.splice(i--, 1);\n            }\n        }\n\n        if (messages.length === 0) {\n            return;\n        }\n\n        var url = _cometd.getURL();\n        if (_config.appendMessageTypeToURL) {\n            // If url does not end with '/', then append it\n            if (!url.match(/\\/$/)) {\n                url = url + '/';\n            }\n            if (extraPath) {\n                url = url + extraPath;\n            }\n        }\n\n        var envelope = {\n            url: url,\n            sync: sync,\n            messages: messages,\n            onSuccess: function(rcvdMessages) {\n                try {\n                    _handleMessages.call(_cometd, rcvdMessages);\n                } catch (x) {\n                    _cometd._info('Exception during handling of messages', x);\n                }\n            },\n            onFailure: function(conduit, messages, failure) {\n                try {\n                    var transport = _cometd.getTransport();\n                    failure.connectionType = transport ? transport.getType() : \"unknown\";\n                    _handleFailure.call(_cometd, conduit, messages, failure);\n                } catch (x) {\n                    _cometd._info('Exception during handling of failure', x);\n                }\n            }\n        };\n        _cometd._debug('Send', envelope);\n        _transport.send(envelope, metaConnect);\n    }\n\n    function _queueSend(message) {\n        if (_batch > 0 || _internalBatch === true) {\n            _messageQueue.push(message);\n        } else {\n            _send(false, [message], false);\n        }\n    }\n\n    /**\n     * Sends a complete bayeux message.\n     * This method is exposed as a public so that extensions may use it\n     * to send bayeux message directly, for example in case of re-sending\n     * messages that have already been sent but that for some reason must\n     * be resent.\n     */\n    this.send = _queueSend;\n\n    function _resetBackoff() {\n        _backoff = 0;\n    }\n\n    function _increaseBackoff() {\n        if (_backoff < _config.maxBackoff) {\n            _backoff += _config.backoffIncrement;\n        }\n        return _backoff;\n    }\n\n    /**\n     * Starts a the batch of messages to be sent in a single request.\n     * @see #_endBatch(sendMessages)\n     */\n    function _startBatch() {\n        ++_batch;\n        _cometd._debug('Starting batch, depth', _batch);\n    }\n\n    function _flushBatch() {\n        var messages = _messageQueue;\n        _messageQueue = [];\n        if (messages.length > 0) {\n            _send(false, messages, false);\n        }\n    }\n\n    /**\n     * Ends the batch of messages to be sent in a single request,\n     * optionally sending messages present in the message queue depending\n     * on the given argument.\n     * @see #_startBatch()\n     */\n    function _endBatch() {\n        --_batch;\n        _cometd._debug('Ending batch, depth', _batch);\n        if (_batch < 0) {\n            throw 'Calls to startBatch() and endBatch() are not paired';\n        }\n\n        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n            _flushBatch();\n        }\n    }\n\n    /**\n     * Sends the connect message\n     */\n    function _connect() {\n        if (!_isDisconnected()) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/connect',\n                connectionType: _transport.getType()\n            };\n\n            // In case of reload or temporary loss of connection\n            // we want the next successful connect to return immediately\n            // instead of being held by the server, so that connect listeners\n            // can be notified that the connection has been re-established\n            if (!_connected) {\n                bayeuxMessage.advice = { timeout: 0 };\n            }\n\n            _setStatus('connecting');\n            _cometd._debug('Connect sent', bayeuxMessage);\n            _send(false, [bayeuxMessage], true, 'connect');\n            _setStatus('connected');\n        }\n    }\n\n    function _delayedConnect(delay) {\n        _setStatus('connecting');\n        _delayedSend(function() {\n            _connect();\n        }, delay);\n    }\n\n    function _updateAdvice(newAdvice) {\n        if (newAdvice) {\n            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n            _cometd._debug('New advice', _advice);\n        }\n    }\n\n    function _disconnect(abort) {\n        _cancelDelayedSend();\n        if (abort && _transport) {\n            _transport.abort();\n        }\n        _clientId = null;\n        _setStatus('disconnected');\n        _batch = 0;\n        _resetBackoff();\n        _transport = null;\n\n        // Fail any existing queued message\n        if (_messageQueue.length > 0) {\n            var messages = _messageQueue;\n            _messageQueue = [];\n            _handleFailure.call(_cometd, undefined, messages, {\n                reason: 'Disconnected'\n            });\n        }\n    }\n\n    function _notifyTransportFailure(oldTransport, newTransport, failure) {\n        var handler = _cometd.onTransportException;\n        if (_isFunction(handler)) {\n            _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n            try {\n                handler.call(_cometd, failure, oldTransport, newTransport);\n            } catch (x) {\n                _cometd._info('Exception during execution of transport exception handler', x);\n            }\n        }\n    }\n\n    /**\n     * Sends the initial handshake message\n     */\n    function _handshake(handshakeProps, handshakeCallback) {\n        if (_isFunction(handshakeProps)) {\n            handshakeCallback = handshakeProps;\n            handshakeProps = undefined;\n        }\n\n        _clientId = null;\n\n        _clearSubscriptions();\n\n        // Reset the transports if we're not retrying the handshake\n        if (_isDisconnected()) {\n            _transports.reset(true);\n            _updateAdvice(_config.advice);\n        } else {\n            // We are retrying the handshake, either because another handshake failed\n            // and we're backing off, or because the server timed us out and asks us to\n            // re-handshake: in both cases, make sure that if the handshake succeeds\n            // the next action is a connect.\n            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));\n        }\n\n        _batch = 0;\n\n        // Mark the start of an internal batch.\n        // This is needed because handshake and connect are async.\n        // It may happen that the application calls init() then subscribe()\n        // and the subscribe message is sent before the connect message, if\n        // the subscribe message is not held until the connect message is sent.\n        // So here we start a batch to hold temporarily any message until\n        // the connection is fully established.\n        _internalBatch = true;\n\n        // Save the properties provided by the user, so that\n        // we can reuse them during automatic re-handshake\n        _handshakeProps = handshakeProps;\n        _handshakeCallback = handshakeCallback;\n\n        var version = '1.0';\n\n        // Figure out the transports to send to the server\n        var url = _cometd.getURL();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            version: version,\n            minimumVersion: version,\n            channel: '/meta/handshake',\n            supportedConnectionTypes: transportTypes,\n            advice: {\n                timeout: _advice.timeout,\n                interval: _advice.interval\n            }\n        };\n        // Do not allow the user to override important fields.\n        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, handshakeCallback);\n\n        // Pick up the first available transport as initial transport\n        // since we don't know if the server supports it\n        if (!_transport) {\n            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n            if (!_transport) {\n                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                _cometd._warn(failure);\n                throw failure;\n            }\n        }\n\n        _cometd._debug('Initial transport is', _transport.getType());\n\n        // We started a batch to hold the application messages,\n        // so here we must bypass it and send immediately.\n        _setStatus('handshaking');\n        _cometd._debug('Handshake sent', message);\n        _send(false, [message], false, 'handshake');\n    }\n\n    function _delayedHandshake(delay) {\n        _setStatus('handshaking');\n\n        // We will call _handshake() which will reset _clientId, but we want to avoid\n        // that between the end of this method and the call to _handshake() someone may\n        // call publish() (or other methods that call _queueSend()).\n        _internalBatch = true;\n\n        _delayedSend(function() {\n            _handshake(_handshakeProps, _handshakeCallback);\n        }, delay);\n    }\n\n    function _notifyCallback(callback, message) {\n        try {\n            callback.call(_cometd, message);\n        } catch (x) {\n            var handler = _cometd.onCallbackException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking callback exception handler', x);\n                try {\n                    handler.call(_cometd, x, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of callback exception handler', xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of message callback', x);\n            }\n        }\n    }\n\n    this._getCallback = function(messageId) {\n        return _callbacks[messageId];\n    };\n\n    this._putCallback = function(messageId, callback) {\n        var result = this._getCallback(messageId);\n        if (_isFunction(callback)) {\n            _callbacks[messageId] = callback;\n        }\n        return result;\n    };\n\n    function _handleCallback(message) {\n        var callback = _cometd._getCallback([message.id]);\n        if (_isFunction(callback)) {\n            delete _callbacks[message.id];\n            _notifyCallback(callback, message);\n        }\n    }\n\n    function _handleRemoteCall(message) {\n        var context = _remoteCalls[message.id];\n        delete _remoteCalls[message.id];\n        _cometd._debug('Handling remote call response for', message, 'with context', context);\n        if (context) {\n            // Clear the timeout, if present.\n            var timeout = context.timeout;\n            if (timeout) {\n                Utils.clearTimeout(timeout);\n            }\n\n            var callback = context.callback;\n            if (_isFunction(callback)) {\n                _notifyCallback(callback, message);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _failHandshake(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/handshake', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // Only try again if we haven't been disconnected and\n        // the advice permits us to retry the handshake\n        var retry = !_isDisconnected() && _advice.reconnect !== 'none';\n        if (retry) {\n            _increaseBackoff();\n            _delayedHandshake();\n        } else {\n            _disconnect(true);\n        }\n    }\n\n    function _handshakeResponse(message) {\n        if (message.successful) {\n            // Save clientId, figure out transport, then follow the advice to connect\n            _clientId = message.clientId;\n\n            var url = _cometd.getURL();\n            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);\n            if (newTransport === null) {\n                var failure = 'Could not negotiate transport with server; client=[' +\n                    _transports.findTransportTypes(message.version, _crossDomain, url) +\n                    '], server=[' + message.supportedConnectionTypes + ']';\n                var oldTransport = _cometd.getTransport();\n                _notifyTransportFailure(oldTransport.getType(), null, {\n                    reason: failure,\n                    connectionType: oldTransport.getType(),\n                    transport: oldTransport\n                });\n                _cometd._warn(failure);\n                _disconnect(true);\n                return;\n            } else if (_transport !== newTransport) {\n                _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n                _transport = newTransport;\n            }\n\n            // End the internal batch and allow held messages from the application\n            // to go to the server (see _handshake() where we start the internal batch).\n            _internalBatch = false;\n            _flushBatch();\n\n            // Here the new transport is in place, as well as the clientId, so\n            // the listeners can perform a publish() if they want.\n            // Notify the listeners before the connect below.\n            message.reestablish = _reestablish;\n            _reestablish = true;\n\n            _handleCallback(message);\n            _notifyListeners('/meta/handshake', message);\n\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    _disconnect(true);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failHandshake(message);\n        }\n    }\n\n    function _handshakeFailure(message) {\n        var version = '1.0';\n        var url = _cometd.getURL();\n        var oldTransport = _cometd.getTransport();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n        var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n        if (!newTransport) {\n            _notifyTransportFailure(oldTransport.getType(), null, message.failure);\n            _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');\n            _disconnect(true);\n            _failHandshake(message);\n        } else {\n            _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());\n            _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);\n            _failHandshake(message);\n            _transport = newTransport;\n        }\n    }\n\n    function _failConnect(message) {\n        // Notify the listeners after the status change but before the next action\n        _notifyListeners('/meta/connect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // This may happen when the server crashed, the current clientId\n        // will be invalid, and the server will ask to handshake again\n        // Listeners can call disconnect(), so check the state after they run\n        var action = _isDisconnected() ? 'none' : _advice.reconnect;\n        switch (action) {\n            case 'retry':\n                _delayedConnect();\n                _increaseBackoff();\n                break;\n            case 'handshake':\n                // The current transport may be failed (e.g. network disconnection)\n                // Reset the transports so the new handshake picks up the right one\n                _transports.reset(true);\n                _resetBackoff();\n                _delayedHandshake();\n                break;\n            case 'none':\n                _disconnect(true);\n                break;\n            default:\n                throw 'Unrecognized advice action' + action;\n        }\n    }\n\n    function _connectResponse(message) {\n        _connected = message.successful;\n\n        if (_connected) {\n            _notifyListeners('/meta/connect', message);\n\n            // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n            // and the server will hold the request, so when a response returns\n            // we immediately call the server again (long polling)\n            // Listeners can call disconnect(), so check the state after they run\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    // Wait for the /meta/disconnect to arrive.\n                    _disconnect(false);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failConnect(message);\n        }\n    }\n\n    function _connectFailure(message) {\n        _connected = false;\n        _failConnect(message);\n    }\n\n    function _failDisconnect(message) {\n        _disconnect(true);\n        _handleCallback(message);\n        _notifyListeners('/meta/disconnect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _disconnectResponse(message) {\n        if (message.successful) {\n            // Wait for the /meta/connect to arrive.\n            _disconnect(false);\n            _handleCallback(message);\n            _notifyListeners('/meta/disconnect', message);\n        } else {\n            _failDisconnect(message);\n        }\n    }\n\n    function _disconnectFailure(message) {\n        _failDisconnect(message);\n    }\n\n    function _failSubscribe(message) {\n        var subscriptions = _listeners[message.subscription];\n        if (subscriptions) {\n            for (var i = subscriptions.length - 1; i >= 0; --i) {\n                var subscription = subscriptions[i];\n                if (subscription && !subscription.listener) {\n                    delete subscriptions[i];\n                    _cometd._debug('Removed failed subscription', subscription);\n                    break;\n                }\n            }\n        }\n        _handleCallback(message);\n        _notifyListeners('/meta/subscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _subscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/subscribe', message);\n        } else {\n            _failSubscribe(message);\n        }\n    }\n\n    function _subscribeFailure(message) {\n        _failSubscribe(message);\n    }\n\n    function _failUnsubscribe(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/unsubscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _unsubscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/unsubscribe', message);\n        } else {\n            _failUnsubscribe(message);\n        }\n    }\n\n    function _unsubscribeFailure(message) {\n        _failUnsubscribe(message);\n    }\n\n    function _failMessage(message) {\n        if (!_handleRemoteCall(message)) {\n            _handleCallback(message);\n            _notifyListeners('/meta/publish', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n    }\n\n    function _messageResponse(message) {\n        if (message.data !== undefined) {\n            if (!_handleRemoteCall(message)) {\n                _notifyListeners(message.channel, message);\n                if (_handshakeMessages > 0) {\n                    --_handshakeMessages;\n                    if (_handshakeMessages === 0) {\n                        _cometd._debug('Processed last handshake-delivered message');\n                        _delayedConnect(0);\n                    }\n                }\n            }\n        } else {\n            if (message.successful === undefined) {\n                _cometd._warn('Unknown Bayeux Message', message);\n            } else {\n                if (message.successful) {\n                    _handleCallback(message);\n                    _notifyListeners('/meta/publish', message);\n                } else {\n                    _failMessage(message);\n                }\n            }\n        }\n    }\n\n    function _messageFailure(failure) {\n        _failMessage(failure);\n    }\n\n    function _receive(message) {\n        _unconnectTime = 0;\n\n        message = _applyIncomingExtensions(message);\n        if (message === undefined || message === null) {\n            return;\n        }\n\n        _updateAdvice(message.advice);\n\n        var channel = message.channel;\n        switch (channel) {\n            case '/meta/handshake':\n                _handshakeResponse(message);\n                break;\n            case '/meta/connect':\n                _connectResponse(message);\n                break;\n            case '/meta/disconnect':\n                _disconnectResponse(message);\n                break;\n            case '/meta/subscribe':\n                _subscribeResponse(message);\n                break;\n            case '/meta/unsubscribe':\n                _unsubscribeResponse(message);\n                break;\n            default:\n                _messageResponse(message);\n                break;\n        }\n    }\n\n    /**\n     * Receives a message.\n     * This method is exposed as a public so that extensions may inject\n     * messages simulating that they had been received.\n     */\n    this.receive = _receive;\n\n    _handleMessages = function(rcvdMessages) {\n        _cometd._debug('Received', rcvdMessages);\n\n        for (var i = 0; i < rcvdMessages.length; ++i) {\n            var message = rcvdMessages[i];\n            _receive(message);\n        }\n    };\n\n    _handleFailure = function(conduit, messages, failure) {\n        _cometd._debug('handleFailure', conduit, messages, failure);\n\n        failure.transport = conduit;\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var failureMessage = {\n                id: message.id,\n                successful: false,\n                channel: message.channel,\n                failure: failure\n            };\n            failure.message = message;\n            switch (message.channel) {\n                case '/meta/handshake':\n                    _handshakeFailure(failureMessage);\n                    break;\n                case '/meta/connect':\n                    _connectFailure(failureMessage);\n                    break;\n                case '/meta/disconnect':\n                    _disconnectFailure(failureMessage);\n                    break;\n                case '/meta/subscribe':\n                    failureMessage.subscription = message.subscription;\n                    _subscribeFailure(failureMessage);\n                    break;\n                case '/meta/unsubscribe':\n                    failureMessage.subscription = message.subscription;\n                    _unsubscribeFailure(failureMessage);\n                    break;\n                default:\n                    _messageFailure(failureMessage);\n                    break;\n            }\n        }\n    };\n\n    function _hasSubscriptions(channel) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                if (subscriptions[i]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function _resolveScopedCallback(scope, callback) {\n        var delegate = {\n            scope: scope,\n            method: callback\n        };\n        if (_isFunction(scope)) {\n            delegate.scope = undefined;\n            delegate.method = scope;\n        } else {\n            if (_isString(callback)) {\n                if (!scope) {\n                    throw 'Invalid scope ' + scope;\n                }\n                delegate.method = scope[callback];\n                if (!_isFunction(delegate.method)) {\n                    throw 'Invalid callback ' + callback + ' for scope ' + scope;\n                }\n            } else if (!_isFunction(callback)) {\n                throw 'Invalid callback ' + callback;\n            }\n        }\n        return delegate;\n    }\n\n    function _addListener(channel, scope, callback, isListener) {\n        // The data structure is a map<channel, subscription[]>, where each subscription\n        // holds the callback to be called and its scope.\n\n        var delegate = _resolveScopedCallback(scope, callback);\n        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n        var subscription = {\n            channel: channel,\n            scope: delegate.scope,\n            callback: delegate.method,\n            listener: isListener\n        };\n\n        var subscriptions = _listeners[channel];\n        if (!subscriptions) {\n            subscriptions = [];\n            _listeners[channel] = subscriptions;\n        }\n\n        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.\n        // Note that if:\n        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');\n        // then:\n        // hc==3, a.join()=='a',,'c', a.length==3\n        subscription.id = subscriptions.push(subscription) - 1;\n\n        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n        // For backward compatibility: we used to return [channel, subscription.id]\n        subscription[0] = channel;\n        subscription[1] = subscription.id;\n\n        return subscription;\n    }\n\n    //\n    // PUBLIC API\n    //\n\n    /**\n     * Registers the given transport under the given transport type.\n     * The optional index parameter specifies the \"priority\" at which the\n     * transport is registered (where 0 is the max priority).\n     * If a transport with the same type is already registered, this function\n     * does nothing and returns false.\n     * @param type the transport type\n     * @param transport the transport object\n     * @param index the index at which this transport is to be registered\n     * @return true if the transport has been registered, false otherwise\n     * @see #unregisterTransport(type)\n     */\n    this.registerTransport = function(type, transport, index) {\n        var result = _transports.add(type, transport, index);\n        if (result) {\n            this._debug('Registered transport', type);\n\n            if (_isFunction(transport.registered)) {\n                transport.registered(type, this);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Unregisters the transport with the given transport type.\n     * @param type the transport type to unregister\n     * @return the transport that has been unregistered,\n     * or null if no transport was previously registered under the given transport type\n     */\n    this.unregisterTransport = function(type) {\n        var transport = _transports.remove(type);\n        if (transport !== null) {\n            this._debug('Unregistered transport', type);\n\n            if (_isFunction(transport.unregistered)) {\n                transport.unregistered();\n            }\n        }\n        return transport;\n    };\n\n    this.unregisterTransports = function() {\n        _transports.clear();\n    };\n\n    /**\n     * @return an array of all registered transport types\n     */\n    this.getTransportTypes = function() {\n        return _transports.getTransportTypes();\n    };\n\n    this.findTransport = function(name) {\n        return _transports.find(name);\n    };\n\n    /**\n     * @returns the TransportRegistry object\n     */\n    this.getTransportRegistry = function() {\n        return _transports;\n    };\n\n    /**\n     * Configures the initial Bayeux communication with the Bayeux server.\n     * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n     * of type string containing the URL of the Bayeux server.\n     * @param configuration the configuration object\n     */\n    this.configure = function(configuration) {\n        _configure.call(this, configuration);\n    };\n\n    /**\n     * Configures and establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param configuration the configuration object\n     * @param handshakeProps an object to be merged with the handshake message\n     * @see #configure(configuration)\n     * @see #handshake(handshakeProps)\n     */\n    this.init = function(configuration, handshakeProps) {\n        this.configure(configuration);\n        this.handshake(handshakeProps);\n    };\n\n    /**\n     * Establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param handshakeProps an object to be merged with the handshake message\n     * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n     */\n    this.handshake = function(handshakeProps, handshakeCallback) {\n        _setStatus('disconnected');\n        _reestablish = false;\n        _handshake(handshakeProps, handshakeCallback);\n    };\n\n    /**\n     * Disconnects from the Bayeux server.\n     * It is possible to suggest to attempt a synchronous disconnect, but this feature\n     * may only be available in certain transports (for example, long-polling may support\n     * it, callback-polling certainly does not).\n     * @param sync whether attempt to perform a synchronous disconnect\n     * @param disconnectProps an object to be merged with the disconnect message\n     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n     */\n    this.disconnect = function(sync, disconnectProps, disconnectCallback) {\n        if (_isDisconnected()) {\n            return;\n        }\n\n        if (typeof sync !== 'boolean') {\n            disconnectCallback = disconnectProps;\n            disconnectProps = sync;\n            sync = false;\n        }\n        if (_isFunction(disconnectProps)) {\n            disconnectCallback = disconnectProps;\n            disconnectProps = undefined;\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: '/meta/disconnect'\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, disconnectCallback);\n\n        _setStatus('disconnecting');\n        _send(sync === true, [message], false, 'disconnect');\n    };\n\n    /**\n     * Marks the start of a batch of application messages to be sent to the server\n     * in a single request, obtaining a single response containing (possibly) many\n     * application reply messages.\n     * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n     * If startBatch() is called multiple times, then an equal number of endBatch()\n     * calls must be made to close and send the batch of messages.\n     * @see #endBatch()\n     */\n    this.startBatch = function() {\n        _startBatch();\n    };\n\n    /**\n     * Marks the end of a batch of application messages to be sent to the server\n     * in a single request.\n     * @see #startBatch()\n     */\n    this.endBatch = function() {\n        _endBatch();\n    };\n\n    /**\n     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n     * and {@link #endBatch()} calls.\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n     */\n    this.batch = function(scope, callback) {\n        var delegate = _resolveScopedCallback(scope, callback);\n        this.startBatch();\n        try {\n            delegate.method.call(delegate.scope);\n            this.endBatch();\n        } catch (x) {\n            this._info('Exception during execution of batch', x);\n            this.endBatch();\n            throw x;\n        }\n    };\n\n    /**\n     * Adds a listener for bayeux messages, performing the given callback in the given scope\n     * when a message for the given channel arrives.\n     * @param channel the channel the listener is interested to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @returns the subscription handle to be passed to {@link #removeListener(object)}\n     * @see #removeListener(subscription)\n     */\n    this.addListener = function(channel, scope, callback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n\n        return _addListener(channel, scope, callback, true);\n    };\n\n    /**\n     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @see #addListener(channel, scope, callback)\n     */\n    this.removeListener = function(subscription) {\n        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n        if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n            throw 'Invalid argument: expected subscription, not ' + subscription;\n        }\n\n        _removeListener(subscription);\n    };\n\n    /**\n     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n     * {@link #subscribe(channel, scope, callback)}.\n     */\n    this.clearListeners = function() {\n        _listeners = {};\n    };\n\n    /**\n     * Subscribes to the given channel, performing the given callback in the given scope\n     * when a message for the channel arrives.\n     * @param channel the channel to subscribe to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @param subscribeProps an object to be merged with the subscribe message\n     * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n     * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n     */\n    this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        // Normalize arguments\n        if (_isFunction(scope)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = callback;\n            callback = scope;\n            scope = undefined;\n        }\n        if (_isFunction(subscribeProps)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = undefined;\n        }\n\n        // Only send the message to the server if this client has not yet subscribed to the channel\n        var send = !_hasSubscriptions(channel);\n\n        var subscription = _addListener(channel, scope, callback, false);\n\n        if (send) {\n            // Send the subscription message after the subscription registration to avoid\n            // races where the server would send a message to the subscribers, but here\n            // on the client the subscription has not been added yet to the data structures\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/subscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, subscribeCallback);\n\n            _queueSend(message);\n        }\n\n        return subscription;\n    };\n\n    /**\n     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @param unsubscribeProps an object to be merged with the unsubscribe message\n     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n     */\n    this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(unsubscribeProps)) {\n            unsubscribeCallback = unsubscribeProps;\n            unsubscribeProps = undefined;\n        }\n\n        // Remove the local listener before sending the message\n        // This ensures that if the server fails, this client does not get notifications\n        this.removeListener(subscription);\n\n        var channel = subscription.channel;\n        // Only send the message to the server if this client unsubscribes the last subscription\n        if (!_hasSubscriptions(channel)) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/unsubscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, unsubscribeCallback);\n\n            _queueSend(message);\n        }\n    };\n\n    this.resubscribe = function(subscription, subscribeProps) {\n        _removeSubscription(subscription);\n        if (subscription) {\n            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n        }\n        return undefined;\n    };\n\n    /**\n     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n     */\n    this.clearSubscriptions = function() {\n        _clearSubscriptions();\n    };\n\n    /**\n     * Publishes a message on the given channel, containing the given content.\n     * @param channel the channel to publish the message to\n     * @param content the content of the message\n     * @param publishProps an object to be merged with the publish message\n     * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n     */\n    this.publish = function(channel, content, publishProps, publishCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (/^\\/meta\\//.test(channel)) {\n            throw 'Illegal argument: cannot publish to meta channels';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            publishCallback = content;\n            content = publishProps = {};\n        } else if (_isFunction(publishProps)) {\n            publishCallback = publishProps;\n            publishProps = {};\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, publishCallback);\n\n        _queueSend(message);\n    };\n\n    this.remoteCall = function(target, content, timeout, callback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(target)) {\n            throw 'Illegal argument type: target must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            callback = content;\n            content = {};\n            timeout = _config.maxNetworkDelay;\n        } else if (_isFunction(timeout)) {\n            callback = timeout;\n            timeout = _config.maxNetworkDelay;\n        }\n\n        if (typeof timeout !== 'number') {\n            throw 'Illegal argument type: timeout must be a number';\n        }\n\n        if (!target.match(/^\\//)) {\n            target = '/' + target;\n        }\n        var channel = '/service' + target;\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n\n        var context = {\n            callback: callback\n        };\n        if (timeout > 0) {\n            context.timeout = Utils.setTimeout(_cometd, function() {\n                _cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');\n                _failMessage({\n                    id: bayeuxMessage.id,\n                    error: '406::timeout',\n                    successful: false,\n                    failure: {\n                        message : bayeuxMessage,\n                        reason: 'Remote Call Timeout'\n                    }\n                });\n            }, timeout);\n            _cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');\n        }\n        _remoteCalls[bayeuxMessage.id] = context;\n\n        _queueSend(bayeuxMessage);\n    };\n\n    /**\n     * Returns a string representing the status of the bayeux communication with the Bayeux server.\n     */\n    this.getStatus = function() {\n        return _status;\n    };\n\n    /**\n     * Returns whether this instance has been disconnected.\n     */\n    this.isDisconnected = _isDisconnected;\n\n    /**\n     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * Default value is 1 second, which means if there is a persistent failure the retries will happen\n     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n     * @param period the backoff period to set\n     * @see #getBackoffIncrement()\n     */\n    this.setBackoffIncrement = function(period) {\n        _config.backoffIncrement = period;\n    };\n\n    /**\n     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * @see #setBackoffIncrement(period)\n     */\n    this.getBackoffIncrement = function() {\n        return _config.backoffIncrement;\n    };\n\n    /**\n     * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n     */\n    this.getBackoffPeriod = function() {\n        return _backoff;\n    };\n\n    /**\n     * Increases the backoff period up to the maximum value configured.\n     * @returns the backoff period after increment\n     * @see getBackoffIncrement\n     */\n    this.increaseBackoffPeriod = function() {\n        return _increaseBackoff();\n    };\n\n    /**\n     * Resets the backoff period to zero.\n     */\n    this.resetBackoffPeriod = function() {\n        _resetBackoff();\n    };\n\n    /**\n     * Sets the log level for console logging.\n     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n     * less verbose to more verbose.\n     * @param level the log level string\n     */\n    this.setLogLevel = function(level) {\n        _config.logLevel = level;\n    };\n\n    /**\n     * Registers an extension whose callbacks are called for every incoming message\n     * (that comes from the server to this client implementation) and for every\n     * outgoing message (that originates from this client implementation for the\n     * server).\n     * The format of the extension object is the following:\n     * <pre>\n     * {\n     *     incoming: function(message) { ... },\n     *     outgoing: function(message) { ... }\n     * }\n     * </pre>\n     * Both properties are optional, but if they are present they will be called\n     * respectively for each incoming message and for each outgoing message.\n     * @param name the name of the extension\n     * @param extension the extension to register\n     * @return true if the extension was registered, false otherwise\n     * @see #unregisterExtension(name)\n     */\n    this.registerExtension = function(name, extension) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var existing = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var existingExtension = _extensions[i];\n            if (existingExtension.name === name) {\n                existing = true;\n                break;\n            }\n        }\n        if (!existing) {\n            _extensions.push({\n                name: name,\n                extension: extension\n            });\n            this._debug('Registered extension', name);\n\n            // Callback for extensions\n            if (_isFunction(extension.registered)) {\n                extension.registered(name, this);\n            }\n\n            return true;\n        } else {\n            this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n            return false;\n        }\n    };\n\n    /**\n     * Unregister an extension previously registered with\n     * {@link #registerExtension(name, extension)}.\n     * @param name the name of the extension to unregister.\n     * @return true if the extension was unregistered, false otherwise\n     */\n    this.unregisterExtension = function(name) {\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var unregistered = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                _extensions.splice(i, 1);\n                unregistered = true;\n                this._debug('Unregistered extension', name);\n\n                // Callback for extensions\n                var ext = extension.extension;\n                if (_isFunction(ext.unregistered)) {\n                    ext.unregistered();\n                }\n\n                break;\n            }\n        }\n        return unregistered;\n    };\n\n    /**\n     * Find the extension registered with the given name.\n     * @param name the name of the extension to find\n     * @return the extension found or null if no extension with the given name has been registered\n     */\n    this.getExtension = function(name) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                return extension.extension;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns the name assigned to this CometD object, or the string 'default'\n     * if no name has been explicitly passed as parameter to the constructor.\n     */\n    this.getName = function() {\n        return _name;\n    };\n\n    /**\n     * Returns the clientId assigned by the Bayeux server during handshake.\n     */\n    this.getClientId = function() {\n        return _clientId;\n    };\n\n    /**\n     * Returns the URL of the Bayeux server.\n     */\n    this.getURL = function() {\n        if (_transport) {\n            var url = _transport.getURL();\n            if (url) {\n                return url;\n            }\n            url = _config.urls[_transport.getType()];\n            if (url) {\n                return url;\n            }\n        }\n        return _config.url;\n    };\n\n    this.getTransport = function() {\n        return _transport;\n    };\n\n    this.getConfiguration = function() {\n        return this._mixin(true, {}, _config);\n    };\n\n    this.getAdvice = function() {\n        return this._mixin(true, {}, _advice);\n    };\n};\n","import { Service } from './core'\n/**\n * Data aggregation\n *\n * Provides data aggregation over time and across different items\n *  User devices push items data on developer-defined categories\n *  This service automatically aggregates the data\n * Raw data is not available for reading, only the generated aggregation result\n *\n * */\n/**\n * User API for item aggregation\n *\n * Users can push data and be notified of aggregated data.\n * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.\n * @access public\n * */\nexport class Aggreg extends Service {\n\t/**\n\t * Get default deployment id associated to Aggreg service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'aggreg_0'\n\t}\n\t/**\n\t * Pushes some data\n\t *\n\t * Pushes the given data.\n\t * All the items are processed according to the defined rules.\n\t * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.\n\t * */\n\tpush({items,owner}) { return this.$publish('push', {items,owner})}\n}\n/**\n * Data stacks\n *\n * Stacks are a per-user named persistent queue of data\n *  An administrator creates a stack service\n *  End-users can push data on an arbitrary number of their own arbitrary named stacks\n * */\n/**\n * Data stack user API\n *\n * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.\n * Stack names are arbitrary and do not need to be explicitly initialized.\n * @access public\n * */\nexport class Stack extends Service {\n\t/**\n\t * Get default deployment id associated to Stack service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'stack_0'\n\t}\n\t/**\n\t * Lists the listeners\n\t *\n\t * Returns the whole list of listeners for the given stack.\n\t * */\n\tgetListeners({stack,owner}) { return this.$publish('getListeners', {stack,owner})}\n\t/**\n\t * Lists content\n\t *\n\t * Returns a paginated list of contents for the given stack.\n\t * Content is sorted according to the statically configured order.\n\t * */\n\tlist({stack,owner,page}) { return this.$publish('list', {stack,owner,page})}\n\t/**\n\t * Empties a stack\n\t *\n\t * Removes all items from the given stack.\n\t * */\n\tpurge({stack,owner}) { return this.$publish('purge', {stack,owner})}\n\t/**\n\t * Pushes an item\n\t *\n\t * Pushes an item onto the given stack.\n\t * The stack does not need to be created.\n\t * */\n\tpush({stack,data,owner}) { return this.$publish('push', {stack,data,owner})}\n\t/**\n\t * Removes items\n\t *\n\t * Removes the item with the given guid from the given stack.\n\t * */\n\tremove({guids,stack,owner}) { return this.$publish('remove', {guids,stack,owner})}\n\t/**\n\t * Sets the listeners\n\t *\n\t * Sets the listeners for the given stack.\n\t * */\n\tsetListeners({listeners,stack,owner}) { return this.$publish('setListeners', {listeners,stack,owner})}\n\t/**\n\t * Updates an item\n\t *\n\t * Updates an existing item of the given stack.\n\t * The item MUST exist prior to the call.\n\t * */\n\tupdate({guid,stack,data,owner}) { return this.$publish('update', {guid,stack,data,owner})}\n}\n/**\n * Echo\n *\n * Echo\n * */\n/**\n * Echo service\n *\n * Simple echo service, for development purposes.\n * @access public\n * */\nexport class Echo extends Service {\n\t/**\n\t * Get default deployment id associated to Echo service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'echo_0'\n\t}\n\t/**\n\t * Echoes an object\n\t *\n\t * Echoes an object: the server will echo that object on channel 'echo' for the current user.\n\t * */\n\techo(parameter) { return this.$publish('echo', parameter)}\n}\n/**\n * Game engine\n *\n * Abstract Game Engine\n *  Concrete game engines are remote cometd clients or internal macros\n * */\n/**\n * User API for games\n *\n * Users can list, start, join games, and play.\n * @access public\n * */\nexport class Game extends Service {\n\t/**\n\t * Get default deployment id associated to Game service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Lists game types\n\t *\n\t * Returns the list of game types supported by the server and the currently registered game engines.\n\t * */\n\tavailable() { return this.$publish('available', {})}\n\t/**A user joins a game*/\n\tjoin({role,gameId,userId,userName}) { return this.$publish('join', {role,gameId,userId,userName})}\n\t/**Organizes a game*/\n\torganize({type,owner,options}) { return this.$publish('organize', {type,owner,options})}\n\t/**Gives some command to the game engine*/\n\tplay({gameId,userId,data}) { return this.$publish('play', {gameId,userId,data})}\n\t/**Starts a game*/\n\tstart({gameId}) { return this.$publish('start', {gameId})}\n\t/**A user cancels joining a game*/\n\tunjoin({role,gameId,userId,userName}) { return this.$publish('unjoin', {role,gameId,userId,userName})}\n}\n/**\n * Game Engine API\n *\n * The Game Engine API is for game engine clients, not end-users.\n * @access public\n * */\nexport class GameEngine extends Service {\n\t/**\n\t * Get default deployment id associated to GameEngine service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Notify the result for a join request\n\t *\n\t * A Game Engine notifies the STR of the result of a join request that it received on join_callback\n\t * */\n\tjoin_result({msgId,payload,error,callerId}) { return this.$publish('join_result', {msgId,payload,error,callerId})}\n\t/**\n\t * Notify the result for an organization request\n\t *\n\t * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback\n\t * */\n\torganize_result({msgId,payload,error,callerId}) { return this.$publish('organize_result', {msgId,payload,error,callerId})}\n\t/**\n\t * Registers a game engine\n\t *\n\t * A client registers itself to the STR as a Game Engine.\n\t * The STR may, from now on, dispatch game of the given game type to said client.\n\t * Unregistration is done automatically on logoff.\n\t * */\n\tregister({maxGames,gameInfo,location}) { return this.$publish('register', {maxGames,gameInfo,location})}\n\t/**\n\t * Notify the result for a start request\n\t *\n\t * A Game Engine notifies the STR of the result of a start request that it received on start_callback\n\t * */\n\tstart_result({gameId}) { return this.$publish('start_result', {gameId})}\n\t/**\n\t * Notify a game event\n\t *\n\t * A Game Engine notifies the STR of some arbitrary game event.\n\t * */\n\tstate({status,gameId,data}) { return this.$publish('state', {status,gameId,data})}\n\t/**\n\t * Notify the result for an unjoin request\n\t *\n\t * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback\n\t * */\n\tunjoin_result({msgId,payload,error,callerId}) { return this.$publish('unjoin_result', {msgId,payload,error,callerId})}\n}\n/**\n * Generic Data Access\n *\n * Generic Data Access Service : NoSQL storage\n * */\n/**\n * GDA User API\n *\n * User API for Generic Data Access.\n * The data are stored on a per-user basis.\n * Users can put, get, list their data.\n * @access public\n * */\nexport class Gda extends Service {\n\t/**\n\t * Get default deployment id associated to Gda service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'gda_0'\n\t}\n\t/**\n\t * Asks for a data row\n\t *\n\t * Returns a full data row.\n\t * */\n\tget({table,key,owner}) { return this.$publish('get', {table,key,owner})}\n\t/**\n\t * Asks for a data cell\n\t *\n\t * Returns a precise list of cells from a column in a data row.\n\t * */\n\tgetCells({table,key,key2,owner,column}) { return this.$publish('getCells', {table,key,key2,owner,column})}\n\t/**\n\t * Increments an integer value\n\t *\n\t * Increments a cell 64-bit signed integer value and returns the result in the data field.\n\t * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.\n\t * */\n\tinc({table,data,key,key2,owner,column}) { return this.$publish('inc', {table,data,key,key2,owner,column})}\n\t/**\n\t * Asks for a list of rows\n\t *\n\t * Returns a paginated list of rows from the given table.\n\t * */\n\tlist({columns,table,owner,page}) { return this.$publish('list', {columns,table,owner,page})}\n\t/**\n\t * Puts some data into a cell\n\t *\n\t * Creates or replaces the contents of a particular cell.\n\t * */\n\tput({table,data,key,key2,owner,column}) { return this.$publish('put', {table,data,key,key2,owner,column})}\n\t/**\n\t * Puts several rows\n\t *\n\t * Creates or replaces the (maybe partial) contents of a collection of rows.\n\t * This method only creates or replaces cells for non-null input values.\n\t * */\n\tputs({rows,table,owner}) { return this.$publish('puts', {rows,table,owner})}\n\t/**\n\t * Asks for a range of rows\n\t *\n\t * Returns a paginated range of rows from the given table.\n\t * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n\t * You can specify partial keys for the start and stop fields.\n\t * */\n\trange({columns,start,table,stop,owner,page}) { return this.$publish('range', {columns,start,table,stop,owner,page})}\n\t/**\n\t * Removes one cell inside a column of a row\n\t *\n\t * Removes only one cell of the given column of the given row from the given table.\n\t * */\n\tremoveCell({table,key,key2,owner,column}) { return this.$publish('removeCell', {table,key,key2,owner,column})}\n\t/**\n\t * Removes one full column of a row\n\t *\n\t * Removes all cells of the given column of the given row from the given table.\n\t * */\n\tremoveColumn({table,key,owner,column}) { return this.$publish('removeColumn', {table,key,owner,column})}\n\t/**\n\t * Removes a range of rows\n\t *\n\t * Removes the specified columns of the given range of rows from the given table.\n\t * */\n\tremoveRange({columns,start,table,stop,owner}) { return this.$publish('removeRange', {columns,start,table,stop,owner})}\n\t/**\n\t * Removes one full row\n\t *\n\t * Removes all columns of the given row from the given table.\n\t * */\n\tremoveRow({table,key,owner}) { return this.$publish('removeRow', {table,key,owner})}\n}\n/**\n * Groups Management\n *\n * Groups management for users, grants on resources, remote commands on devices\n *  This is where you can configure rights for any resource\n *\n * */\n/**\n * User API for remote control\n *\n * @access public\n * */\nexport class Remoting extends Service {\n\t/**\n\t * Get default deployment id associated to Remoting service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds a listener\n\t *\n\t * A user requests notifications from a device owned by anyone who granted him the right authorizations.\n\t * Whenever the device calls 'notify', notifications will be sent to the caller of this verb.\n\t * */\n\taddListener({resource,fromResource,cmd,from,data,owner}) { return this.$publish('addListener', {resource,fromResource,cmd,from,data,owner})}\n\t/**Response to 'getCapabilities'*/\n\tcapabilities({askingResource,capabilities,answeringResource}) { return this.$publish('capabilities', {askingResource,capabilities,answeringResource})}\n\t/**\n\t * Executes a command\n\t *\n\t * A user executes a command on a device owned by anyone who granted him the right authorizations.\n\t * The command is issued on channel 'command'\n\t * */\n\texecute({resource,cmd,data,owner}) { return this.$publish('execute', {resource,cmd,data,owner})}\n\t/**\n\t * Requests capabilities\n\t *\n\t * A user requests all his devices for the whole list of their capabilities.\n\t * Devices are expected to answer on channel 'capabilities'\n\t * */\n\tgetCapabilities() { return this.$publish('getCapabilities', {})}\n\t/**\n\t * Notifies of some event\n\t *\n\t * A device notifies the registered users/devices on this channel.\n\t * The server forwards the notification to said users.\n\t * */\n\tnotify({resource,fromResource,cmd,from,data,owner}) { return this.$publish('notify', {resource,fromResource,cmd,from,data,owner})}\n\t/**\n\t * Pings devices\n\t *\n\t * A user requests all devices (of all owners) on which he has authorizations to respond on channel 'pong'\n\t * */\n\tping({action}) { return this.$publish('ping', {action})}\n\t/**Response to ping*/\n\tpong({user,resource,available,uid,owner,action}) { return this.$publish('pong', {user,resource,available,uid,owner,action})}\n\t/**\n\t * Removes a listener\n\t *\n\t * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations\n\t * */\n\tremoveListener({resource,fromResource,cmd,from,data,owner}) { return this.$publish('removeListener', {resource,fromResource,cmd,from,data,owner})}\n}\n/**\n * User API for groups and rights.\n *\n * Groups are stored per user.\n * This means that two users can own a group with the same identifier. A couple (owner, group) is needed to uniquely identify a group inside a group management service.\n * The triplet (deploymentId, owner, group) is actually needed to fully qualify a group outside of the scope of this service.\n * @access public\n * */\nexport class GroupManagement extends Service {\n\t/**\n\t * Get default deployment id associated to GroupManagement service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds me to a group\n\t *\n\t * Adds me (the caller) to a group.\n\t * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\taddMe({group,owner}) { return this.$publish('addMe', {group,owner})}\n\t/**\n\t * Adds a user to a group\n\t *\n\t * Adds the given user to the given group.\n\t * Addition may fail if the given group does not already exist.\n\t * */\n\taddUser({user,group,owner}) { return this.$publish('addUser', {user,group,owner})}\n\t/**Adds users to a group*/\n\taddUsers({users,group,owner}) { return this.$publish('addUsers', {users,group,owner})}\n\t/**\n\t * Lists my owned groups, with details\n\t *\n\t * Returns the whole list of groups owned by the current user, with their members\n\t * */\n\tallGroups({owner}) { return this.$publish('allGroups', {owner})}\n\t/**\n\t * Creates a group\n\t *\n\t * Creates a group owned by the current user.\n\t * Group creation may fail if the group already exists.\n\t * */\n\tcreateGroup({group,groupName,owner}) { return this.$publish('createGroup', {group,groupName,owner})}\n\t/**\n\t * Removes a group\n\t *\n\t * Removes the given group owned by the current user or the given owner.\n\t * Also removes all grants to that group.\n\t * */\n\tdelGroup({group,owner}) { return this.$publish('delGroup', {group,owner})}\n\t/**Removes a user from a group*/\n\tdelUser({user,group,owner}) { return this.$publish('delUser', {user,group,owner})}\n\t/**Removes users from a group*/\n\tdelUsers({users,group,groupName,owner}) { return this.$publish('delUsers', {users,group,groupName,owner})}\n\t/**\n\t * Tests for a group's existence\n\t *\n\t * Returns whether a group exists or not.\n\t * */\n\texists({group,owner}) { return this.$publish('exists', {group,owner})}\n\t/**\n\t * Grants a right to a group\n\t *\n\t * The granting API does not do any check when storing permissions.\n\t * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.\n\t * */\n\tgrant({resource,group,owner,action}) { return this.$publish('grant', {resource,group,owner,action})}\n\t/**\n\t * Lists the group users\n\t *\n\t * Returns the whole list of users configured inside the given group.\n\t * */\n\tgroupUsers({group,owner}) { return this.$publish('groupUsers', {group,owner})}\n\t/**\n\t * Lists my owned groups\n\t *\n\t * Returns the whole list of groups owned by the current user\n\t * */\n\tgroups({owner}) { return this.$publish('groups', {owner})}\n\t/**\n\t * Lists rights for a group\n\t *\n\t * This API lists explicitly configured rights.\n\t * Effective rights include configured rights, implicit rights and inherited rights.\n\t * */\n\tlistGrants({group,owner}) { return this.$publish('listGrants', {group,owner})}\n\t/**\n\t * Lists presences for a group\n\t *\n\t * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.\n\t * The current implementation does not include information about the particular devices users are connected with.\n\t * If a user is connected twice with two different devices, two identical entries will be returned.\n\t * */\n\tlistPresences({group,owner}) { return this.$publish('listPresences', {group,owner})}\n\t/**\n\t * Tests membership\n\t *\n\t * Tests whether I (the caller) am a member of the given group.\n\t * This verb exists so that users can determine if they are part of a group without being granted particular rights.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\tmemberOf({hardFail,group,owner}) { return this.$publish('memberOf', {hardFail,group,owner})}\n\t/**\n\t * Grants rights to a group\n\t *\n\t * Grant several rights at once.\n\t * */\n\tmgrant({resource,actions,group,owner}) { return this.$publish('mgrant', {resource,actions,group,owner})}\n\t/**Revokes rights for a group*/\n\tmrevoke({resource,actions,group,owner}) { return this.$publish('mrevoke', {resource,actions,group,owner})}\n\t/**\n\t * Lists the groups I am part of\n\t *\n\t * Returns the whole list of groups the current user is part of.\n\t * Groups may be owned by anyone, including the current user.\n\t * */\n\tmyGroups({owner}) { return this.$publish('myGroups', {owner})}\n\t/**Revokes a right for a group*/\n\trevoke({resource,group,owner,action}) { return this.$publish('revoke', {resource,group,owner,action})}\n}\n/**\n * HTTP client\n *\n * Web-service client\n *  An admin records URL templates that can be called by users\n *  Calls are not configurable by end-users\n *  However an admin may leverage the macro service to achieve URL, headers and body configurability\n * */\n/**\n * User API for http requests\n *\n * @access public\n * */\nexport class Httpclient extends Service {\n\t/**\n\t * Get default deployment id associated to Httpclient service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'httpclient_0'\n\t}\n\t/**\n\t * Makes a predefined request\n\t *\n\t * Lookups a predefined request by name, and executes it.\n\t * */\n\tcall({name,requestId}) { return this.$publish('call', {name,requestId})}\n}\n/**\n * Macros\n *\n * Macro-command service\n *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc\n *\n *\n *  End-users play them, with contextual parameters\n * */\n/**\n * User API for macro debugging\n *\n * Debugger API for macro.\n * These API verbs are not intended for use by most developers.\n * @access public\n * */\nexport class MacroDebug extends Service {\n\t/**\n\t * Get default deployment id associated to MacroDebug service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'macro_0'\n\t}\n\t/**Enables or disables a breakpoint*/\n\tbreakpoint({breakpoint,token,enabled}) { return this.$publish('breakpoint', {breakpoint,token,enabled})}\n\t/**Requests some information*/\n\tinfo({token,path,exp,requestId,frame}) { return this.$publish('info', {token,path,exp,requestId,frame})}\n\t/**\n\t * Debugs a previously recorded macro\n\t *\n\t * The given breakpoints will be honored, causing a suspension of the execution, resumable via 'resume'.\n\t * Only one debug session can be active at any given time.\n\t * */\n\tlivedebug({parameters,token,breakpoints,hardFail,name,requestId,debug}) { return this.$publish('livedebug', {parameters,token,breakpoints,hardFail,name,requestId,debug})}\n\t/**Resumes a paused macro*/\n\tresume({token,type}) { return this.$publish('resume', {token,type})}\n\t/**Sets a variable value*/\n\tvariable({token,name,frame,data}) { return this.$publish('variable', {token,name,frame,data})}\n}\n/**\n * User API for macro execution\n *\n * Simple errors are reported as usual.\n * However, the macro execution verbs treat most errors in a particular way : instead of reporting errors on the usual 'error' channel, errors are put in the returned 'MacroCompletion' result.\n * This behavior can be tuned on a per-call basis with the hardFail parameter.\n * Note that some particular errors will always behave as if hardFail were true, because they are related to programming errors, or prevent processing from ending gracefully : STACK_OVERFLOW, NO_SUCH_FUNCTION, RAM_EXCEEDED, CYCLES_EXCEEDED, TIME_EXCEEDED, QUOTA_EXCEEDED, RATE_EXCEEDED, BAD_COMPARATOR_VALUE\n * @access public\n * */\nexport class Macro extends Service {\n\t/**\n\t * Get default deployment id associated to Macro service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'macro_0'\n\t}\n\t/**\n\t * Plays a previously recorded macro\n\t *\n\t * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.\n\t * You can override the default notification channel when defining the macro.\n\t * */\n\tcall({parameters,hardFail,name,requestId,debug}) { return this.$publish('call', {parameters,hardFail,name,requestId,debug})}\n}\n/**\n * Mail sender\n *\n * Sends email through SMTP\n * */\n/**\n * Mail service user API\n *\n * This service is statically configured with an outgoing SMTP server.\n * Users call the API here to actually send emails.\n * @access public\n * */\nexport class Sendmail extends Service {\n\t/**\n\t * Get default deployment id associated to Sendmail service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sendmail_0'\n\t}\n}\n/**\n * Messaging service\n *\n * Messaging service\n * */\n/**\n * Messaging service\n *\n * Simple and flexible user-to-user or user-to-group messaging service.\n * @access public\n * */\nexport class Messaging extends Service {\n\t/**\n\t * Get default deployment id associated to Messaging service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'messaging_0'\n\t}\n\t/**\n\t * Sends a message to a target\n\t *\n\t * Sends the given message to the specified target on the given (optional) channel.\n\t * The administratively given default channel name is used when none is provided in the message itself.\n\t * */\n\tsend({target,channel,data}) { return this.$publish('send', {target,channel,data})}\n}\n/**\n * Producer consumer\n *\n * Producer consumer service\n *  Users can submit tasks and other users consume them\n * */\n/**\n * Producer / consumer real-time API\n *\n * Task producers submits their tasks.\n * The server dispatches the tasks.\n * Consumers process them and report completion back to the server.\n * Tasks are global to the service (i.e. NOT per user).\n * @access public\n * */\nexport class Queue extends Service {\n\t/**\n\t * Get default deployment id associated to Queue service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'queue_0'\n\t}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be returned to the caller.\n\t * When called from inside a macro, the comsumer generated result is available for further use.\n\t * */\n\tcall({description,originBusinessId,originDeploymentId,data,owner}) { return this.$publish('call', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Notifies completion of a task\n\t *\n\t * Consumer API.\n\t * The tasker notifies completion of the given task to the server.\n\t * The tasker can optionally include a result or an error code.\n\t * */\n\tdone({result,taskId,success}) { return this.$publish('done', {result,taskId,success})}\n\t/**\n\t * Registers a consumer\n\t *\n\t * Consumer API.\n\t * Registers the current user resource as an available task consumer.\n\t * Tasks will be then dispatched to that consumer.\n\t * */\n\tregister({capacity}) { return this.$publish('register', {capacity})}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).\n\t * This verb will return immediately : you can use this API to asynchronously submit a task.\n\t * */\n\tsubmit({description,originBusinessId,originDeploymentId,data,owner}) { return this.$publish('submit', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Unregisters a consumer\n\t *\n\t * Consumer API.\n\t * Unregisters the current user resource as an available task consumer.\n\t * All non finished tasks are returned to the server.\n\t * */\n\tunregister() { return this.$publish('unregister', {})}\n}\n/**\n * Push Notifications\n *\n * Native Push Notifications for Android, iOS\n *\n *\n *\n * */\n/**\n * Notification User API\n *\n * User API for notifications.\n * For notifications to work properly, it is imperative that the resource name of a device remain constant over time.\n * @access public\n * */\nexport class Notif extends Service {\n\t/**\n\t * Get default deployment id associated to Notif service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'notif_0'\n\t}\n}\n/**\n * RDBMS\n *\n * Relational Database : SQL storage\n * */\n/**\n * RDBMS User API\n *\n * User API for SQL queries.\n * Contrary to GDA or Stacks, the data are not stored on a per-user basis.\n * Users can store, get, list their data.\n * @access public\n * */\nexport class Rdbms extends Service {\n\t/**\n\t * Get default deployment id associated to Rdbms service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'rdbms_0'\n\t}\n}\n/**\n * SMS via OVH\n *\n * SMS sender, to send text messages to mobile phones\n * This SMS sending service uses the OVH API\n *\n * */\n/**\n * SMS service\n *\n * User API for SMS.\n * @access public\n * */\nexport class Sms_ovh extends Service {\n\t/**\n\t * Get default deployment id associated to Sms_ovh service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sms_ovh_0'\n\t}\n}\n/**\n * Scheduler\n *\n * Scheduler service\n *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)\n * */\n/**\n * User API for the Scheduler\n *\n * User endpoints for scheduling : users can schedule, list and delete tasks.\n * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.\n * Tasks are run on the server and thus can call api verbs marked as server-only.\n * @access public\n * */\nexport class Cron extends Service {\n\t/**\n\t * Get default deployment id associated to Cron service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'cron_0'\n\t}\n\t/**\n\t * List the configured tasks\n\t *\n\t * Returns a paginated list of the asking user's tasks.\n\t * */\n\tlist({start,stop,owner,page}) { return this.$publish('list', {start,stop,owner,page})}\n}\n/**\n * Search engine\n *\n * ElasticSearch engine, to index and search data\n *  An admin creates indices\n *  Users index and search documents\n *\n * */\n/**\n * ElasticSearch Service\n *\n * This API is a very thin wrapper around ElasticSearch's API.\n * @access public\n * */\nexport class Search extends Service {\n\t/**\n\t * Get default deployment id associated to Search service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'search_0'\n\t}\n\t/**\n\t * Deletes data\n\t *\n\t * Deletes a document from the elasticsearch engine by id.\n\t * */\n\tdelete({type,id,index}) { return this.$publish('delete', {type,id,index})}\n\t/**\n\t * Gets data\n\t *\n\t * Retrieves a document from the elasticsearch engine by id.\n\t * */\n\tget({type,id,index}) { return this.$publish('get', {type,id,index})}\n\t/**\n\t * Indexes data\n\t *\n\t * Inserts or updates a document into the elasticsearch engine.\n\t * */\n\tindex({type,id,index,data}) { return this.$publish('index', {type,id,index,data})}\n\t/**Searches for data*/\n\tsearch({indices,query,sort,page,types}) { return this.$publish('search', {indices,query,sort,page,types})}\n}\n/**\n * Template engine\n *\n * Template engine to produce documents from parameterized templates\n * <br>An admin creates templates\n * <br> Users produce documents\n * <br>The implementation uses the <a href='http://freemarker\n * org/'>freemarker</a> engine\n *\n * */\n/**\n * User API for templates\n *\n * Users use this API to evaluate pre-configured templates.\n * @access public\n * */\nexport class Template extends Service {\n\t/**\n\t * Get default deployment id associated to Template service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'template_0'\n\t}\n\t/**\n\t * Evaluates a template\n\t *\n\t * Evaluates the given template and returns the result as a string.\n\t * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.\n\t * */\n\tevaluate({languageTag,name,requestId,data}) { return this.$publish('evaluate', {languageTag,name,requestId,data})}\n}\n/**\n * Triggers\n *\n * Register callbacks for events and trigger them when needed\n *\n * */\n/**\n * Trigger service\n *\n * Register listeners and trigger events.\n * @access public\n * */\nexport class Trigger extends Service {\n\t/**\n\t * Get default deployment id associated to Trigger service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'trigger_0'\n\t}\n}\n/**\n * Upload: S3\n *\n * Upload service with S3 storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3 extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3 service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * Upload: local\n *\n * Upload service with local HDFS storage\n * */\n/**\n * User API for local file management\n *\n * User API for file content manipulation\n * @access public\n * */\nexport class Zpfs_hdfs extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_hdfs service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_hdfs_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * Upload: pseudo-S3\n *\n * Upload service with pseudo-S3compatible storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3compat extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3compat service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3compat_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * User directory service\n *\n * User directory service\n * */\n/**\n * User API for user information\n *\n * @access public\n * */\nexport class Userdir extends Service {\n\t/**\n\t * Get default deployment id associated to Userdir service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'userdir_0'\n\t}\n\t/**Searches for users matching the request*/\n\tsearch({requestId,query,page}) { return this.$publish('search', {requestId,query,page})}\n\t/**Requests public data for the specified users*/\n\tuserInfo({userKeys}) { return this.$publish('userInfo', {userKeys})}\n}\n","/**\n * Match unsecure pattern web\n * @type {RegExp}\n */\nconst HTTP_PATTERN = /^http:\\/\\/|^\\/\\//\n\n/**\n * Http protocol\n * @type {string}\n */\nconst HTTP_PROTOCOL = 'http:'\n\n/**\n * Https protocol\n * @type {string}\n */\nconst HTTPS_PROTOCOL = 'https:'\n\n/**\n * Alpha numeric dictionary\n */\nconst DICTIONARY = 'abcdefghijklmnopqrstuvwxyz0123456789'\n\n/**\n * Default ZetaPush API URL\n * @access private\n */\nexport const API_URL = 'https://api.zpush.io/'\n\n/**\n * Force ssl based protocol for network echange\n * Cross Env (Browser/Node) test\n * @access private\n * @type boolean\n */\nexport const FORCE_HTTPS = typeof location === 'undefined' ? false : location.protocol === HTTPS_PROTOCOL\n\n/**\n * @access private\n * @param {string} apiUrl\n * @return {string}\n */\nconst normalizeApiUrl = (apiUrl) => {\n  const last = apiUrl.charAt(apiUrl.length - 1)\n  const SLASH = '/'\n  return last === SLASH ? apiUrl : apiUrl + SLASH\n}\n\n/**\n * @access private\n * @param {Array<Object>} list\n * @return {Object}\n */\nexport const shuffle = (list) => {\n  const index = Math.floor(Math.random() * list.length)\n  return list[index]\n}\n\n/**\n * @access private\n * @param {string} url\n * @param {boolean} forceHttps\n * @return {string}\n */\nexport const getSecureUrl = (url, forceHttps) => {\n  return forceHttps ? url.replace(HTTP_PATTERN, `${HTTPS_PROTOCOL}//`) : url\n}\n\n/**\n * @access private\n * @param {{apiUrl: string, sandboxId: string, forceHttps: boolean, transports: Transports}} parameters\n * @return {Promise}\n */\nexport const getServers = ({ apiUrl, sandboxId, forceHttps, transports }) => {\n  const normalizedSecuresApiUrl = normalizeApiUrl(getSecureUrl(apiUrl, forceHttps))\n  const url = `${normalizedSecuresApiUrl}${sandboxId}`\n  const options = { protocol: forceHttps ? HTTPS_PROTOCOL : HTTP_PROTOCOL }\n  return transports.fetch(url, options)\n    .then((response) => response.json())\n    // TODO: Replace by a server side implementation when available\n    .then(({ servers }) => servers.map((server) => getSecureUrl(server, forceHttps)))\n}\n\n/**\n * @access private\n * @param Class Derived\n * @param Class Parent\n * @return {boolean}\n */\nexport const isDerivedOf = (Derived, Parent) => {\n  let prototype = Object.getPrototypeOf(Derived)\n  let is = false\n  while (!(is || prototype === null)) {\n    is = prototype === Parent\n    prototype = Object.getPrototypeOf(prototype)\n  }\n  return is\n}\n\n/**\n * Get random id\n * @return {string}\n */\nexport const uuid = (entropy = 7, dictionary = DICTIONARY) => Array.from(Array(entropy)).reduce((previous) => {\n  const next = dictionary.charAt(Math.floor(Math.random() * dictionary.length))\n  return `${previous}${next}`\n}, '')\n","import { CometD, Transports } from 'zetapush-cometd'\nimport { ConnectionStatusListener } from '../connection/connection-status'\nimport { Macro } from '../mapping/services'\nimport { getServers, isDerivedOf, shuffle, uuid } from '../utils/index'\n\n/**\n * CometD Messages enumeration\n * @type {Object}\n */\nconst Message = {\n  RECONNECT_HANDSHAKE_VALUE: 'handshake',\n  RECONNECT_NONE_VALUE: 'none',\n  RECONNECT_RETRY_VALUE: 'retry'\n}\n\n/**\n * Delay to update server url\n * @type {integer}\n */\nconst UPDATE_SERVER_URL_DELAY = 250\n\n/**\n * Default macro channel\n * @type {string}\n */\nconst DEFAULT_MACRO_CHANNEL = 'completed'\n\n/**\n * Provide utilities and abstraction on CometD Transport layer\n * @access private\n */\nexport class ClientHelper {\n  /**\n   * Create a new ZetaPush client helper\n   */\n  constructor({ apiUrl, sandboxId, forceHttps = false, authentication, resource = null, transports = Transports }) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access private\n     * @type {function():AbstractHandshake}\n     */\n    this.authentication = authentication\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.resource = resource\n    /**\n     * @access private\n     * @type {number}\n     */\n    this.requestId = 0\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.userId = null\n    /**\n     * @access private\n     * @type {Object}\n     */\n    this.userInfo = null\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.uniqId = uuid()\n    /**\n     * @access private\n     * @type {Promise}\n     */\n    this.servers = getServers({ apiUrl, sandboxId, forceHttps, transports }).catch((error) => {\n      // Notify error in connection to server step\n      this.connectionToServerFail(error)\n      // Return empty list\n      return []\n    })\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.connectionListeners = []\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.connected = false\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.wasConnected = false\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.serverUrl = null\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sessionId = null\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.subscribeQueue = []\n    /**\n     * @access private\n     * @type {CometD}\n     */\n    this.cometd = new CometD()\n\n    // Register transports layers\n    transports.ALL.forEach(({ type, Transport }) => {\n      this.cometd.registerTransport(type, new Transport())\n    })\n\n    // Handle transport exception\n    this.cometd.onTransportException = (cometd, transport) => {\n      // Try to find an other available server\n      // Remove the current one from the _serverList array\n      this.updateServerUrl()\n    }\n\n    this.cometd.addListener('/meta/handshake', ({ ext, successful, advice, error }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      if (successful) {\n        const { authentication = null } = ext\n        this.initialized(authentication)\n      } else {\n        this.handshakeFailure(error)\n      }\n    })\n\n    this.cometd.addListener('/meta/handshake', ({ advice, error, ext, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      // AuthNegotiation\n      if (!successful) {\n        if (typeof advice === 'undefined') {\n          return\n        }\n        if (Message.RECONNECT_NONE_VALUE === advice.reconnect) {\n          this.authenticationFailed(error)\n        } else if (Message.RECONNECT_HANDSHAKE_VALUE === advice.reconnect) {\n          this.negotiationFailed(error)\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/connect', ({ advice, channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/connect', { advice, channel, successful })\n      // ConnectionListener\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection will close\n        this.connectionWillClose()\n      } else {\n        this.wasConnected = this.connected\n        this.connected = successful\n        if (!this.wasConnected && this.connected) {\n          this.cometd.batch(this, () => {\n            // Unqueue subscriptions\n            this.subscribeQueue.forEach(({ prefix, listener, subscriptions }) => {\n              this.subscribe(prefix, listener, subscriptions)\n            })\n          })\n          // Notify connection is established\n          this.connectionEstablished()\n        } else if (this.wasConnected && !this.connected) {\n          // Notify connection is broken\n          this.connectionBroken()\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/disconnect', ({ channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/disconnect', { channel, successful })\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection is closed\n        this.connectionClosed()\n      }\n    })\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    this.connectionListeners.push({\n      enabled: true,\n      listener: Object.assign(new ConnectionStatusListener(), listener)\n    })\n    return this.connectionListeners.length - 1\n  }\n  /**\n   * Notify listeners when handshake step succeed\n   */\n  authenticationFailed(error) {\n    this.userId = null\n    this.userInfo = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onFailedHandshake(error)\n      })\n  }\n  /**\n   * Connect client using CometD Transport\n   */\n  connect() {\n    this.servers.then((servers) => {\n      if (servers.length > 0) {\n        // Get a random server url\n        this.serverUrl = shuffle(servers)\n        // Configure CometD\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`,\n          backoffIncrement: 1000,\n          maxBackoff: 60000,\n          appendMessageTypeToURL: false\n        })\n        // Send handshake fields\n        this.cometd.handshake(this.getHandshakeFields())\n      } else {\n        // No servers available\n        this.noServerUrlAvailable()\n      }\n    })\n  }\n  /**\n   * Notify listeners when connection is broken\n   */\n  connectionBroken() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionBroken()\n      })\n  }\n  /**\n   * Notify listeners when connection is closed\n   */\n  connectionClosed() {\n    this.userId = null\n    this.userInfo = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionClosed()\n      })\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  connectionEstablished() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionEstablished()\n      })\n  }\n  /**\n   * Notify listeners when connection to server fail\n   */\n  connectionToServerFail(failure) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionToServerFail(failure)\n      })\n  }\n  /**\n   * Notify listeners when connection will close\n   */\n  connectionWillClose() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionWillClose()\n      })\n  }\n  /**\n   * Create a promise based macro service\n   * @experimental\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createAsyncMacroService({ listener, Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`\n    const $publish = this.getAsyncMacroPublisher(prefix)\n    // Create service by publisher\n    return this.createServiceByPublisher({ listener, prefix, Type, $publish })\n  }\n  /**\n   * Create a publish/subscribe service\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createService({ listener, Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const isMacroType = isDerivedOf(Type, Macro)\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`\n    const $publish = isMacroType ? this.getMacroPublisher(prefix) : this.getServicePublisher(prefix)\n    // Create service by publisher\n    return this.createServiceByPublisher({ listener, prefix, Type, $publish })\n  }\n  /**\n   * @param {{listener: Object, prefix: string, Type: class, $publish: Function}} parameters\n   * @return {Object} service\n   */\n  createServiceByPublisher({ listener, prefix, Type, $publish }) {\n    const service = new Type({ $publish })\n    // Store subscription in service instance\n    service.$subscriptions = this.subscribe(prefix, listener)\n    return service\n  }\n  /**\n   * Disconnect CometD client\n   */\n  disconnect() {\n    this.cometd.disconnect(true)\n  }\n  /**\n   * Get a publisher for a macro service that return a promise\n   * @experimental\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getAsyncMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`\n      const uniqRequestId = this.getUniqRequestId()\n      const subscriptions = {}\n      return new Promise((resolve, reject) => {\n        const handler = ({ data = {} }) => {\n          const { result = {}, errors = [], requestId } = data\n          if (requestId === uniqRequestId) {\n            // Handle errors\n            if (errors.length > 0) {\n              reject(errors)\n            } else {\n              resolve(result)\n            }\n            this.unsubscribe(subscriptions)\n          }\n        }\n        // Create dynamic listener method\n        const listener = {\n          [name]: handler,\n          [DEFAULT_MACRO_CHANNEL]: handler\n        }\n        // Ad-Hoc subscription\n        this.subscribe(prefix, listener, subscriptions)\n        // Publish message on channel\n        this.publish(channel, {\n          debug,\n          hardFail,\n          name,\n          parameters,\n          requestId: uniqRequestId\n        })\n      })\n    }\n  }\n  /**\n   * Get client id\n   * @return {string} clientId\n   */\n  getClientId() {\n    return this.cometd.getClientId()\n  }\n  /**\n   * Get CometD handshake parameters\n   * @return {Object}\n   */\n  getHandshakeFields() {\n    const handshake = this.authentication()\n    return handshake.getHandshakeFields(this)\n  }\n  /**\n   * Get a publisher for a macro service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`\n      const requestId = this.getUniqRequestId()\n      return this.publish(channel, {\n        debug,\n        hardFail,\n        name,\n        parameters,\n        requestId\n      })\n    }\n  }\n  /**\n   * Get queued subscription index\n   * @return {Object} index\n   */\n  getQueuedSubscription(subscriptions = {}) {\n    const index = this.subscribeQueue.findIndex((element) => subscriptions === element.subscriptions)\n    return {\n      index,\n      queued: index > -1\n    }\n  }\n  /**\n   * Get resource\n   * @return {string}\n   */\n  getResource() {\n    return this.resource\n  }\n  /**\n   * Get sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.sandboxId\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.servers\n  }\n  /**\n   * Get a publisher for a service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getServicePublisher(prefix) {\n    return (method, parameters) => {\n      const channel = `${prefix}/${method}`\n      return this.publish(channel, parameters)\n    }\n  }\n  /**\n   * Get uniq request id\n   * @return {string}\n   */\n  getUniqRequestId() {\n    return `${this.getClientId()}:${this.uniqId}:${++this.requestId}`\n  }\n  /**\n   * Get user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.userId\n  }\n  /**\n   * Get user info\n   * @return {Objet}\n   */\n  getUserInfo() {\n    return this.userInfo\n  }\n  /**\n   * Manage handshake failure case\n   */\n  handshakeFailure() {\n    this.userId = null\n    this.userInfo = null\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  initialized(authentication) {\n    if (authentication) {\n      this.userId = authentication.userId\n      this.userInfo = authentication.userInfo\n    }\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onSuccessfulHandshake(authentication)\n      })\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return !this.cometd.isDisconnected()\n  }\n  /**\n   * Notify listeners when a message is lost\n   */\n  messageLost(channel, data) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onMessageLost(channel, data)\n      })\n  }\n  /**\n   * Negociate authentication\n   * @param {error} error\n   */\n  negotiationFailed(error) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onNegotiationFailed(error)\n      })\n  }\n  /**\n   * Notify listeners when no server url available\n   */\n  noServerUrlAvailable() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onNoServerUrlAvailable()\n      })\n  }\n  /**\n   * Wrap CometdD publish method\n   * @param {String} channel\n   * @param {Object} parameters\n   * @return {Object}\n   */\n  publish(channel, parameters = {}) {\n    this.cometd.publish(channel, parameters)\n    return { channel, parameters }\n  }\n  /**\n   * Remove a connection status listener\n   */\n  removeConnectionStatusListener(handler) {\n    const listener = this.connectionListeners[handler]\n    if (listener) {\n      listener.enabled = false\n    }\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.authentication = authentication\n  }\n  /**\n   * Set logging level for CometD client\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.cometd.setLogLevel(level)\n  }\n  /**\n   * Subsribe all methods defined in the listener for the given prefixed channel\n   * @param {string} prefix - Channel prefix\n   * @param {Object} listener\n   * @param {Object} subscriptions\n   * @return {Object} subscriptions\n   */\n  subscribe(prefix, listener = {}, subscriptions = {}) {\n    const { queued } = this.getQueuedSubscription(subscriptions)\n    if (!queued) {\n      // Store arguments to renew subscriptions on connection\n      this.subscribeQueue.push({ prefix, listener, subscriptions })\n    }\n    // Subscribe if user is connected\n    if (!this.cometd.isDisconnected()) {\n      for (let method in listener) {\n        if (listener.hasOwnProperty(method)) {\n          const channel = `${prefix}/${method}`\n          subscriptions[method] = this.cometd.subscribe(channel, listener[method])\n        }\n      }\n    }\n    return subscriptions\n  }\n  /**\n  * Remove current server url from the server list and shuffle for another one\n  */\n  updateServerUrl() {\n    this.servers.then((servers) => {\n      const index = servers.indexOf(this.serverUrl)\n      if (index > -1) {\n        servers.splice(index, 1)\n      }\n      if (servers.length === 0) {\n        // No more server available\n        this.noServerUrlAvailable()\n      } else {\n        this.serverUrl = shuffle(servers)\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`\n        })\n        setTimeout(() => {\n          this.cometd.handshake(this.getHandshakeFields())\n        }, UPDATE_SERVER_URL_DELAY)\n      }\n    })\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} subscriptions\n   */\n  unsubscribe(subscriptions = {}) {\n    // Unsubscribe\n    for (let method in subscriptions) {\n      if (subscriptions.hasOwnProperty(method)) {\n        const subscription = subscriptions[method]\n        this.cometd.unsubscribe(subscription)\n      }\n    }\n    // Remove subscription from queue\n    const { index, queued } = this.getQueuedSubscription(subscriptions)\n    if (queued) {\n      this.subscribeQueue.splice(index, 1)\n    }\n  }\n}\n","import { ClientHelper } from './helper'\nimport { API_URL, FORCE_HTTPS } from '../utils/index'\nimport { ConnectionStatusListener } from '../connection/connection-status'\n\n/**\n * Client config object.\n * @typedef {Object} ClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {function():AbstractHandshake} authentication - Return authentication properties\n * @property {string} resource - Client resource id\n * @property {Transports} transports - Client transports implementation\n */\n\n/**\n * ZetaPush Client to connect\n * @access public\n * @example\n * // Securized client with token based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       token: null\n *    })\n *   }\n * })\n * @example\n * // Client with authentication based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * @example\n * // Explicit deploymentId\n * const clientSimple = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * const clientWeak = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n *       token: '<SESSION-TOKEN>'\n *    })\n *   }\n * })\n */\nexport class Client {\n  /**\n   * Create a new ZetaPush Client\n   * @param {ClientConfig} config\n   */\n  constructor({ apiUrl = API_URL, sandboxId, forceHttps = FORCE_HTTPS, authentication, resource, transports }) {\n    /**\n     * @access private\n     * @type {ClientHelper}\n     */\n    this.helper = new ClientHelper({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      authentication,\n      resource,\n      transports\n    })\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    return this.helper.addConnectionStatusListener(listener)\n  }\n  /**\n   * Safely connect client to ZetaPush\n   */\n  connect() {\n    if (this.isConnected()) {\n      const handler = this.addConnectionStatusListener({\n        onConnectionClosed: () => {\n          this.removeConnectionStatusListener(handler)\n          this.helper.connect()\n        }\n      })\n      this.disconnect()\n    } else {\n      this.helper.connect()\n    }\n  }\n  /**\n   * Create a promise based service instance\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const api = client.createAsyncMacroService({\n   *   Type: WelcomeMacro\n   * })\n   * api.welcome({\n   *   message: Hello'\n   * }).then(({ message }) => {\n   *   console.log(message)\n   * })\n   */\n  createAsyncMacroService({ deploymentId, listener, Type }) {\n    return this.helper.createAsyncMacroService({ deploymentId, listener, Type })\n  }\n  /**\n   * Create a publish/subscribe for a service type\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const service = client.createService({\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * const service = client.createService({\n   *   deploymentId: 'stack_0'\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   */\n  createService({ deploymentId, listener, Type }) {\n    return this.helper.createService({ deploymentId, listener, Type })\n  }\n  /**\n   * Disonnect client from ZetaPush\n   */\n  disconnect() {\n    if (this.isConnected()) {\n      this.helper.disconnect()\n    }\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return this.helper.isConnected()\n  }\n  /**\n   * Get the client sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.helper.getSandboxId()\n  }\n  /**\n   * Get the client resource\n   * @return {string}\n   */\n  getResource() {\n    return this.helper.getResource()\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.helper.getServers()\n  }\n  /**\n   * Get the client user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.helper.getUserId()\n  }\n  /*\n   * Get the client user info\n   * @return {Object}\n   * @example\n   * // Create new ZetaPush Client\n   * const client = new Client({\n   *   sandboxId: '<YOUR-SANDBOX-ID>',\n   *   authentication: () => Authentication.simple({\n   *     login: '<YOUR-USER-LOGIN>',\n   *     password: '<YOUR-USER-PASSWORD>'\n   *   })\n   * })\n   * // Add connection establised listener\n   * client.onConnectionEstablished(() => {\n   *   console.log('onConnectionEstablished')\n   *   const profile = client.getUserInfo()\n   *   console.log('Your profile', profile)\n   * })\n   * client.connect()\n   */\n  getUserInfo() {\n    return this.helper.getUserInfo()\n  }\n  /**\n   * Remove a connection status listener\n   * @param {number} handler\n   */\n  removeConnectionStatusListener(handler) {\n    return this.helper.removeConnectionStatusListener(handler)\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.helper.setAuthentication(authentication)\n  }\n  /**\n   * Set logging level\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.helper.setLogLevel(level)\n  }\n  /**\n   * Set new client resource value\n   * @param {string} resource\n   */\n  setResource(resource) {\n    this.helper.setResource(resource)\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} service\n   */\n  unsubscribe(service) {\n    if (!service.$subscriptions) {\n      throw new TypeError('Missing $subscriptions property in service')\n    }\n    return this.helper.unsubscribe(service.$subscriptions)\n  }\n}\n\n/**\n * Add shorthand connection status method\n */\nObject.getOwnPropertyNames(ConnectionStatusListener.prototype).forEach((method) => {\n  // Only implements unsupported methods\n  if (!Client.prototype.hasOwnProperty(method)) {\n    Client.prototype[method] = function addListener(listener) {\n      return this.addConnectionStatusListener({\n        [method]: listener\n      })\n    }\n  }\n})\n","/**\n * Provide fallback for DOMStorage\n * @access protected\n */\nclass MemoryStorage {\n  constructor() {\n    this._map = new Map()\n  }\n  getItem(key) {\n    return this._map.get(key)\n  }\n  setItem(key, value) {\n    return this._map.get(key)\n  }\n  removeItem(key) {\n    this._map.delete(key)\n  }\n  clear() {\n    this._map = new Map()\n  }\n  key(n) {\n    return Array.from(this._map.keys())[n]\n  }\n  get length() {\n    return this._map.size\n  }\n}\n\n/**\n * @type {Storage}\n * @access protected\n */\nexport const platformStorage = typeof localStorage === 'undefined' ? new MemoryStorage() : localStorage\n","import { platformStorage } from './storage'\n\n/**\n * @type {string}\n */\nexport const ZETAPUSH_SESSION_KEY = 'zetapush.token'\n\n/**\n * Provide abstraction for token persistence\n * @access protected\n */\nexport class SessionPersistenceStrategy {\n  /**\n   * @param {{sandboxId: string, storage: DOMStorage}} parameters\n   */\n  constructor({ sandboxId, storage = platformStorage } = {}) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.key = `${ZETAPUSH_SESSION_KEY}.${sandboxId}`\n    /**\n     * @access private\n     * @type {DOMStorage}\n     */\n    this.storage = storage\n  }\n  /**\n   * @return {string} session The stored session\n   */\n  get() {\n    const { key, storage } = this\n    const json = storage.getItem(key) || '{}'\n    let session = {}\n    try {\n      session = JSON.parse(json)\n    } catch (e) { }\n    return session\n  }\n  /**\n   * @param {Object} session The session to store\n   */\n  set(session = {}) {\n    const { key, storage } = this\n    const json = JSON.stringify(session)\n    try {\n      storage.setItem(key, json)\n    } catch (e) { }\n    return session\n  }\n}\n","import { Client } from './basic'\nimport { Authentication } from '../authentication/handshake'\nimport { SessionPersistenceStrategy } from '../utils/session-persistence'\n\n/**\n * SmartClient config object.\n * @typedef {Object} SmartClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.SmartClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class SmartClient extends Client {\n  /**\n   * Create a new ZetaPush SmartClient\n   * @param {SmartClientConfig} config\n   */\n  constructor({ apiUrl, sandboxId, forceHttps, resource, transports }) {\n    const persistence = new SessionPersistenceStrategy({ sandboxId })\n\n    /**\n     * @return {AbstractHandshakeManager}\n     */\n    const authentication = () => {\n      const session = persistence.get()\n      const { token } = session\n\n      if (this.hasCredentials()) {\n        const { login, password } = this.getCredentials()\n        this.setCredentials({})\n        return Authentication.simple({\n          login,\n          password\n        })\n      } else {\n        if (this.isStronglyAuthenticated(session)) {\n          return Authentication.simple({\n            login: token,\n            password: null\n          })\n        } else {\n          return Authentication.weak({\n            token\n          })\n        }\n      }\n    }\n    // Initialize base client\n    super({\n      apiUrl, sandboxId, authentication, forceHttps, resource, transports\n    })\n    /**\n     * @access protected\n     * @type {SessionPersistenceStrategy}\n     */\n    this.persistence = persistence\n    /**\n     * @access protected\n     * @type {Object}\n     */\n    this.credentials = {}\n    /**\n     * Handle connection lifecycle events\n     * @access protected\n     * @type {Object}\n     */\n    this.lifeCycleConnectionHandler = this.addConnectionStatusListener({\n      onConnectionClosed() {\n        persistence.set({})\n      },\n      onSuccessfulHandshake(session) {\n        if (session.token) {\n          persistence.set(session)\n        }\n      }\n    })\n    // Properly disconnect client to avoir ghost connections\n    /*\n    window.addEventListener('beforeunload', () => {\n      this.removeConnectionStatusListener(this.lifeCycleConnectionHandler)\n      super.disconnect()\n    })\n    */\n  }\n  /**\n   * Disconnect client from ZetaPush backend\n   */\n  disconnect() {\n    super.disconnect()\n  }\n  /**\n   * @return {Object}\n   */\n  getCredentials() {\n    return this.credentials\n  }\n  /**\n   * @return {Object}\n   */\n  getSession() {\n    return this.persistence.get()\n  }\n  /**\n   * @return {boolean}\n   */\n  hasCredentials() {\n    const { login, password } = this.getCredentials()\n    return login && password\n  }\n  /**\n   * @return {boolean}\n   */\n  isStronglyAuthenticated(session = this.persistence.get()) {\n    return !this.isWeaklyAuthenticated(session) && typeof session.token === 'string'\n  }\n  /**\n   * @return {boolean}\n   */\n  isWeaklyAuthenticated(session = this.persistence.get()) {\n    return typeof session.publicToken === 'string'\n  }\n  /**\n   * @param {{login: string, password: string}} parameters\n   */\n  setCredentials({ login, password }) {\n    this.credentials = { login, password }\n  }\n}\n","import { Client } from './basic'\nimport { Authentication } from '../authentication/handshake'\nimport { SessionPersistenceStrategy } from '../utils/session-persistence'\n\n/**\n * WeakClient config object.\n * @typedef {Object} WeakClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} deploymentId - Authentication deployment id, default value is 'weak_0'\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.WeakClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n * @example\n * // Explicit deploymentId\n * // WeakClient provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n * // deploymentId default value is weak_0\n * const client = new ZetaPush.WeakClient({\n *   deploymentId: 'weak_0',\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class WeakClient extends Client {\n  /**\n   * Create a new ZetaPush WeakClient\n   * @param {WeakClientConfig} config\n   */\n  constructor({ apiUrl, sandboxId, deploymentId, forceHttps, resource, transports }) {\n    const authentication = () => {\n      const token = this.getToken()\n      const handshake = Authentication.weak({\n        deploymentId,\n        token\n      })\n      return handshake\n    }\n    /**\n     * Call Client constructor with specific parameters\n     */\n    super({ apiUrl, sandboxId, forceHttps, authentication, resource, transports })\n    // Handle successful handshake\n    const onSuccessfulHandshake = ({ publicToken, userId, token }) => {\n      if (token) {\n        this.strategy.set({ publicToken, userId, token })\n      }\n    }\n    this.addConnectionStatusListener({ onSuccessfulHandshake })\n    /**\n     * @access private\n     * @type {SessionPersistenceStrategy}\n     */\n    this.strategy = new SessionPersistenceStrategy({ sandboxId })\n  }\n  /**\n   * @return {string} The stored token\n   */\n  getToken() {\n    const { token } = this.strategy.get()\n    return token\n  }\n}\n","export { Authentication } from './authentication/handshake'\nexport { ConnectionStatusListener } from './connection/connection-status'\n\nexport { Client } from './client/basic'\nexport { SmartClient } from './client/smart'\nexport { WeakClient } from './client/weak'\n\nexport { services } from './mapping'\n\n/**\n * SDK Version\n * @type {string}\n */\nexport const VERSION = '3.2.2'\n"],"names":["FetchLongPollingTransport","_super","LongPollingTransport","that","Transport","derive","xhrSend","packet","fetch","url","method","body","headers","Object","assign","Content-Type","then","response","json","onSuccess","catch","onError","WebSocketTransport","_forceClose","context","event","this","webSocketClose","code","reason","onClose","_sameContext","_connecting","_context","_storeEnvelope","envelope","metaConnect","messageIds","i","messages","length","message","id","push","envelopes","join","_debug","getType","_websocketConnect","_cometd","getURL","replace","protocol","getConfiguration","WebSocket","webSocket","x","_webSocketSupported","_stickyReconnect","stickyReconnect","self","connectTimeout","connectTimer","setTimeout","call","onclose","clearTimeout","onopen","_webSocketConnected","onOpen","_warn","onerror","onmessage","wsMessage","onMessage","_webSocketSend","JSON","stringify","send","maxDelay","maxNetworkDelay","delay","getAdvice","timeout","_connected","timeouts","_send","exception","_self","_successCallback","reset","init","_notifySuccess","fn","_notifyFailure","failure","key","hasOwnProperty","element","close","convertToMessages","data","test","channel","undefined","removed","j","ids","split","index","Utils","inArray","splice","websocketCode","onFailure","registered","type","cometd","accept","version","crossDomain","websocketEnabled","abort","Service","$publish","Delegating","Simple","Weak","publicToken","fullRights","AbstractHandshake","authType","sandboxId","deploymentId","client","authentication","authData","getSandboxId","authVersion","getResource","resource","TokenHandshake","token","CredentialsHandshake","login","password","Authentication","create","DeployableNames","DEFAULT_DEPLOYMENT_ID","ConnectionStatusListener","_types","_transports","getTransportTypes","slice","findTransportTypes","result","negotiateTransport","types","transport","add","existing","find","remove","clear","value","String","Array","array","funktion","timeoutHandle","_type","_url","unregistered","apply","arguments","_mixin","handle","isString","parse","isArray","setURL","toString","baseObject","F","prototype","_coalesceEnvelopes","_envelopes","envelopeAndRequest","newEnvelope","newRequest","sync","shift","concat","_transportSend","request","transportSend","expired","errorMessage","xhr","httpCode","xhrStatus","abortXHR","complete","_queueSend","requestId","_requestIds","_requests","maxConnections","_metaConnectComplete","_metaConnectRequest","_complete","success","nextEnvelope","nextRequest","autoBatch","_metaConnectSend","transportSuccess","responses","transportFailure","state","readyState","XMLHttpRequest","UNSENT","status","RequestTransport","_supportsCrossDomain","sameStack","requestHeaders","received","window","WEBSOCKET_TRANSPORT","TRANSPORT_TYPES","LONG_POLLING_TRANSPORT","name","_fieldValue","object","_isString","_isFunction","_zeroPad","Math","pow","_log","level","args","console","logger","now","Date","getHours","getMinutes","getSeconds","getMilliseconds","_splitURL","exec","_configure","configuration","_config","urlParts","uri","afterURI","_crossDomain","_isCrossDomain","appendMessageTypeToURL","_info","uriSegments","lastSegmentIndex","match","indexOf","_removeListener","subscription","subscriptions","_listeners","listener","_removeSubscription","_clearSubscriptions","_setStatus","newStatus","_status","_isDisconnected","_nextMessageId","_messageId","_applyExtension","scope","callback","outgoing","handler","onExtensionException","xx","_applyIncomingExtensions","_extensions","extension","reverseIncomingExtensions","incoming","_applyOutgoingExtensions","_notify","onListenerException","_notifyListeners","channelParts","last","channelPart","_cancelDelayedSend","_scheduledSend","_delayedSend","operation","_backoff","time","_advice","interval","extraPath","messageId","_clientId","clientId","_callbacks","rcvdMessages","_handleMessages","conduit","getTransport","connectionType","_handleFailure","_transport","_batch","_internalBatch","_messageQueue","_resetBackoff","_increaseBackoff","maxBackoff","backoffIncrement","_startBatch","_flushBatch","_endBatch","_connect","bayeuxMessage","advice","_delayedConnect","_updateAdvice","newAdvice","_disconnect","_notifyTransportFailure","oldTransport","newTransport","onTransportException","_handshake","handshakeProps","handshakeCallback","reconnect","_handshakeProps","_handshakeCallback","transportTypes","minimumVersion","supportedConnectionTypes","_putCallback","_delayedHandshake","_notifyCallback","onCallbackException","_handleCallback","_getCallback","_handleRemoteCall","_remoteCalls","_failHandshake","_handshakeResponse","successful","reestablish","_reestablish","action","_handshakeFailure","_failConnect","_connectResponse","_connectFailure","_failDisconnect","_disconnectResponse","_disconnectFailure","_failSubscribe","_subscribeResponse","_subscribeFailure","_failUnsubscribe","_unsubscribeResponse","_unsubscribeFailure","_failMessage","_messageResponse","_handshakeMessages","_messageFailure","_receive","_hasSubscriptions","_resolveScopedCallback","delegate","_addListener","isListener","_name","TransportRegistry","logLevel","urls","maxURILength","maxInterval","deep","target","objects","propName","prop","targ","hostAndPort","host","location","receive","failureMessage","registerTransport","unregisterTransport","unregisterTransports","findTransport","getTransportRegistry","configure","handshake","disconnect","disconnectProps","disconnectCallback","startBatch","endBatch","batch","addListener","removeListener","clearListeners","subscribe","subscribeProps","subscribeCallback","unsubscribe","unsubscribeProps","unsubscribeCallback","resubscribe","clearSubscriptions","publish","content","publishProps","publishCallback","remoteCall","error","getStatus","isDisconnected","setBackoffIncrement","period","getBackoffIncrement","getBackoffPeriod","increaseBackoffPeriod","resetBackoffPeriod","setLogLevel","registerExtension","unregisterExtension","ext","getExtension","getName","getClientId","Aggreg","items","owner","Stack","stack","page","guids","listeners","guid","Echo","parameter","Game","role","gameId","userId","userName","options","GameEngine","msgId","payload","callerId","maxGames","gameInfo","Gda","table","key2","column","columns","rows","start","stop","Remoting","fromResource","cmd","from","askingResource","capabilities","answeringResource","user","available","uid","GroupManagement","group","users","groupName","hardFail","actions","Httpclient","MacroDebug","breakpoint","enabled","path","exp","frame","parameters","breakpoints","debug","Macro","Sendmail","Messaging","Queue","description","originBusinessId","originDeploymentId","taskId","capacity","Notif","Rdbms","Sms_ovh","Cron","Search","indices","query","sort","Template","languageTag","Trigger","Zpfs_s3","oldPath","folder","parents","tags","metadata","contentType","flatten","metadataFiles","Zpfs_hdfs","Zpfs_s3compat","Userdir","userKeys","HTTP_PATTERN","API_URL","FORCE_HTTPS","normalizeApiUrl","apiUrl","charAt","shuffle","list","floor","random","getSecureUrl","forceHttps","HTTPS_PROTOCOL","getServers","transports","normalizedSecuresApiUrl","servers","map","server","isDerivedOf","Derived","Parent","getPrototypeOf","is","uuid","dictionary","reduce","previous","Message","ClientHelper","Transports","userInfo","uniqId","connectionToServerFail","connectionListeners","connected","wasConnected","serverUrl","sessionId","subscribeQueue","CometD","ALL","forEach","updateServerUrl","initialized","handshakeFailure","RECONNECT_NONE_VALUE","authenticationFailed","RECONNECT_HANDSHAKE_VALUE","negotiationFailed","_this","connectionWillClose","prefix","connectionEstablished","connectionBroken","connectionClosed","filter","onFailedHandshake","_this2","getHandshakeFields","noServerUrlAvailable","onConnectionBroken","onConnectionClosed","onConnectionEstablished","onConnectionToServerFail","onConnectionWillClose","Type","getAsyncMacroPublisher","createServiceByPublisher","isMacroType","getMacroPublisher","getServicePublisher","service","$subscriptions","uniqRequestId","_this3","getUniqRequestId","Promise","resolve","reject","errors","_this4","findIndex","_this5","onSuccessfulHandshake","onMessageLost","onNegotiationFailed","onNoServerUrlAvailable","getQueuedSubscription","queued","_this6","Client","helper","addConnectionStatusListener","isConnected","removeConnectionStatusListener","connect","createAsyncMacroService","createService","getUserId","getUserInfo","setAuthentication","setResource","TypeError","getOwnPropertyNames","MemoryStorage","_map","Map","get","delete","n","keys","size","platformStorage","localStorage","ZETAPUSH_SESSION_KEY","SessionPersistenceStrategy","storage","getItem","session","e","setItem","SmartClient","persistence","hasCredentials","getCredentials","setCredentials","simple","isStronglyAuthenticated","weak","credentials","lifeCycleConnectionHandler","set","isWeaklyAuthenticated","WeakClient","getToken","strategy"],"mappings":"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"}