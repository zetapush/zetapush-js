{"version":3,"file":"zetapush.min.js","sources":["../node_modules/zetapush-cometd/lib/FetchLongPollingTransport.js","../node_modules/zetapush-cometd/lib/WebSocketTransport.js","../src/mapping/core.js","../src/mapping/authentications.js","../src/authentication/handshake.js","../src/connection/connection-status.js","../node_modules/zetapush-cometd/lib/TransportRegistry.js","../node_modules/zetapush-cometd/lib/Utils.js","../node_modules/zetapush-cometd/lib/CometD.js","../node_modules/zetapush-cometd/lib/Transport.js","../node_modules/zetapush-cometd/lib/RequestTransport.js","../node_modules/zetapush-cometd/lib/LongPollingTransport.js","../node_modules/zetapush-cometd/lib/browser/Transports.js","../node_modules/zetapush-cometd/index.js","../src/mapping/services.js","../src/utils/index.js","../src/client/helper.js","../src/client/basic.js","../src/utils/storage.js","../src/utils/session-persistence.js","../src/client/smart.js","../src/client/weak.js","../src/index.js"],"sourcesContent":["var Transport = require('./Transport')\nvar LongPollingTransport = require('./LongPollingTransport')\n\n/**\n * Implements LongPollingTransport using borwser fetch() API\n * @access private\n * @return {FetchLongPollingTransport}\n */\nfunction FetchLongPollingTransport() {\n  var _super = new LongPollingTransport()\n  var that = Transport.derive(_super)\n\n  /**\n   * Implements transport via fetch() API\n   * @param {Object} packet\n   */\n  that.xhrSend = function (packet) {\n    FetchLongPollingTransport.fetch(packet.url, {\n      method: 'post',\n      body: packet.body,\n      headers: Object.assign(packet.headers, {\n        'Content-Type': 'application/json;charset=UTF-8'\n      })\n    })\n    .then(function (response) {\n      return response.json()\n    })\n    .then(packet.onSuccess)\n    .catch(packet.onError)\n  }\n\n  return that\n}\n\n// Reference global WebSocket \nFetchLongPollingTransport.fetch = 'Abstract'\n\n// Export FetchLongPollingTransport\nmodule.exports = FetchLongPollingTransport;\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\nfunction WebSocketTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _cometd;\n    // By default WebSocket is supported\n    var _webSocketSupported = true;\n    // Whether we were able to establish a WebSocket connection\n    var _webSocketConnected = false;\n    var _stickyReconnect = true;\n    // The context contains the envelopes that have been sent\n    // and the timeouts for the messages that have been sent.\n    var _context = null;\n    var _connecting = null;\n    var _connected = false;\n    var _successCallback = null;\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _webSocketSupported = true;\n        if (init) {\n            _webSocketConnected = false;\n        }\n        _stickyReconnect = true;\n        _context = null;\n        _connecting = null;\n        _connected = false;\n    };\n\n    function _forceClose(context, event) {\n        if (context) {\n            this.webSocketClose(context, event.code, event.reason);\n            // Force immediate failure of pending messages to trigger reconnect.\n            // This is needed because the server may not reply to our close()\n            // and therefore the onclose function is never called.\n            this.onClose(context, event);\n        }\n    }\n\n    function _sameContext(context) {\n        return context === _connecting || context === _context;\n    }\n\n    function _storeEnvelope(context, envelope, metaConnect) {\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            var message = envelope.messages[i];\n            if (message.id) {\n                messageIds.push(message.id);\n            }\n        }\n        context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n    }\n\n    function _websocketConnect(context) {\n        // We may have multiple attempts to open a WebSocket\n        // connection, for example a /meta/connect request that\n        // may take time, along with a user-triggered publish.\n        // Early return if we are already connecting.\n        if (_connecting) {\n            return;\n        }\n\n        // Mangle the URL, changing the scheme from 'http' to 'ws'.\n        var url = _cometd.getURL().replace(/^http/, 'ws');\n        this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n        try {\n            var protocol = _cometd.getConfiguration().protocol;\n            var WebSocket = WebSocketTransport.WebSocket;\n            context.webSocket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);\n            _connecting = context;\n        } catch (x) {\n            _webSocketSupported = false;\n            this._debug('Exception while creating WebSocket object', x);\n            throw x;\n        }\n\n        // By default use sticky reconnects.\n        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\n        var self = this;\n        var connectTimeout = _cometd.getConfiguration().connectTimeout;\n        if (connectTimeout > 0) {\n            context.connectTimer = self.setTimeout(function() {\n                _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n                // The connection was not opened, close anyway.\n                _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n            }, connectTimeout);\n        }\n\n        var onopen = function() {\n            _cometd._debug('WebSocket onopen', context);\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            if (_sameContext(context)) {\n                _connecting = null;\n                _context = context;\n                _webSocketConnected = true;\n                self.onOpen(context);\n            } else {\n                // We have a valid connection already, close this one.\n                _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n                _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n            }\n        };\n\n        // This callback is invoked when the server sends the close frame.\n        // The close frame for a connection may arrive *after* another\n        // connection has been opened, so we must make sure that actions\n        // are performed only if it's the same connection.\n        var onclose = function(event) {\n            event = event || {code: 1000};\n            _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            self.onClose(context, event);\n        };\n\n        var onmessage = function(wsMessage) {\n            _cometd._debug('WebSocket onmessage', wsMessage, context);\n            self.onMessage(context, wsMessage);\n        };\n\n        context.webSocket.onopen = onopen;\n        context.webSocket.onclose = onclose;\n        context.webSocket.onerror = function() {\n            // Clients should call onclose(), but if they do not we do it here for safety.\n            onclose({code: 1000, reason: 'Error'});\n        };\n        context.webSocket.onmessage = onmessage;\n\n        this._debug('Transport', this.getType(), 'configured callbacks on', context);\n    }\n\n    function _webSocketSend(context, envelope, metaConnect) {\n        var json = JSON.stringify(envelope.messages);\n        context.webSocket.send(json);\n        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);\n\n        // Manage the timeout waiting for the response.\n        var maxDelay = this.getConfiguration().maxNetworkDelay;\n        var delay = maxDelay;\n        if (metaConnect) {\n            delay += this.getAdvice().timeout;\n            _connected = true;\n        }\n\n        var self = this;\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            (function() {\n                var message = envelope.messages[i];\n                if (message.id) {\n                    messageIds.push(message.id);\n                    context.timeouts[message.id] = self.setTimeout(function() {\n                        _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n                        _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n                    }, delay);\n                }\n            })();\n        }\n\n        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n    }\n\n    _self._notifySuccess = function(fn, messages) {\n        fn.call(this, messages);\n    };\n\n    _self._notifyFailure = function(fn, context, messages, failure) {\n        fn.call(this, context, messages, failure);\n    };\n\n    function _send(context, envelope, metaConnect) {\n        try {\n            if (context === null) {\n                context = _connecting || {\n                        envelopes: {},\n                        timeouts: {}\n                    };\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _websocketConnect.call(this, context);\n            } else {\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        } catch (x) {\n            // Keep the semantic of calling response callbacks asynchronously after the request.\n            var self = this;\n            self.setTimeout(function() {\n                _forceClose.call(self, context, {\n                    code: 1000,\n                    reason: 'Exception',\n                    exception: x\n                });\n            }, 0);\n        }\n    }\n\n    _self.onOpen = function(context) {\n        var envelopes = context.envelopes;\n        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var element = envelopes[key];\n                var envelope = element[0];\n                var metaConnect = element[1];\n                // Store the success callback, which is independent from the envelope,\n                // so that it can be used to notify arrival of messages.\n                _successCallback = envelope.onSuccess;\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        }\n    };\n\n    _self.onMessage = function(context, wsMessage) {\n        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n        var close = false;\n        var messages = this.convertToMessages(wsMessage.data);\n        var messageIds = [];\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n\n            // Detect if the message is a response to a request we made.\n            // If it's a meta message, for sure it's a response; otherwise it's\n            // a publish message and publish responses don't have the data field.\n            if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n                if (message.id) {\n                    messageIds.push(message.id);\n\n                    var timeout = context.timeouts[message.id];\n                    if (timeout) {\n                        this.clearTimeout(timeout);\n                        delete context.timeouts[message.id];\n                        this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n                    }\n                }\n            }\n\n            if ('/meta/connect' === message.channel) {\n                _connected = false;\n            }\n            if ('/meta/disconnect' === message.channel && !_connected) {\n                close = true;\n            }\n        }\n\n        // Remove the envelope corresponding to the messages.\n        var removed = false;\n        var envelopes = context.envelopes;\n        for (var j = 0; j < messageIds.length; ++j) {\n            var id = messageIds[j];\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var ids = key.split(',');\n                    var index = Utils.inArray(id, ids);\n                    if (index >= 0) {\n                        removed = true;\n                        ids.splice(index, 1);\n                        var envelope = envelopes[key][0];\n                        var metaConnect = envelopes[key][1];\n                        delete envelopes[key];\n                        if (ids.length > 0) {\n                            envelopes[ids.join(',')] = [envelope, metaConnect];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if (removed) {\n            this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n        }\n\n        this._notifySuccess(_successCallback, messages);\n\n        if (close) {\n            this.webSocketClose(context, 1000, 'Disconnect');\n        }\n    };\n\n    _self.onClose = function(context, event) {\n        this._debug('Transport', this.getType(), 'closed', context, event);\n\n        if (_sameContext(context)) {\n            // Remember if we were able to connect.\n            // This close event could be due to server shutdown,\n            // and if it restarts we want to try websocket again.\n            _webSocketSupported = _stickyReconnect && _webSocketConnected;\n            _connecting = null;\n            _context = null;\n        }\n\n        var timeouts = context.timeouts;\n        context.timeouts = {};\n        for (var id in timeouts) {\n            if (timeouts.hasOwnProperty(id)) {\n                this.clearTimeout(timeouts[id]);\n            }\n        }\n\n        var envelopes = context.envelopes;\n        context.envelopes = {};\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var envelope = envelopes[key][0];\n                var metaConnect = envelopes[key][1];\n                if (metaConnect) {\n                    _connected = false;\n                }\n                var failure = {\n                    websocketCode: event.code,\n                    reason: event.reason\n                };\n                if (event.exception) {\n                    failure.exception = event.exception;\n                }\n                this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n            }\n        }\n    };\n\n    _self.registered = function(type, cometd) {\n        _super.registered(type, cometd);\n        _cometd = cometd;\n    };\n\n    _self.accept = function(version, crossDomain, url) {\n        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n        // Using !! to return a boolean (and not the WebSocket object).\n        return _webSocketSupported && !('undefined' === typeof WebSocket) && _cometd.websocketEnabled !== false;\n    };\n\n    _self.send = function(envelope, metaConnect) {\n        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);\n        _send.call(this, _context, envelope, metaConnect);\n    };\n\n    _self.webSocketClose = function(context, code, reason) {\n        try {\n            if (context.webSocket) {\n                context.webSocket.close(code, reason);\n            }\n        } catch (x) {\n            this._debug(x);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n        this.reset(true);\n    };\n\n    return _self;\n};\n\n// Reference global WebSocket \nWebSocketTransport.WebSocket = 'Abstract';\n\n// Export WebSocketTransport\nmodule.exports = WebSocketTransport;\n","/**\n * @access protected\n */\nexport class Service {\n  constructor({ $publish }) {\n    this.$publish = $publish\n  }\n}\n","import { Service } from './core'\n/**\n * Delegating authentication\n *\n * This authentication delegates authentication to an external auth provider\n * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL\n * <br>The response must be in JSON format\n *  Each key of the response will be considered a user information field name\n * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)\n * */\n/**\n * End-user API for the delegating authentication\n *\n * Provisionning verbs.\n * @access public\n * */\nexport class Delegating extends Service {\n\t/**\n\t * Get default deployment id associated to Delegating service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'delegating_0'\n\t}\n}\n/**\n * Local authentication\n *\n * Zetapush local authentication\n *  The configurer can choose the primary key and mandatory user fields for account creation\n *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)\n * */\n/**\n * End-user API for the simple local authentication\n *\n * These API verbs allow end-users to manage their account.\n * @access public\n * */\nexport class Simple extends Service {\n\t/**\n\t * Get default deployment id associated to Simple service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'simple_0'\n\t}\n}\n/**\n * Weak authentication\n *\n * The weak authentication allows for anonymous authentication of devices\n *  Such devices can display a qrcode to allow regular users to take control of them\n * */\n/**\n * User API for weak devices control\n *\n * User API for control and release of weakly authenticated user sessions.\n * @access public\n * */\nexport class Weak extends Service {\n\t/**\n\t * Get default deployment id associated to Weak service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'weak_0'\n\t}\n\t/**\n\t * Controls a session\n\t *\n\t * Takes control of a weak user session, identified by the given public token.\n\t * The public token has been previously made available by the controlled device, for example by displaying a QRCode.\n\t * Upon control notification, the client SDK of the controlled session is expected to re-handshake.\n\t * */\n\tcontrol({publicToken,fullRights}) { return this.$publish('control', {publicToken,fullRights})}\n\t/**\n\t * Returns the current token\n\t *\n\t * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.\n\t * The token can be used to log in as the same weak user another time.\n\t * */\n\tgetToken() { return this.$publish('getToken', {})}\n\t/**\n\t * Releases a session\n\t *\n\t * Releases control of a weak user session, identified by the given public token.\n\t * The weak user session must have been previously controlled by a call to 'control'.\n\t * */\n\trelease({publicToken,fullRights}) { return this.$publish('release', {publicToken,fullRights})}\n}\n","import { Delegating, Simple, Weak } from '../mapping/authentications'\n\n/**\n * ZetaPush deployables names\n */\nconst DeployableNames = {\n  AUTH_SIMPLE: 'simple',\n  AUTH_WEAK: 'weak',\n  AUTH_DELEGATING: 'delegating'\n}\n\n/**\n * Provide abstraction over CometD handshake data structure\n * @access protected\n */\nclass AbstractHandshake {\n  /**\n   * Create a new handshake manager\n   * @param {{authType: string, sandboxId: string, deploymentId: string}} parameters\n   */\n  constructor({ authType, sandboxId, deploymentId }) {\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.authType = authType\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.deploymentId = deploymentId\n  }\n  /**\n   * @param {ClientHelper} client\n   * @return {Object}\n   */\n  getHandshakeFields(client) {\n    const authentication = {\n      data: this.authData,\n      type: `${client.getSandboxId()}.${this.deploymentId}.${this.authType}`,\n      version: this.authVersion\n    }\n    if (client.getResource()) {\n      authentication.resource = client.getResource()\n    }\n    return {\n      ext: {\n        authentication\n      }\n    }\n  }\n  /**\n   * Get auth version\n   * @return {string}\n   */\n  get authVersion() {\n    return 'none'\n  }\n}\n\n/**\n * Provide abstraction over CometD token base handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass TokenHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, token: string}} parameters\n   */\n  constructor({ authType, deploymentId, token }) {\n    super({ deploymentId, authType })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.token = token\n  }\n  /**\n   * @return {token: string}\n   */\n  get authData() {\n    const { token } = this\n    return {\n      token\n    }\n  }\n}\n\n/**\n * Provide abstraction over CometD credentials based handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass CredentialsHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   */\n  constructor({ authType, deploymentId, login, password }) {\n    super({ authType, deploymentId })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.login = login\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.password = password\n  }\n  /**\n   * Get auth data\n   * @return {login: string, password: string}\n   */\n  get authData() {\n    const { login, password } = this\n    return {\n      login, password\n    }\n  }\n}\n\n/**\n * Factory to create handshake\n * @access public\n */\nexport class Authentication {\n  /**\n   * @param {{deploymentId: string, login: string, password: string}} parameters\n   * @return {CredentialsHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   login: <USER-LOGIN>,\n   *   password: '<USER-PASSWORD>'\n   * })\n   */\n  static simple({ deploymentId = Simple.DEFAULT_DEPLOYMENT_ID, login, password }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_SIMPLE,\n      deploymentId,\n      login,\n      password\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static weak({ deploymentId = Weak.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_WEAK,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-DELEGATING-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static delegating({ deploymentId = Delegating.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_DELEGATING,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   * @return {TokenHandshake|CredentialsHandshake}\n   */\n  static create({ authType, deploymentId, login, password }) {\n    if (password === null) {\n      return new TokenHandshake({ authType, deploymentId, token: login })\n    }\n    return new CredentialsHandshake({ authType, deploymentId, login, password })\n  }\n}\n","/**\n * Define life cycle connection methods\n * @access public\n */\nexport class ConnectionStatusListener {\n  /**\n   * Callback fired when connection is broken\n   */\n  onConnectionBroken() {}\n  /**\n   * Callback fired when connection is closed\n   */\n  onConnectionClosed() {}\n  /**\n   * Callback fired when connection is established\n   */\n  onConnectionEstablished() {}\n  /**\n   * Callback fired when an error occurs in connection to server step\n   * @param {Object} failure\n   */\n  onConnectionToServerFail(failure) {}\n  /**\n   * Callback no server url avaibale\n   */\n  onNoServerUrlAvailable() {}\n  /**\n  * Callback fired when connection will close\n  */\n  onConnectionWillClose() {}\n  /**\n   * Callback fired when an error occurs in handshake step\n   * @param {Object} failure\n   */\n  onFailedHandshake(failure) {}\n  /**\n   * Callback fired when a message is lost\n   */\n  onMessageLost() {}\n  /**\n   * Callback fired when handshake step succeed\n   * @param {Object} authentication\n   */\n  onSuccessfulHandshake(authentication) {}\n}\n","/**\n * A registry for transports used by the CometD object.\n */\nmodule.exports = function TransportRegistry() {\n    var _types = [];\n    var _transports = {};\n\n    this.getTransportTypes = function() {\n        return _types.slice(0);\n    };\n\n    this.findTransportTypes = function(version, crossDomain, url) {\n        var result = [];\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            if (_transports[type].accept(version, crossDomain, url) === true) {\n                result.push(type);\n            }\n        }\n        return result;\n    };\n\n    this.negotiateTransport = function(types, version, crossDomain, url) {\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            for (var j = 0; j < types.length; ++j) {\n                if (type === types[j]) {\n                    var transport = _transports[type];\n                    if (transport.accept(version, crossDomain, url) === true) {\n                        return transport;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    this.add = function(type, transport, index) {\n        var existing = false;\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                existing = true;\n                break;\n            }\n        }\n\n        if (!existing) {\n            if (typeof index !== 'number') {\n                _types.push(type);\n            } else {\n                _types.splice(index, 0, type);\n            }\n            _transports[type] = transport;\n        }\n\n        return !existing;\n    };\n\n    this.find = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                return _transports[type];\n            }\n        }\n        return null;\n    };\n\n    this.remove = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                _types.splice(i, 1);\n                var transport = _transports[type];\n                delete _transports[type];\n                return transport;\n            }\n        }\n        return null;\n    };\n\n    this.clear = function() {\n        _types = [];\n        _transports = {};\n    };\n\n    this.reset = function(init) {\n        for (var i = 0; i < _types.length; ++i) {\n            _transports[_types[i]].reset(init);\n        }\n    };\n};\n","exports.isString = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return typeof value === 'string' || value instanceof String;\n};\n\nexports.isArray = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return value instanceof Array;\n};\n\n/**\n * Returns whether the given element is contained into the given array.\n * @param element the element to check presence for\n * @param array the array to check for the element presence\n * @return the index of the element, if present, or a negative index if the element is not present\n */\nexports.inArray = function (element, array) {\n    for (var i = 0; i < array.length; ++i) {\n        if (element === array[i]) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nexports.setTimeout = function (cometd, funktion, delay) {\n    return setTimeout(function() {\n        try {\n            cometd._debug('Invoking timed function', funktion);\n            funktion();\n        } catch (x) {\n            cometd._debug('Exception invoking timed function', funktion, x);\n        }\n    }, delay);\n};\n\nexports.clearTimeout = function (timeoutHandle) {\n    clearTimeout(timeoutHandle);\n};\n","var TransportRegistry = require('./TransportRegistry');\nvar Utils = require('./Utils');\n/**\n * The constructor for a CometD object, identified by an optional name.\n * The default name is the string 'default'.\n * In the rare case a page needs more than one Bayeux conversation,\n * a new instance can be created via:\n * <pre>\n * var bayeuxUrl2 = ...;\n *\n * // Dojo style\n * var cometd2 = new dojox.CometD('another_optional_name');\n *\n * // jQuery style\n * var cometd2 = new $.CometD('another_optional_name');\n *\n * cometd2.init({url: bayeuxUrl2});\n * </pre>\n * @param name the optional name of this cometd object\n */\nmodule.exports = function CometD(name) {\n    var _cometd = this;\n    var _name = name || 'default';\n    var _crossDomain = false;\n    var _transports = new TransportRegistry();\n    var _transport;\n    var _status = 'disconnected';\n    var _messageId = 0;\n    var _clientId = null;\n    var _batch = 0;\n    var _messageQueue = [];\n    var _internalBatch = false;\n    var _listeners = {};\n    var _backoff = 0;\n    var _scheduledSend = null;\n    var _extensions = [];\n    var _advice = {};\n    var _handshakeProps;\n    var _handshakeCallback;\n    var _callbacks = {};\n    var _remoteCalls = {};\n    var _reestablish = false;\n    var _connected = false;\n    var _unconnectTime = 0;\n    var _handshakeMessages = 0;\n    var _config = {\n        protocol: null,\n        stickyReconnect: true,\n        connectTimeout: 0,\n        maxConnections: 2,\n        backoffIncrement: 1000,\n        maxBackoff: 60000,\n        logLevel: 'info',\n        reverseIncomingExtensions: true,\n        maxNetworkDelay: 10000,\n        requestHeaders: {},\n        appendMessageTypeToURL: true,\n        autoBatch: false,\n        urls: {},\n        maxURILength: 2000,\n        advice: {\n            timeout: 60000,\n            interval: 0,\n            reconnect: 'retry',\n            maxInterval: 0\n        }\n    };\n\n    function _fieldValue(object, name) {\n        try {\n            return object[name];\n        } catch (x) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Mixes in the given objects into the target object by copying the properties.\n     * @param deep if the copy must be deep\n     * @param target the target object\n     * @param objects the objects whose properties are copied into the target\n     */\n    this._mixin = function(deep, target, objects) {\n        var result = target || {};\n\n        // Skip first 2 parameters (deep and target), and loop over the others\n        for (var i = 2; i < arguments.length; ++i) {\n            var object = arguments[i];\n\n            if (object === undefined || object === null) {\n                continue;\n            }\n\n            for (var propName in object) {\n                if (object.hasOwnProperty(propName)) {\n                    var prop = _fieldValue(object, propName);\n                    var targ = _fieldValue(result, propName);\n\n                    // Avoid infinite loops\n                    if (prop === target) {\n                        continue;\n                    }\n                    // Do not mixin undefined values\n                    if (prop === undefined) {\n                        continue;\n                    }\n\n                    if (deep && typeof prop === 'object' && prop !== null) {\n                        if (prop instanceof Array) {\n                            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n                        } else {\n                            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                            result[propName] = this._mixin(deep, source, prop);\n                        }\n                    } else {\n                        result[propName] = prop;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    function _isString(value) {\n        return Utils.isString(value);\n    }\n\n    function _isFunction(value) {\n        if (value === undefined || value === null) {\n            return false;\n        }\n        return typeof value === 'function';\n    }\n\n    function _zeroPad(value, length) {\n        var result = '';\n        while (--length > 0) {\n            if (value >= Math.pow(10, length)) {\n                break;\n            }\n            result += '0';\n        }\n        result += value;\n        return result;\n    }\n\n    function _log(level, args) {\n        if ('undefined' !== typeof console) {\n            var logger = console[level];\n            if (_isFunction(logger)) {\n                var now = new Date();\n                [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n                logger.apply(console, args);\n            }\n        }\n    }\n\n    this._warn = function() {\n        _log('warn', arguments);\n    };\n\n    this._info = function() {\n        if (_config.logLevel !== 'warn') {\n            _log('info', arguments);\n        }\n    };\n\n    this._debug = function() {\n        if (_config.logLevel === 'debug') {\n            _log('debug', arguments);\n        }\n    };\n\n    function _splitURL(url) {\n        // [1] = protocol://,\n        // [2] = host:port,\n        // [3] = host,\n        // [4] = IPv6_host,\n        // [5] = IPv4_host,\n        // [6] = :port,\n        // [7] = port,\n        // [8] = uri,\n        // [9] = rest (query / fragment)\n        return /(^https?:\\/\\/)?(((\\[[^\\]]+\\])|([^:\\/\\?#]+))(:(\\d+))?)?([^\\?#]*)(.*)?/.exec(url);\n    }\n\n    /**\n     * Returns whether the given hostAndPort is cross domain.\n     * The default implementation checks against window.location.host\n     * but this function can be overridden to make it work in non-browser\n     * environments.\n     *\n     * @param hostAndPort the host and port in format host:port\n     * @return whether the given hostAndPort is cross domain\n     */\n    this._isCrossDomain = function(hostAndPort) {\n        var host = typeof location === 'undefined' ? hostAndPort : location.host;\n        return hostAndPort && hostAndPort !== host;\n    };\n\n    function _configure(configuration) {\n        _cometd._debug('Configuring cometd object with', configuration);\n        // Support old style param, where only the Bayeux server URL was passed\n        if (_isString(configuration)) {\n            configuration = { url: configuration };\n        }\n        if (!configuration) {\n            configuration = {};\n        }\n\n        _config = _cometd._mixin(false, _config, configuration);\n\n        var url = _cometd.getURL();\n        if (!url) {\n            throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n        }\n\n        // Check if we're cross domain.\n        var urlParts = _splitURL(url);\n        var hostAndPort = urlParts[2];\n        var uri = urlParts[8];\n        var afterURI = urlParts[9];\n        _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\n        // Check if appending extra path is supported\n        if (_config.appendMessageTypeToURL) {\n            if (afterURI !== undefined && afterURI.length > 0) {\n                _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                _config.appendMessageTypeToURL = false;\n            } else {\n                var uriSegments = uri.split('/');\n                var lastSegmentIndex = uriSegments.length - 1;\n                if (uri.match(/\\/$/)) {\n                    lastSegmentIndex -= 1;\n                }\n                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n                    // It will be difficult to add the extra path in this case\n                    _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                    _config.appendMessageTypeToURL = false;\n                }\n            }\n        }\n    }\n\n    function _removeListener(subscription) {\n        if (subscription) {\n            var subscriptions = _listeners[subscription.channel];\n            if (subscriptions && subscriptions[subscription.id]) {\n                delete subscriptions[subscription.id];\n                _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n            }\n        }\n    }\n\n    function _removeSubscription(subscription) {\n        if (subscription && !subscription.listener) {\n            _removeListener(subscription);\n        }\n    }\n\n    function _clearSubscriptions() {\n        for (var channel in _listeners) {\n            if (_listeners.hasOwnProperty(channel)) {\n                var subscriptions = _listeners[channel];\n                if (subscriptions) {\n                    for (var i = 0; i < subscriptions.length; ++i) {\n                        _removeSubscription(subscriptions[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    function _setStatus(newStatus) {\n        if (_status !== newStatus) {\n            _cometd._debug('Status', _status, '->', newStatus);\n            _status = newStatus;\n        }\n    }\n\n    function _isDisconnected() {\n        return _status === 'disconnecting' || _status === 'disconnected';\n    }\n\n    function _nextMessageId() {\n        var result = ++_messageId;\n        return '' + result;\n    }\n\n    function _applyExtension(scope, callback, name, message, outgoing) {\n        try {\n            return callback.call(scope, message);\n        } catch (x) {\n            var handler = _cometd.onExtensionException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking extension exception handler', name, x);\n                try {\n                    handler.call(_cometd, x, name, outgoing, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of extension exception handler', name, xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of extension', name, x);\n            }\n            return message;\n        }\n    }\n\n    function _applyIncomingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;\n            var extension = _extensions[index];\n            var callback = extension.extension.incoming;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _applyOutgoingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var extension = _extensions[i];\n            var callback = extension.extension.outgoing;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _notify(channel, message) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions && subscriptions.length > 0) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                var subscription = subscriptions[i];\n                // Subscriptions may come and go, so the array may have 'holes'\n                if (subscription) {\n                    try {\n                        subscription.callback.call(subscription.scope, message);\n                    } catch (x) {\n                        var handler = _cometd.onListenerException;\n                        if (_isFunction(handler)) {\n                            _cometd._debug('Invoking listener exception handler', subscription, x);\n                            try {\n                                handler.call(_cometd, x, subscription, subscription.listener, message);\n                            } catch (xx) {\n                                _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                            }\n                        } else {\n                            _cometd._info('Exception during execution of listener', subscription, message, x);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function _notifyListeners(channel, message) {\n        // Notify direct listeners\n        _notify(channel, message);\n\n        // Notify the globbing listeners\n        var channelParts = channel.split('/');\n        var last = channelParts.length - 1;\n        for (var i = last; i > 0; --i) {\n            var channelPart = channelParts.slice(0, i).join('/') + '/*';\n            // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n            // so we stop at the first non recursive globbing\n            if (i === last) {\n                _notify(channelPart, message);\n            }\n            // Add the recursive globber and notify\n            channelPart += '*';\n            _notify(channelPart, message);\n        }\n    }\n\n    function _cancelDelayedSend() {\n        if (_scheduledSend !== null) {\n            Utils.clearTimeout(_scheduledSend);\n        }\n        _scheduledSend = null;\n    }\n\n    function _delayedSend(operation, delay) {\n        if ('undefined' === typeof delay) {\n          delay = _backoff\n        }\n        _cancelDelayedSend();\n        var time = _advice.interval + delay;\n        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n        _scheduledSend = Utils.setTimeout(_cometd, operation, time);\n    }\n\n    // Needed to break cyclic dependencies between function definitions\n    var _handleMessages;\n    var _handleFailure;\n\n    /**\n     * Delivers the messages to the CometD server\n     * @param sync whether the send is synchronous\n     * @param messages the array of messages to send\n     * @param metaConnect true if this send is on /meta/connect\n     * @param extraPath an extra path to append to the Bayeux server URL\n     */\n    function _send(sync, messages, metaConnect, extraPath) {\n        // We must be sure that the messages have a clientId.\n        // This is not guaranteed since the handshake may take time to return\n        // (and hence the clientId is not known yet) and the application\n        // may create other messages.\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var messageId = message.id;\n\n            if (_clientId) {\n                message.clientId = _clientId;\n            }\n\n            message = _applyOutgoingExtensions(message);\n            if (message !== undefined && message !== null) {\n                // Extensions may have modified the message id, but we need to own it.\n                message.id = messageId;\n                messages[i] = message;\n            } else {\n                delete _callbacks[messageId];\n                messages.splice(i--, 1);\n            }\n        }\n\n        if (messages.length === 0) {\n            return;\n        }\n\n        var url = _cometd.getURL();\n        if (_config.appendMessageTypeToURL) {\n            // If url does not end with '/', then append it\n            if (!url.match(/\\/$/)) {\n                url = url + '/';\n            }\n            if (extraPath) {\n                url = url + extraPath;\n            }\n        }\n\n        var envelope = {\n            url: url,\n            sync: sync,\n            messages: messages,\n            onSuccess: function(rcvdMessages) {\n                try {\n                    _handleMessages.call(_cometd, rcvdMessages);\n                } catch (x) {\n                    _cometd._info('Exception during handling of messages', x);\n                }\n            },\n            onFailure: function(conduit, messages, failure) {\n                try {\n                    var transport = _cometd.getTransport();\n                    failure.connectionType = transport ? transport.getType() : \"unknown\";\n                    _handleFailure.call(_cometd, conduit, messages, failure);\n                } catch (x) {\n                    _cometd._info('Exception during handling of failure', x);\n                }\n            }\n        };\n        _cometd._debug('Send', envelope);\n        _transport.send(envelope, metaConnect);\n    }\n\n    function _queueSend(message) {\n        if (_batch > 0 || _internalBatch === true) {\n            _messageQueue.push(message);\n        } else {\n            _send(false, [message], false);\n        }\n    }\n\n    /**\n     * Sends a complete bayeux message.\n     * This method is exposed as a public so that extensions may use it\n     * to send bayeux message directly, for example in case of re-sending\n     * messages that have already been sent but that for some reason must\n     * be resent.\n     */\n    this.send = _queueSend;\n\n    function _resetBackoff() {\n        _backoff = 0;\n    }\n\n    function _increaseBackoff() {\n        if (_backoff < _config.maxBackoff) {\n            _backoff += _config.backoffIncrement;\n        }\n        return _backoff;\n    }\n\n    /**\n     * Starts a the batch of messages to be sent in a single request.\n     * @see #_endBatch(sendMessages)\n     */\n    function _startBatch() {\n        ++_batch;\n        _cometd._debug('Starting batch, depth', _batch);\n    }\n\n    function _flushBatch() {\n        var messages = _messageQueue;\n        _messageQueue = [];\n        if (messages.length > 0) {\n            _send(false, messages, false);\n        }\n    }\n\n    /**\n     * Ends the batch of messages to be sent in a single request,\n     * optionally sending messages present in the message queue depending\n     * on the given argument.\n     * @see #_startBatch()\n     */\n    function _endBatch() {\n        --_batch;\n        _cometd._debug('Ending batch, depth', _batch);\n        if (_batch < 0) {\n            throw 'Calls to startBatch() and endBatch() are not paired';\n        }\n\n        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n            _flushBatch();\n        }\n    }\n\n    /**\n     * Sends the connect message\n     */\n    function _connect() {\n        if (!_isDisconnected()) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/connect',\n                connectionType: _transport.getType()\n            };\n\n            // In case of reload or temporary loss of connection\n            // we want the next successful connect to return immediately\n            // instead of being held by the server, so that connect listeners\n            // can be notified that the connection has been re-established\n            if (!_connected) {\n                bayeuxMessage.advice = { timeout: 0 };\n            }\n\n            _setStatus('connecting');\n            _cometd._debug('Connect sent', bayeuxMessage);\n            _send(false, [bayeuxMessage], true, 'connect');\n            _setStatus('connected');\n        }\n    }\n\n    function _delayedConnect(delay) {\n        _setStatus('connecting');\n        _delayedSend(function() {\n            _connect();\n        }, delay);\n    }\n\n    function _updateAdvice(newAdvice) {\n        if (newAdvice) {\n            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n            _cometd._debug('New advice', _advice);\n        }\n    }\n\n    function _disconnect(abort) {\n        _cancelDelayedSend();\n        if (abort && _transport) {\n            _transport.abort();\n        }\n        _clientId = null;\n        _setStatus('disconnected');\n        _batch = 0;\n        _resetBackoff();\n        _transport = null;\n\n        // Fail any existing queued message\n        if (_messageQueue.length > 0) {\n            var messages = _messageQueue;\n            _messageQueue = [];\n            _handleFailure.call(_cometd, undefined, messages, {\n                reason: 'Disconnected'\n            });\n        }\n    }\n\n    function _notifyTransportFailure(oldTransport, newTransport, failure) {\n        var handler = _cometd.onTransportException;\n        if (_isFunction(handler)) {\n            _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n            try {\n                handler.call(_cometd, failure, oldTransport, newTransport);\n            } catch (x) {\n                _cometd._info('Exception during execution of transport exception handler', x);\n            }\n        }\n    }\n\n    /**\n     * Sends the initial handshake message\n     */\n    function _handshake(handshakeProps, handshakeCallback) {\n        if (_isFunction(handshakeProps)) {\n            handshakeCallback = handshakeProps;\n            handshakeProps = undefined;\n        }\n\n        _clientId = null;\n\n        _clearSubscriptions();\n\n        // Reset the transports if we're not retrying the handshake\n        if (_isDisconnected()) {\n            _transports.reset(true);\n            _updateAdvice(_config.advice);\n        } else {\n            // We are retrying the handshake, either because another handshake failed\n            // and we're backing off, or because the server timed us out and asks us to\n            // re-handshake: in both cases, make sure that if the handshake succeeds\n            // the next action is a connect.\n            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));\n        }\n\n        _batch = 0;\n\n        // Mark the start of an internal batch.\n        // This is needed because handshake and connect are async.\n        // It may happen that the application calls init() then subscribe()\n        // and the subscribe message is sent before the connect message, if\n        // the subscribe message is not held until the connect message is sent.\n        // So here we start a batch to hold temporarily any message until\n        // the connection is fully established.\n        _internalBatch = true;\n\n        // Save the properties provided by the user, so that\n        // we can reuse them during automatic re-handshake\n        _handshakeProps = handshakeProps;\n        _handshakeCallback = handshakeCallback;\n\n        var version = '1.0';\n\n        // Figure out the transports to send to the server\n        var url = _cometd.getURL();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            version: version,\n            minimumVersion: version,\n            channel: '/meta/handshake',\n            supportedConnectionTypes: transportTypes,\n            advice: {\n                timeout: _advice.timeout,\n                interval: _advice.interval\n            }\n        };\n        // Do not allow the user to override important fields.\n        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, handshakeCallback);\n\n        // Pick up the first available transport as initial transport\n        // since we don't know if the server supports it\n        if (!_transport) {\n            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n            if (!_transport) {\n                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                _cometd._warn(failure);\n                throw failure;\n            }\n        }\n\n        _cometd._debug('Initial transport is', _transport.getType());\n\n        // We started a batch to hold the application messages,\n        // so here we must bypass it and send immediately.\n        _setStatus('handshaking');\n        _cometd._debug('Handshake sent', message);\n        _send(false, [message], false, 'handshake');\n    }\n\n    function _delayedHandshake(delay) {\n        _setStatus('handshaking');\n\n        // We will call _handshake() which will reset _clientId, but we want to avoid\n        // that between the end of this method and the call to _handshake() someone may\n        // call publish() (or other methods that call _queueSend()).\n        _internalBatch = true;\n\n        _delayedSend(function() {\n            _handshake(_handshakeProps, _handshakeCallback);\n        }, delay);\n    }\n\n    function _notifyCallback(callback, message) {\n        try {\n            callback.call(_cometd, message);\n        } catch (x) {\n            var handler = _cometd.onCallbackException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking callback exception handler', x);\n                try {\n                    handler.call(_cometd, x, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of callback exception handler', xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of message callback', x);\n            }\n        }\n    }\n\n    this._getCallback = function(messageId) {\n        return _callbacks[messageId];\n    };\n\n    this._putCallback = function(messageId, callback) {\n        var result = this._getCallback(messageId);\n        if (_isFunction(callback)) {\n            _callbacks[messageId] = callback;\n        }\n        return result;\n    };\n\n    function _handleCallback(message) {\n        var callback = _cometd._getCallback([message.id]);\n        if (_isFunction(callback)) {\n            delete _callbacks[message.id];\n            _notifyCallback(callback, message);\n        }\n    }\n\n    function _handleRemoteCall(message) {\n        var context = _remoteCalls[message.id];\n        delete _remoteCalls[message.id];\n        _cometd._debug('Handling remote call response for', message, 'with context', context);\n        if (context) {\n            // Clear the timeout, if present.\n            var timeout = context.timeout;\n            if (timeout) {\n                Utils.clearTimeout(timeout);\n            }\n\n            var callback = context.callback;\n            if (_isFunction(callback)) {\n                _notifyCallback(callback, message);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _failHandshake(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/handshake', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // Only try again if we haven't been disconnected and\n        // the advice permits us to retry the handshake\n        var retry = !_isDisconnected() && _advice.reconnect !== 'none';\n        if (retry) {\n            _increaseBackoff();\n            _delayedHandshake();\n        } else {\n            _disconnect(true);\n        }\n    }\n\n    function _handshakeResponse(message) {\n        if (message.successful) {\n            // Save clientId, figure out transport, then follow the advice to connect\n            _clientId = message.clientId;\n\n            var url = _cometd.getURL();\n            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);\n            if (newTransport === null) {\n                var failure = 'Could not negotiate transport with server; client=[' +\n                    _transports.findTransportTypes(message.version, _crossDomain, url) +\n                    '], server=[' + message.supportedConnectionTypes + ']';\n                var oldTransport = _cometd.getTransport();\n                _notifyTransportFailure(oldTransport.getType(), null, {\n                    reason: failure,\n                    connectionType: oldTransport.getType(),\n                    transport: oldTransport\n                });\n                _cometd._warn(failure);\n                _disconnect(true);\n                return;\n            } else if (_transport !== newTransport) {\n                _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n                _transport = newTransport;\n            }\n\n            // End the internal batch and allow held messages from the application\n            // to go to the server (see _handshake() where we start the internal batch).\n            _internalBatch = false;\n            _flushBatch();\n\n            // Here the new transport is in place, as well as the clientId, so\n            // the listeners can perform a publish() if they want.\n            // Notify the listeners before the connect below.\n            message.reestablish = _reestablish;\n            _reestablish = true;\n\n            _handleCallback(message);\n            _notifyListeners('/meta/handshake', message);\n\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    _disconnect(true);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failHandshake(message);\n        }\n    }\n\n    function _handshakeFailure(message) {\n        var version = '1.0';\n        var url = _cometd.getURL();\n        var oldTransport = _cometd.getTransport();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n        var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n        if (!newTransport) {\n            _notifyTransportFailure(oldTransport.getType(), null, message.failure);\n            _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');\n            _disconnect(true);\n            _failHandshake(message);\n        } else {\n            _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());\n            _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);\n            _failHandshake(message);\n            _transport = newTransport;\n        }\n    }\n\n    function _failConnect(message) {\n        // Notify the listeners after the status change but before the next action\n        _notifyListeners('/meta/connect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // This may happen when the server crashed, the current clientId\n        // will be invalid, and the server will ask to handshake again\n        // Listeners can call disconnect(), so check the state after they run\n        var action = _isDisconnected() ? 'none' : _advice.reconnect;\n        switch (action) {\n            case 'retry':\n                _delayedConnect();\n                _increaseBackoff();\n                break;\n            case 'handshake':\n                // The current transport may be failed (e.g. network disconnection)\n                // Reset the transports so the new handshake picks up the right one\n                _transports.reset(true);\n                _resetBackoff();\n                _delayedHandshake();\n                break;\n            case 'none':\n                _disconnect(true);\n                break;\n            default:\n                throw 'Unrecognized advice action' + action;\n        }\n    }\n\n    function _connectResponse(message) {\n        _connected = message.successful;\n\n        if (_connected) {\n            _notifyListeners('/meta/connect', message);\n\n            // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n            // and the server will hold the request, so when a response returns\n            // we immediately call the server again (long polling)\n            // Listeners can call disconnect(), so check the state after they run\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    // Wait for the /meta/disconnect to arrive.\n                    _disconnect(false);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failConnect(message);\n        }\n    }\n\n    function _connectFailure(message) {\n        _connected = false;\n        _failConnect(message);\n    }\n\n    function _failDisconnect(message) {\n        _disconnect(true);\n        _handleCallback(message);\n        _notifyListeners('/meta/disconnect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _disconnectResponse(message) {\n        if (message.successful) {\n            // Wait for the /meta/connect to arrive.\n            _disconnect(false);\n            _handleCallback(message);\n            _notifyListeners('/meta/disconnect', message);\n        } else {\n            _failDisconnect(message);\n        }\n    }\n\n    function _disconnectFailure(message) {\n        _failDisconnect(message);\n    }\n\n    function _failSubscribe(message) {\n        var subscriptions = _listeners[message.subscription];\n        if (subscriptions) {\n            for (var i = subscriptions.length - 1; i >= 0; --i) {\n                var subscription = subscriptions[i];\n                if (subscription && !subscription.listener) {\n                    delete subscriptions[i];\n                    _cometd._debug('Removed failed subscription', subscription);\n                    break;\n                }\n            }\n        }\n        _handleCallback(message);\n        _notifyListeners('/meta/subscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _subscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/subscribe', message);\n        } else {\n            _failSubscribe(message);\n        }\n    }\n\n    function _subscribeFailure(message) {\n        _failSubscribe(message);\n    }\n\n    function _failUnsubscribe(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/unsubscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _unsubscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/unsubscribe', message);\n        } else {\n            _failUnsubscribe(message);\n        }\n    }\n\n    function _unsubscribeFailure(message) {\n        _failUnsubscribe(message);\n    }\n\n    function _failMessage(message) {\n        if (!_handleRemoteCall(message)) {\n            _handleCallback(message);\n            _notifyListeners('/meta/publish', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n    }\n\n    function _messageResponse(message) {\n        if (message.data !== undefined) {\n            if (!_handleRemoteCall(message)) {\n                _notifyListeners(message.channel, message);\n                if (_handshakeMessages > 0) {\n                    --_handshakeMessages;\n                    if (_handshakeMessages === 0) {\n                        _cometd._debug('Processed last handshake-delivered message');\n                        _delayedConnect(0);\n                    }\n                }\n            }\n        } else {\n            if (message.successful === undefined) {\n                _cometd._warn('Unknown Bayeux Message', message);\n            } else {\n                if (message.successful) {\n                    _handleCallback(message);\n                    _notifyListeners('/meta/publish', message);\n                } else {\n                    _failMessage(message);\n                }\n            }\n        }\n    }\n\n    function _messageFailure(failure) {\n        _failMessage(failure);\n    }\n\n    function _receive(message) {\n        _unconnectTime = 0;\n\n        message = _applyIncomingExtensions(message);\n        if (message === undefined || message === null) {\n            return;\n        }\n\n        _updateAdvice(message.advice);\n\n        var channel = message.channel;\n        switch (channel) {\n            case '/meta/handshake':\n                _handshakeResponse(message);\n                break;\n            case '/meta/connect':\n                _connectResponse(message);\n                break;\n            case '/meta/disconnect':\n                _disconnectResponse(message);\n                break;\n            case '/meta/subscribe':\n                _subscribeResponse(message);\n                break;\n            case '/meta/unsubscribe':\n                _unsubscribeResponse(message);\n                break;\n            default:\n                _messageResponse(message);\n                break;\n        }\n    }\n\n    /**\n     * Receives a message.\n     * This method is exposed as a public so that extensions may inject\n     * messages simulating that they had been received.\n     */\n    this.receive = _receive;\n\n    _handleMessages = function(rcvdMessages) {\n        _cometd._debug('Received', rcvdMessages);\n\n        for (var i = 0; i < rcvdMessages.length; ++i) {\n            var message = rcvdMessages[i];\n            _receive(message);\n        }\n    };\n\n    _handleFailure = function(conduit, messages, failure) {\n        _cometd._debug('handleFailure', conduit, messages, failure);\n\n        failure.transport = conduit;\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var failureMessage = {\n                id: message.id,\n                successful: false,\n                channel: message.channel,\n                failure: failure\n            };\n            failure.message = message;\n            switch (message.channel) {\n                case '/meta/handshake':\n                    _handshakeFailure(failureMessage);\n                    break;\n                case '/meta/connect':\n                    _connectFailure(failureMessage);\n                    break;\n                case '/meta/disconnect':\n                    _disconnectFailure(failureMessage);\n                    break;\n                case '/meta/subscribe':\n                    failureMessage.subscription = message.subscription;\n                    _subscribeFailure(failureMessage);\n                    break;\n                case '/meta/unsubscribe':\n                    failureMessage.subscription = message.subscription;\n                    _unsubscribeFailure(failureMessage);\n                    break;\n                default:\n                    _messageFailure(failureMessage);\n                    break;\n            }\n        }\n    };\n\n    function _hasSubscriptions(channel) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                if (subscriptions[i]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function _resolveScopedCallback(scope, callback) {\n        var delegate = {\n            scope: scope,\n            method: callback\n        };\n        if (_isFunction(scope)) {\n            delegate.scope = undefined;\n            delegate.method = scope;\n        } else {\n            if (_isString(callback)) {\n                if (!scope) {\n                    throw 'Invalid scope ' + scope;\n                }\n                delegate.method = scope[callback];\n                if (!_isFunction(delegate.method)) {\n                    throw 'Invalid callback ' + callback + ' for scope ' + scope;\n                }\n            } else if (!_isFunction(callback)) {\n                throw 'Invalid callback ' + callback;\n            }\n        }\n        return delegate;\n    }\n\n    function _addListener(channel, scope, callback, isListener) {\n        // The data structure is a map<channel, subscription[]>, where each subscription\n        // holds the callback to be called and its scope.\n\n        var delegate = _resolveScopedCallback(scope, callback);\n        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n        var subscription = {\n            channel: channel,\n            scope: delegate.scope,\n            callback: delegate.method,\n            listener: isListener\n        };\n\n        var subscriptions = _listeners[channel];\n        if (!subscriptions) {\n            subscriptions = [];\n            _listeners[channel] = subscriptions;\n        }\n\n        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.\n        // Note that if:\n        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');\n        // then:\n        // hc==3, a.join()=='a',,'c', a.length==3\n        subscription.id = subscriptions.push(subscription) - 1;\n\n        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n        // For backward compatibility: we used to return [channel, subscription.id]\n        subscription[0] = channel;\n        subscription[1] = subscription.id;\n\n        return subscription;\n    }\n\n    //\n    // PUBLIC API\n    //\n\n    /**\n     * Registers the given transport under the given transport type.\n     * The optional index parameter specifies the \"priority\" at which the\n     * transport is registered (where 0 is the max priority).\n     * If a transport with the same type is already registered, this function\n     * does nothing and returns false.\n     * @param type the transport type\n     * @param transport the transport object\n     * @param index the index at which this transport is to be registered\n     * @return true if the transport has been registered, false otherwise\n     * @see #unregisterTransport(type)\n     */\n    this.registerTransport = function(type, transport, index) {\n        var result = _transports.add(type, transport, index);\n        if (result) {\n            this._debug('Registered transport', type);\n\n            if (_isFunction(transport.registered)) {\n                transport.registered(type, this);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Unregisters the transport with the given transport type.\n     * @param type the transport type to unregister\n     * @return the transport that has been unregistered,\n     * or null if no transport was previously registered under the given transport type\n     */\n    this.unregisterTransport = function(type) {\n        var transport = _transports.remove(type);\n        if (transport !== null) {\n            this._debug('Unregistered transport', type);\n\n            if (_isFunction(transport.unregistered)) {\n                transport.unregistered();\n            }\n        }\n        return transport;\n    };\n\n    this.unregisterTransports = function() {\n        _transports.clear();\n    };\n\n    /**\n     * @return an array of all registered transport types\n     */\n    this.getTransportTypes = function() {\n        return _transports.getTransportTypes();\n    };\n\n    this.findTransport = function(name) {\n        return _transports.find(name);\n    };\n\n    /**\n     * @returns the TransportRegistry object\n     */\n    this.getTransportRegistry = function() {\n        return _transports;\n    };\n\n    /**\n     * Configures the initial Bayeux communication with the Bayeux server.\n     * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n     * of type string containing the URL of the Bayeux server.\n     * @param configuration the configuration object\n     */\n    this.configure = function(configuration) {\n        _configure.call(this, configuration);\n    };\n\n    /**\n     * Configures and establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param configuration the configuration object\n     * @param handshakeProps an object to be merged with the handshake message\n     * @see #configure(configuration)\n     * @see #handshake(handshakeProps)\n     */\n    this.init = function(configuration, handshakeProps) {\n        this.configure(configuration);\n        this.handshake(handshakeProps);\n    };\n\n    /**\n     * Establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param handshakeProps an object to be merged with the handshake message\n     * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n     */\n    this.handshake = function(handshakeProps, handshakeCallback) {\n        _setStatus('disconnected');\n        _reestablish = false;\n        _handshake(handshakeProps, handshakeCallback);\n    };\n\n    /**\n     * Disconnects from the Bayeux server.\n     * It is possible to suggest to attempt a synchronous disconnect, but this feature\n     * may only be available in certain transports (for example, long-polling may support\n     * it, callback-polling certainly does not).\n     * @param sync whether attempt to perform a synchronous disconnect\n     * @param disconnectProps an object to be merged with the disconnect message\n     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n     */\n    this.disconnect = function(sync, disconnectProps, disconnectCallback) {\n        if (_isDisconnected()) {\n            return;\n        }\n\n        if (typeof sync !== 'boolean') {\n            disconnectCallback = disconnectProps;\n            disconnectProps = sync;\n            sync = false;\n        }\n        if (_isFunction(disconnectProps)) {\n            disconnectCallback = disconnectProps;\n            disconnectProps = undefined;\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: '/meta/disconnect'\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, disconnectCallback);\n\n        _setStatus('disconnecting');\n        _send(sync === true, [message], false, 'disconnect');\n    };\n\n    /**\n     * Marks the start of a batch of application messages to be sent to the server\n     * in a single request, obtaining a single response containing (possibly) many\n     * application reply messages.\n     * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n     * If startBatch() is called multiple times, then an equal number of endBatch()\n     * calls must be made to close and send the batch of messages.\n     * @see #endBatch()\n     */\n    this.startBatch = function() {\n        _startBatch();\n    };\n\n    /**\n     * Marks the end of a batch of application messages to be sent to the server\n     * in a single request.\n     * @see #startBatch()\n     */\n    this.endBatch = function() {\n        _endBatch();\n    };\n\n    /**\n     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n     * and {@link #endBatch()} calls.\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n     */\n    this.batch = function(scope, callback) {\n        var delegate = _resolveScopedCallback(scope, callback);\n        this.startBatch();\n        try {\n            delegate.method.call(delegate.scope);\n            this.endBatch();\n        } catch (x) {\n            this._info('Exception during execution of batch', x);\n            this.endBatch();\n            throw x;\n        }\n    };\n\n    /**\n     * Adds a listener for bayeux messages, performing the given callback in the given scope\n     * when a message for the given channel arrives.\n     * @param channel the channel the listener is interested to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @returns the subscription handle to be passed to {@link #removeListener(object)}\n     * @see #removeListener(subscription)\n     */\n    this.addListener = function(channel, scope, callback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n\n        return _addListener(channel, scope, callback, true);\n    };\n\n    /**\n     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @see #addListener(channel, scope, callback)\n     */\n    this.removeListener = function(subscription) {\n        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n        if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n            throw 'Invalid argument: expected subscription, not ' + subscription;\n        }\n\n        _removeListener(subscription);\n    };\n\n    /**\n     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n     * {@link #subscribe(channel, scope, callback)}.\n     */\n    this.clearListeners = function() {\n        _listeners = {};\n    };\n\n    /**\n     * Subscribes to the given channel, performing the given callback in the given scope\n     * when a message for the channel arrives.\n     * @param channel the channel to subscribe to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @param subscribeProps an object to be merged with the subscribe message\n     * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n     * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n     */\n    this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        // Normalize arguments\n        if (_isFunction(scope)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = callback;\n            callback = scope;\n            scope = undefined;\n        }\n        if (_isFunction(subscribeProps)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = undefined;\n        }\n\n        // Only send the message to the server if this client has not yet subscribed to the channel\n        var send = !_hasSubscriptions(channel);\n\n        var subscription = _addListener(channel, scope, callback, false);\n\n        if (send) {\n            // Send the subscription message after the subscription registration to avoid\n            // races where the server would send a message to the subscribers, but here\n            // on the client the subscription has not been added yet to the data structures\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/subscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, subscribeCallback);\n\n            _queueSend(message);\n        }\n\n        return subscription;\n    };\n\n    /**\n     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @param unsubscribeProps an object to be merged with the unsubscribe message\n     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n     */\n    this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(unsubscribeProps)) {\n            unsubscribeCallback = unsubscribeProps;\n            unsubscribeProps = undefined;\n        }\n\n        // Remove the local listener before sending the message\n        // This ensures that if the server fails, this client does not get notifications\n        this.removeListener(subscription);\n\n        var channel = subscription.channel;\n        // Only send the message to the server if this client unsubscribes the last subscription\n        if (!_hasSubscriptions(channel)) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/unsubscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, unsubscribeCallback);\n\n            _queueSend(message);\n        }\n    };\n\n    this.resubscribe = function(subscription, subscribeProps) {\n        _removeSubscription(subscription);\n        if (subscription) {\n            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n        }\n        return undefined;\n    };\n\n    /**\n     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n     */\n    this.clearSubscriptions = function() {\n        _clearSubscriptions();\n    };\n\n    /**\n     * Publishes a message on the given channel, containing the given content.\n     * @param channel the channel to publish the message to\n     * @param content the content of the message\n     * @param publishProps an object to be merged with the publish message\n     * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n     */\n    this.publish = function(channel, content, publishProps, publishCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (/^\\/meta\\//.test(channel)) {\n            throw 'Illegal argument: cannot publish to meta channels';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            publishCallback = content;\n            content = publishProps = {};\n        } else if (_isFunction(publishProps)) {\n            publishCallback = publishProps;\n            publishProps = {};\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, publishCallback);\n\n        _queueSend(message);\n    };\n\n    this.remoteCall = function(target, content, timeout, callback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(target)) {\n            throw 'Illegal argument type: target must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            callback = content;\n            content = {};\n            timeout = _config.maxNetworkDelay;\n        } else if (_isFunction(timeout)) {\n            callback = timeout;\n            timeout = _config.maxNetworkDelay;\n        }\n\n        if (typeof timeout !== 'number') {\n            throw 'Illegal argument type: timeout must be a number';\n        }\n\n        if (!target.match(/^\\//)) {\n            target = '/' + target;\n        }\n        var channel = '/service' + target;\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n\n        var context = {\n            callback: callback\n        };\n        if (timeout > 0) {\n            context.timeout = Utils.setTimeout(_cometd, function() {\n                _cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');\n                _failMessage({\n                    id: bayeuxMessage.id,\n                    error: '406::timeout',\n                    successful: false,\n                    failure: {\n                        message : bayeuxMessage,\n                        reason: 'Remote Call Timeout'\n                    }\n                });\n            }, timeout);\n            _cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');\n        }\n        _remoteCalls[bayeuxMessage.id] = context;\n\n        _queueSend(bayeuxMessage);\n    };\n\n    /**\n     * Returns a string representing the status of the bayeux communication with the Bayeux server.\n     */\n    this.getStatus = function() {\n        return _status;\n    };\n\n    /**\n     * Returns whether this instance has been disconnected.\n     */\n    this.isDisconnected = _isDisconnected;\n\n    /**\n     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * Default value is 1 second, which means if there is a persistent failure the retries will happen\n     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n     * @param period the backoff period to set\n     * @see #getBackoffIncrement()\n     */\n    this.setBackoffIncrement = function(period) {\n        _config.backoffIncrement = period;\n    };\n\n    /**\n     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * @see #setBackoffIncrement(period)\n     */\n    this.getBackoffIncrement = function() {\n        return _config.backoffIncrement;\n    };\n\n    /**\n     * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n     */\n    this.getBackoffPeriod = function() {\n        return _backoff;\n    };\n\n    /**\n     * Increases the backoff period up to the maximum value configured.\n     * @returns the backoff period after increment\n     * @see getBackoffIncrement\n     */\n    this.increaseBackoffPeriod = function() {\n        return _increaseBackoff();\n    };\n\n    /**\n     * Resets the backoff period to zero.\n     */\n    this.resetBackoffPeriod = function() {\n        _resetBackoff();\n    };\n\n    /**\n     * Sets the log level for console logging.\n     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n     * less verbose to more verbose.\n     * @param level the log level string\n     */\n    this.setLogLevel = function(level) {\n        _config.logLevel = level;\n    };\n\n    /**\n     * Registers an extension whose callbacks are called for every incoming message\n     * (that comes from the server to this client implementation) and for every\n     * outgoing message (that originates from this client implementation for the\n     * server).\n     * The format of the extension object is the following:\n     * <pre>\n     * {\n     *     incoming: function(message) { ... },\n     *     outgoing: function(message) { ... }\n     * }\n     * </pre>\n     * Both properties are optional, but if they are present they will be called\n     * respectively for each incoming message and for each outgoing message.\n     * @param name the name of the extension\n     * @param extension the extension to register\n     * @return true if the extension was registered, false otherwise\n     * @see #unregisterExtension(name)\n     */\n    this.registerExtension = function(name, extension) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var existing = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var existingExtension = _extensions[i];\n            if (existingExtension.name === name) {\n                existing = true;\n                break;\n            }\n        }\n        if (!existing) {\n            _extensions.push({\n                name: name,\n                extension: extension\n            });\n            this._debug('Registered extension', name);\n\n            // Callback for extensions\n            if (_isFunction(extension.registered)) {\n                extension.registered(name, this);\n            }\n\n            return true;\n        } else {\n            this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n            return false;\n        }\n    };\n\n    /**\n     * Unregister an extension previously registered with\n     * {@link #registerExtension(name, extension)}.\n     * @param name the name of the extension to unregister.\n     * @return true if the extension was unregistered, false otherwise\n     */\n    this.unregisterExtension = function(name) {\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var unregistered = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                _extensions.splice(i, 1);\n                unregistered = true;\n                this._debug('Unregistered extension', name);\n\n                // Callback for extensions\n                var ext = extension.extension;\n                if (_isFunction(ext.unregistered)) {\n                    ext.unregistered();\n                }\n\n                break;\n            }\n        }\n        return unregistered;\n    };\n\n    /**\n     * Find the extension registered with the given name.\n     * @param name the name of the extension to find\n     * @return the extension found or null if no extension with the given name has been registered\n     */\n    this.getExtension = function(name) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                return extension.extension;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns the name assigned to this CometD object, or the string 'default'\n     * if no name has been explicitly passed as parameter to the constructor.\n     */\n    this.getName = function() {\n        return _name;\n    };\n\n    /**\n     * Returns the clientId assigned by the Bayeux server during handshake.\n     */\n    this.getClientId = function() {\n        return _clientId;\n    };\n\n    /**\n     * Returns the URL of the Bayeux server.\n     */\n    this.getURL = function() {\n        if (_transport) {\n            var url = _transport.getURL();\n            if (url) {\n                return url;\n            }\n            url = _config.urls[_transport.getType()];\n            if (url) {\n                return url;\n            }\n        }\n        return _config.url;\n    };\n\n    this.getTransport = function() {\n        return _transport;\n    };\n\n    this.getConfiguration = function() {\n        return this._mixin(true, {}, _config);\n    };\n\n    this.getAdvice = function() {\n        return this._mixin(true, {}, _advice);\n    };\n};\n","var Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports.\n */\nmodule.exports = function Transport() {\n    var _type;\n    var _cometd;\n    var _url;\n\n    /**\n     * Function invoked just after a transport has been successfully registered.\n     * @param type the type of transport (for example 'long-polling')\n     * @param cometd the cometd object this transport has been registered to\n     * @see #unregistered()\n     */\n    this.registered = function(type, cometd) {\n        _type = type;\n        _cometd = cometd;\n    };\n\n    /**\n     * Function invoked just after a transport has been successfully unregistered.\n     * @see #registered(type, cometd)\n     */\n    this.unregistered = function() {\n        _type = null;\n        _cometd = null;\n    };\n\n    this._debug = function() {\n        _cometd._debug.apply(_cometd, arguments);\n    };\n\n    this._mixin = function() {\n        return _cometd._mixin.apply(_cometd, arguments);\n    };\n\n    this.getConfiguration = function() {\n        return _cometd.getConfiguration();\n    };\n\n    this.getAdvice = function() {\n        return _cometd.getAdvice();\n    };\n\n    this.setTimeout = function(funktion, delay) {\n        return Utils.setTimeout(_cometd, funktion, delay);\n    };\n\n    this.clearTimeout = function(handle) {\n        Utils.clearTimeout(handle);\n    };\n\n    /**\n     * Converts the given response into an array of bayeux messages\n     * @param response the response to convert\n     * @return an array of bayeux messages obtained by converting the response\n     */\n    this.convertToMessages = function(response) {\n        if (Utils.isString(response)) {\n            try {\n                return JSON.parse(response);\n            } catch (x) {\n                this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n                throw x;\n            }\n        }\n        if (Utils.isArray(response)) {\n            return response;\n        }\n        if (response === undefined || response === null) {\n            return [];\n        }\n        if (response instanceof Object) {\n            return [response];\n        }\n        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n    };\n\n    /**\n     * Returns whether this transport can work for the given version and cross domain communication case.\n     * @param version a string indicating the transport version\n     * @param crossDomain a boolean indicating whether the communication is cross domain\n     * @param url the URL to connect to\n     * @return true if this transport can work for the given version and cross domain communication case,\n     * false otherwise\n     */\n    this.accept = function(version, crossDomain, url) {\n        throw 'Abstract';\n    };\n\n    /**\n     * Returns the type of this transport.\n     * @see #registered(type, cometd)\n     */\n    this.getType = function() {\n        return _type;\n    };\n\n    this.getURL = function() {\n        return _url;\n    };\n\n    this.setURL = function(url) {\n        _url = url;\n    };\n\n    this.send = function(envelope, metaConnect) {\n        throw 'Abstract';\n    };\n\n    this.reset = function(init) {\n        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n    };\n\n    this.abort = function() {\n        this._debug('Transport', _type, 'aborted');\n    };\n\n    this.toString = function() {\n        return this.getType();\n    };\n};\n\nmodule.exports.derive = function(baseObject) {\n    function F() {\n    }\n\n    F.prototype = baseObject;\n    return new F();\n};\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports based on requests.\n * The key responsibility is to allow at most 2 outstanding requests to the server,\n * to avoid that requests are sent behind a long poll.\n * To achieve this, we have one reserved request for the long poll, and all other\n * requests are serialized one after the other.\n */\nmodule.exports = function RequestTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _requestIds = 0;\n    var _metaConnectRequest = null;\n    var _requests = [];\n    var _envelopes = [];\n\n    function _coalesceEnvelopes(envelope) {\n        while (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes[0];\n            var newEnvelope = envelopeAndRequest[0];\n            var newRequest = envelopeAndRequest[1];\n            if (newEnvelope.url === envelope.url &&\n                newEnvelope.sync === envelope.sync) {\n                _envelopes.shift();\n                envelope.messages = envelope.messages.concat(newEnvelope.messages);\n                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n                continue;\n            }\n            break;\n        }\n    }\n\n    function _transportSend(envelope, request) {\n        this.transportSend(envelope, request);\n        request.expired = false;\n\n        if (!envelope.sync) {\n            var maxDelay = this.getConfiguration().maxNetworkDelay;\n            var delay = maxDelay;\n            if (request.metaConnect === true) {\n                delay += this.getAdvice().timeout;\n            }\n\n            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n            var self = this;\n            request.timeout = self.setTimeout(function() {\n                request.expired = true;\n                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n                var failure = {\n                    reason: errorMessage\n                };\n                var xhr = request.xhr;\n                failure.httpCode = self.xhrStatus(xhr);\n                self.abortXHR(xhr);\n                self._debug(errorMessage);\n                self.complete(request, false, request.metaConnect);\n                envelope.onFailure(xhr, envelope.messages, failure);\n            }, delay);\n        }\n    }\n\n    function _queueSend(envelope) {\n        var requestId = ++_requestIds;\n        var request = {\n            id: requestId,\n            metaConnect: false,\n            envelope: envelope\n        };\n\n        // Consider the metaConnect requests which should always be present\n        if (_requests.length < this.getConfiguration().maxConnections - 1) {\n            _requests.push(request);\n            _transportSend.call(this, envelope, request);\n        } else {\n            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n            _envelopes.push([envelope, request]);\n        }\n    }\n\n    function _metaConnectComplete(request) {\n        var requestId = request.id;\n        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);\n        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n            throw 'Longpoll request mismatch, completing request ' + requestId;\n        }\n\n        // Reset metaConnect request\n        _metaConnectRequest = null;\n    }\n\n    function _complete(request, success) {\n        var index = Utils.inArray(request, _requests);\n        // The index can be negative if the request has been aborted\n        if (index >= 0) {\n            _requests.splice(index, 1);\n        }\n\n        if (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes.shift();\n            var nextEnvelope = envelopeAndRequest[0];\n            var nextRequest = envelopeAndRequest[1];\n            this._debug('Transport dequeued request', nextRequest.id);\n            if (success) {\n                if (this.getConfiguration().autoBatch) {\n                    _coalesceEnvelopes.call(this, nextEnvelope);\n                }\n                _queueSend.call(this, nextEnvelope);\n                this._debug('Transport completed request', request.id, nextEnvelope);\n            } else {\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                var self = this;\n                self.setTimeout(function() {\n                    self.complete(nextRequest, false, nextRequest.metaConnect);\n                    var failure = {\n                        reason: 'Previous request failed'\n                    };\n                    var xhr = nextRequest.xhr;\n                    failure.httpCode = self.xhrStatus(xhr);\n                    nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n                }, 0);\n            }\n        }\n    }\n\n    _self.complete = function(request, success, metaConnect) {\n        if (metaConnect) {\n            _metaConnectComplete.call(this, request);\n        } else {\n            _complete.call(this, request, success);\n        }\n    };\n\n    /**\n     * Performs the actual send depending on the transport type details.\n     * @param envelope the envelope to send\n     * @param request the request information\n     */\n    _self.transportSend = function(envelope, request) {\n        throw 'Abstract';\n    };\n\n    _self.transportSuccess = function(envelope, request, responses) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, true, request.metaConnect);\n            if (responses && responses.length > 0) {\n                envelope.onSuccess(responses);\n            } else {\n                envelope.onFailure(request.xhr, envelope.messages, {\n                    httpCode: 204\n                });\n            }\n        }\n    };\n\n    _self.transportFailure = function(envelope, request, failure) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, false, request.metaConnect);\n            envelope.onFailure(request.xhr, envelope.messages, failure);\n        }\n    };\n\n    function _metaConnectSend(envelope) {\n        if (_metaConnectRequest !== null) {\n            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n        }\n\n        var requestId = ++_requestIds;\n        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);\n        var request = {\n            id: requestId,\n            metaConnect: true,\n            envelope: envelope\n        };\n        _transportSend.call(this, envelope, request);\n        _metaConnectRequest = request;\n    }\n\n    _self.send = function(envelope, metaConnect) {\n        if (metaConnect) {\n            _metaConnectSend.call(this, envelope);\n        } else {\n            _queueSend.call(this, envelope);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        for (var i = 0; i < _requests.length; ++i) {\n            var request = _requests[i];\n            if (request) {\n                this._debug('Aborting request', request);\n                if (!this.abortXHR(request.xhr)) {\n                    this.transportFailure(request.envelope, request, {reason: 'abort'});\n                }\n            }\n        }\n        if (_metaConnectRequest) {\n            this._debug('Aborting metaConnect request', _metaConnectRequest);\n            if (!this.abortXHR(_metaConnectRequest.xhr)) {\n                this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});\n            }\n        }\n        this.reset(true);\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _metaConnectRequest = null;\n        _requests = [];\n        _envelopes = [];\n    };\n\n    _self.abortXHR = function(xhr) {\n        if (xhr) {\n            try {\n                var state = xhr.readyState;\n                xhr.abort();\n                return state !== XMLHttpRequest.UNSENT;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return false;\n    };\n\n    _self.xhrStatus = function(xhr) {\n        if (xhr) {\n            try {\n                return xhr.status;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return -1;\n    };\n\n    return _self;\n};\n","var Transport = require('./Transport');\nvar RequestTransport = require('./RequestTransport');\n\nmodule.exports = function LongPollingTransport() {\n    var _super = new RequestTransport();\n    var _self = Transport.derive(_super);\n    // By default, support cross domain\n    var _supportsCrossDomain = true;\n\n    _self.accept = function(version, crossDomain, url) {\n        return _supportsCrossDomain || !crossDomain;\n    };\n\n    _self.xhrSend = function(packet) {\n        throw 'Abstract';\n    };\n\n    _self.transportSend = function(envelope, request) {\n        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n        var self = this;\n        try {\n            var sameStack = true;\n            request.xhr = this.xhrSend({\n                transport: this,\n                url: envelope.url,\n                sync: envelope.sync,\n                headers: this.getConfiguration().requestHeaders,\n                body: JSON.stringify(envelope.messages),\n                onSuccess: function(response) {\n                    self._debug('Transport', self.getType(), 'received response', response);\n                    var success = false;\n                    try {\n                        var received = self.convertToMessages(response);\n                        if (received.length === 0) {\n                            _supportsCrossDomain = false;\n                            self.transportFailure(envelope, request, {\n                                httpCode: 204\n                            });\n                        } else {\n                            success = true;\n                            self.transportSuccess(envelope, request, received);\n                        }\n                    } catch (x) {\n                        self._debug(x);\n                        if (!success) {\n                            _supportsCrossDomain = false;\n                            var failure = {\n                                exception: x\n                            };\n                            failure.httpCode = self.xhrStatus(request.xhr);\n                            self.transportFailure(envelope, request, failure);\n                        }\n                    }\n                },\n                onError: function(reason, exception) {\n                    self._debug('Transport', self.getType(), 'received error', reason, exception);\n                    _supportsCrossDomain = false;\n                    var failure = {\n                        reason: reason,\n                        exception: exception\n                    };\n                    failure.httpCode = self.xhrStatus(request.xhr);\n                    if (sameStack) {\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        self.setTimeout(function() {\n                            self.transportFailure(envelope, request, failure);\n                        }, 0);\n                    } else {\n                        self.transportFailure(envelope, request, failure);\n                    }\n                }\n            });\n            sameStack = false;\n        } catch (x) {\n            _supportsCrossDomain = false;\n            // Keep the semantic of calling response callbacks asynchronously after the request\n            self.setTimeout(function() {\n                self.transportFailure(envelope, request, {\n                    exception: x\n                });\n            }, 0);\n        }\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _supportsCrossDomain = true;\n    };\n\n    return _self;\n};\n","var TRANSPORT_TYPES = require('../TransportTypes');\n\nvar FetchLongPollingTransport = require('../FetchLongPollingTransport');\nvar WebSocketTransport = require('../WebSocketTransport');\n\n// Use node-fetch implementation\nmodule.exports.fetch = FetchLongPollingTransport.fetch = function() {\n  return fetch.apply(window, arguments);\n};\n\n// Use node-websocket implementation\nmodule.exports.WebSocket = WebSocketTransport.WebSocket = typeof WebSocket === 'undefined' ? null : WebSocket;\n\n/**\n * Long polling transport layer\n */\nvar WEBSOCKET_TRANSPORT = {\n  type: TRANSPORT_TYPES.WEBSOCKET,\n  Transport: WebSocketTransport\n};\nmodule.exports.WEBSOCKET_TRANSPORT = WEBSOCKET_TRANSPORT;\n\n/**\n * Long polling transport layer\n */\nvar LONG_POLLING_TRANSPORT = {\n  type: TRANSPORT_TYPES.LONG_POLLING,\n  Transport: FetchLongPollingTransport\n};\nmodule.exports.LONG_POLLING_TRANSPORT = LONG_POLLING_TRANSPORT;\n\n/**\n * CometD Transports Layers map\n */\nvar ALL = [\n  WEBSOCKET_TRANSPORT,\n  LONG_POLLING_TRANSPORT\n];\nmodule.exports.ALL = ALL;\n","module.exports.CometD = require('./lib/CometD')\nmodule.exports.Transports = require('./lib/browser/Transports')\n","import { Service } from './core'\n/**\n * Data aggregation\n *\n * Provides data aggregation over time and across different items\n *  User devices push items data on developer-defined categories\n *  This service automatically aggregates the data\n * Raw data is not available for reading, only the generated aggregation result\n *\n * */\n/**\n * User API for item aggregation\n *\n * Users can push data and be notified of aggregated data.\n * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.\n * @access public\n * */\nexport class Aggreg extends Service {\n\t/**\n\t * Get default deployment id associated to Aggreg service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'aggreg_0'\n\t}\n\t/**\n\t * Pushes some data\n\t *\n\t * Pushes the given data.\n\t * All the items are processed according to the defined rules.\n\t * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.\n\t * */\n\tpush({items,owner}) { return this.$publish('push', {items,owner})}\n}\n/**\n * Data stacks\n *\n * Stacks are a per-user named persistent queue of data\n *  An administrator creates a stack service\n *  End-users can push data on an arbitrary number of their own arbitrary named stacks\n * */\n/**\n * Data stack user API\n *\n * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.\n * Stack names are arbitrary and do not need to be explicitly initialized.\n * @access public\n * */\nexport class Stack extends Service {\n\t/**\n\t * Get default deployment id associated to Stack service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'stack_0'\n\t}\n\t/**\n\t * Lists the listeners\n\t *\n\t * Returns the whole list of listeners for the given stack.\n\t * */\n\tgetListeners({stack,owner}) { return this.$publish('getListeners', {stack,owner})}\n\t/**\n\t * Lists content\n\t *\n\t * Returns a paginated list of contents for the given stack.\n\t * Content is sorted according to the statically configured order.\n\t * */\n\tlist({stack,owner,page}) { return this.$publish('list', {stack,owner,page})}\n\t/**\n\t * Empties a stack\n\t *\n\t * Removes all items from the given stack.\n\t * */\n\tpurge({stack,owner}) { return this.$publish('purge', {stack,owner})}\n\t/**\n\t * Pushes an item\n\t *\n\t * Pushes an item onto the given stack.\n\t * The stack does not need to be created.\n\t * */\n\tpush({stack,data,owner}) { return this.$publish('push', {stack,data,owner})}\n\t/**\n\t * Removes items\n\t *\n\t * Removes the item with the given guid from the given stack.\n\t * */\n\tremove({guids,stack,owner}) { return this.$publish('remove', {guids,stack,owner})}\n\t/**\n\t * Sets the listeners\n\t *\n\t * Sets the listeners for the given stack.\n\t * */\n\tsetListeners({listeners,stack,owner}) { return this.$publish('setListeners', {listeners,stack,owner})}\n\t/**\n\t * Updates an item\n\t *\n\t * Updates an existing item of the given stack.\n\t * The item MUST exist prior to the call.\n\t * */\n\tupdate({guid,stack,data,owner}) { return this.$publish('update', {guid,stack,data,owner})}\n}\n/**\n * Echo\n *\n * Echo\n * */\n/**\n * Echo service\n *\n * Simple echo service, for development purposes.\n * @access public\n * */\nexport class Echo extends Service {\n\t/**\n\t * Get default deployment id associated to Echo service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'echo_0'\n\t}\n\t/**\n\t * Echoes an object\n\t *\n\t * Echoes an object: the server will echo that object on channel 'echo' for the current user.\n\t * */\n\techo(parameter) { return this.$publish('echo', parameter)}\n}\n/**\n * Game engine\n *\n * Abstract Game Engine\n *  Concrete game engines are remote cometd clients or internal macros\n * */\n/**\n * User API for games\n *\n * Users can list, start, join games, and play.\n * @access public\n * */\nexport class Game extends Service {\n\t/**\n\t * Get default deployment id associated to Game service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Lists game types\n\t *\n\t * Returns the list of game types supported by the server and the currently registered game engines.\n\t * */\n\tavailable() { return this.$publish('available', {})}\n\t/**A user joins a game*/\n\tjoin({role,gameId,userId,userName}) { return this.$publish('join', {role,gameId,userId,userName})}\n\t/**Organizes a game*/\n\torganize({type,owner,options}) { return this.$publish('organize', {type,owner,options})}\n\t/**Gives some command to the game engine*/\n\tplay({gameId,userId,data}) { return this.$publish('play', {gameId,userId,data})}\n\t/**Starts a game*/\n\tstart({gameId}) { return this.$publish('start', {gameId})}\n\t/**A user cancels joining a game*/\n\tunjoin({role,gameId,userId,userName}) { return this.$publish('unjoin', {role,gameId,userId,userName})}\n}\n/**\n * Game Engine API\n *\n * The Game Engine API is for game engine clients, not end-users.\n * @access public\n * */\nexport class GameEngine extends Service {\n\t/**\n\t * Get default deployment id associated to GameEngine service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Notify the result for a join request\n\t *\n\t * A Game Engine notifies the STR of the result of a join request that it received on join_callback\n\t * */\n\tjoin_result({msgId,payload,error,callerId}) { return this.$publish('join_result', {msgId,payload,error,callerId})}\n\t/**\n\t * Notify the result for an organization request\n\t *\n\t * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback\n\t * */\n\torganize_result({msgId,payload,error,callerId}) { return this.$publish('organize_result', {msgId,payload,error,callerId})}\n\t/**\n\t * Registers a game engine\n\t *\n\t * A client registers itself to the STR as a Game Engine.\n\t * The STR may, from now on, dispatch game of the given game type to said client.\n\t * Unregistration is done automatically on logoff.\n\t * */\n\tregister({maxGames,gameInfo,location}) { return this.$publish('register', {maxGames,gameInfo,location})}\n\t/**\n\t * Notify the result for a start request\n\t *\n\t * A Game Engine notifies the STR of the result of a start request that it received on start_callback\n\t * */\n\tstart_result({gameId}) { return this.$publish('start_result', {gameId})}\n\t/**\n\t * Notify a game event\n\t *\n\t * A Game Engine notifies the STR of some arbitrary game event.\n\t * */\n\tstate({status,gameId,data}) { return this.$publish('state', {status,gameId,data})}\n\t/**\n\t * Notify the result for an unjoin request\n\t *\n\t * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback\n\t * */\n\tunjoin_result({msgId,payload,error,callerId}) { return this.$publish('unjoin_result', {msgId,payload,error,callerId})}\n}\n/**\n * Generic Data Access\n *\n * Generic Data Access Service : NoSQL storage\n * */\n/**\n * GDA User API\n *\n * User API for Generic Data Access.\n * The data are stored on a per-user basis.\n * Users can put, get, list their data.\n * @access public\n * */\nexport class Gda extends Service {\n\t/**\n\t * Get default deployment id associated to Gda service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'gda_0'\n\t}\n\t/**\n\t * Asks for a data row\n\t *\n\t * Returns a full data row.\n\t * */\n\tget({table,key,owner}) { return this.$publish('get', {table,key,owner})}\n\t/**\n\t * Asks for a data cell\n\t *\n\t * Returns a precise list of cells from a column in a data row.\n\t * */\n\tgetCells({table,key,key2,owner,column}) { return this.$publish('getCells', {table,key,key2,owner,column})}\n\t/**\n\t * Increments an integer value\n\t *\n\t * Increments a cell 64-bit signed integer value and returns the result in the data field.\n\t * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.\n\t * */\n\tinc({table,data,key,key2,owner,column}) { return this.$publish('inc', {table,data,key,key2,owner,column})}\n\t/**\n\t * Asks for a list of rows\n\t *\n\t * Returns a paginated list of rows from the given table.\n\t * */\n\tlist({columns,table,owner,page}) { return this.$publish('list', {columns,table,owner,page})}\n\t/**\n\t * Puts some data into a cell\n\t *\n\t * Creates or replaces the contents of a particular cell.\n\t * */\n\tput({table,data,key,key2,owner,column}) { return this.$publish('put', {table,data,key,key2,owner,column})}\n\t/**\n\t * Puts several rows\n\t *\n\t * Creates or replaces the (maybe partial) contents of a collection of rows.\n\t * This method only creates or replaces cells for non-null input values.\n\t * */\n\tputs({rows,table,owner}) { return this.$publish('puts', {rows,table,owner})}\n\t/**\n\t * Asks for a range of rows\n\t *\n\t * Returns a paginated range of rows from the given table.\n\t * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n\t * You can specify partial keys for the start and stop fields.\n\t * */\n\trange({columns,start,table,stop,owner,page}) { return this.$publish('range', {columns,start,table,stop,owner,page})}\n\t/**\n\t * Removes one cell inside a column of a row\n\t *\n\t * Removes only one cell of the given column of the given row from the given table.\n\t * */\n\tremoveCell({table,key,key2,owner,column}) { return this.$publish('removeCell', {table,key,key2,owner,column})}\n\t/**\n\t * Removes one full column of a row\n\t *\n\t * Removes all cells of the given column of the given row from the given table.\n\t * */\n\tremoveColumn({table,key,owner,column}) { return this.$publish('removeColumn', {table,key,owner,column})}\n\t/**\n\t * Removes a range of rows\n\t *\n\t * Removes the specified columns of the given range of rows from the given table.\n\t * */\n\tremoveRange({columns,start,table,stop,owner}) { return this.$publish('removeRange', {columns,start,table,stop,owner})}\n\t/**\n\t * Removes one full row\n\t *\n\t * Removes all columns of the given row from the given table.\n\t * */\n\tremoveRow({table,key,owner}) { return this.$publish('removeRow', {table,key,owner})}\n}\n/**\n * Groups Management\n *\n * Groups management for users, grants on resources, remote commands on devices\n *  This is where you can configure rights for any resource\n *\n * */\n/**\n * User API for remote control\n *\n * @access public\n * */\nexport class Remoting extends Service {\n\t/**\n\t * Get default deployment id associated to Remoting service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds a listener\n\t *\n\t * A user requests notifications from a device owned by anyone who granted him the right authorizations.\n\t * Whenever the device calls 'notify', notifications will be sent to the caller of this verb.\n\t * */\n\taddListener({resource,fromResource,cmd,from,data,owner}) { return this.$publish('addListener', {resource,fromResource,cmd,from,data,owner})}\n\t/**Response to 'getCapabilities'*/\n\tcapabilities({askingResource,capabilities,answeringResource}) { return this.$publish('capabilities', {askingResource,capabilities,answeringResource})}\n\t/**\n\t * Executes a command\n\t *\n\t * A user executes a command on a device owned by anyone who granted him the right authorizations.\n\t * The command is issued on channel 'command'\n\t * */\n\texecute({resource,cmd,data,owner}) { return this.$publish('execute', {resource,cmd,data,owner})}\n\t/**\n\t * Requests capabilities\n\t *\n\t * A user requests all his devices for the whole list of their capabilities.\n\t * Devices are expected to answer on channel 'capabilities'\n\t * */\n\tgetCapabilities() { return this.$publish('getCapabilities', {})}\n\t/**\n\t * Notifies of some event\n\t *\n\t * A device notifies the registered users/devices on this channel.\n\t * The server forwards the notification to said users.\n\t * */\n\tnotify({resource,fromResource,cmd,from,data,owner}) { return this.$publish('notify', {resource,fromResource,cmd,from,data,owner})}\n\t/**\n\t * Pings devices\n\t *\n\t * A user requests all devices (of all owners) on which he has authorizations to respond on channel 'pong'\n\t * */\n\tping({action}) { return this.$publish('ping', {action})}\n\t/**Response to ping*/\n\tpong({user,resource,available,uid,owner,action}) { return this.$publish('pong', {user,resource,available,uid,owner,action})}\n\t/**\n\t * Removes a listener\n\t *\n\t * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations\n\t * */\n\tremoveListener({resource,fromResource,cmd,from,data,owner}) { return this.$publish('removeListener', {resource,fromResource,cmd,from,data,owner})}\n}\n/**\n * User API for groups and rights.\n *\n * Groups are stored per user.\n * This means that two users can own a group with the same identifier. A couple (owner, group) is needed to uniquely identify a group inside a group management service.\n * The triplet (deploymentId, owner, group) is actually needed to fully qualify a group outside of the scope of this service.\n * @access public\n * */\nexport class GroupManagement extends Service {\n\t/**\n\t * Get default deployment id associated to GroupManagement service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds me to a group\n\t *\n\t * Adds me (the caller) to a group.\n\t * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\taddMe({group,owner}) { return this.$publish('addMe', {group,owner})}\n\t/**\n\t * Adds a user to a group\n\t *\n\t * Adds the given user to the given group.\n\t * Addition may fail if the given group does not already exist.\n\t * */\n\taddUser({user,group,owner}) { return this.$publish('addUser', {user,group,owner})}\n\t/**Adds users to a group*/\n\taddUsers({users,group,owner}) { return this.$publish('addUsers', {users,group,owner})}\n\t/**\n\t * Lists my owned groups, with details\n\t *\n\t * Returns the whole list of groups owned by the current user, with their members\n\t * */\n\tallGroups({owner}) { return this.$publish('allGroups', {owner})}\n\t/**\n\t * Creates a group\n\t *\n\t * Creates a group owned by the current user.\n\t * Group creation may fail if the group already exists.\n\t * */\n\tcreateGroup({group,groupName,owner}) { return this.$publish('createGroup', {group,groupName,owner})}\n\t/**\n\t * Removes a group\n\t *\n\t * Removes the given group owned by the current user or the given owner.\n\t * Also removes all grants to that group.\n\t * */\n\tdelGroup({group,owner}) { return this.$publish('delGroup', {group,owner})}\n\t/**Removes a user from a group*/\n\tdelUser({user,group,owner}) { return this.$publish('delUser', {user,group,owner})}\n\t/**Removes users from a group*/\n\tdelUsers({users,group,groupName,owner}) { return this.$publish('delUsers', {users,group,groupName,owner})}\n\t/**\n\t * Tests for a group's existence\n\t *\n\t * Returns whether a group exists or not.\n\t * */\n\texists({group,owner}) { return this.$publish('exists', {group,owner})}\n\t/**\n\t * Grants a right to a group\n\t *\n\t * The granting API does not do any check when storing permissions.\n\t * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.\n\t * */\n\tgrant({resource,group,owner,action}) { return this.$publish('grant', {resource,group,owner,action})}\n\t/**\n\t * Lists the group users\n\t *\n\t * Returns the whole list of users configured inside the given group.\n\t * */\n\tgroupUsers({group,owner}) { return this.$publish('groupUsers', {group,owner})}\n\t/**\n\t * Lists my owned groups\n\t *\n\t * Returns the whole list of groups owned by the current user\n\t * */\n\tgroups({owner}) { return this.$publish('groups', {owner})}\n\t/**\n\t * Lists rights for a group\n\t *\n\t * This API lists explicitly configured rights.\n\t * Effective rights include configured rights, implicit rights and inherited rights.\n\t * */\n\tlistGrants({group,owner}) { return this.$publish('listGrants', {group,owner})}\n\t/**\n\t * Lists presences for a group\n\t *\n\t * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.\n\t * The current implementation does not include information about the particular devices users are connected with.\n\t * If a user is connected twice with two different devices, two identical entries will be returned.\n\t * */\n\tlistPresences({group,owner}) { return this.$publish('listPresences', {group,owner})}\n\t/**\n\t * Tests membership\n\t *\n\t * Tests whether I (the caller) am a member of the given group.\n\t * This verb exists so that users can determine if they are part of a group without being granted particular rights.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\tmemberOf({hardFail,group,owner}) { return this.$publish('memberOf', {hardFail,group,owner})}\n\t/**\n\t * Grants rights to a group\n\t *\n\t * Grant several rights at once.\n\t * */\n\tmgrant({resource,actions,group,owner}) { return this.$publish('mgrant', {resource,actions,group,owner})}\n\t/**Revokes rights for a group*/\n\tmrevoke({resource,actions,group,owner}) { return this.$publish('mrevoke', {resource,actions,group,owner})}\n\t/**\n\t * Lists the groups I am part of\n\t *\n\t * Returns the whole list of groups the current user is part of.\n\t * Groups may be owned by anyone, including the current user.\n\t * */\n\tmyGroups({owner}) { return this.$publish('myGroups', {owner})}\n\t/**Revokes a right for a group*/\n\trevoke({resource,group,owner,action}) { return this.$publish('revoke', {resource,group,owner,action})}\n}\n/**\n * HTTP client\n *\n * Web-service client\n *  An admin records URL templates that can be called by users\n *  Calls are not configurable by end-users\n *  However an admin may leverage the macro service to achieve URL, headers and body configurability\n * */\n/**\n * User API for http requests\n *\n * @access public\n * */\nexport class Httpclient extends Service {\n\t/**\n\t * Get default deployment id associated to Httpclient service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'httpclient_0'\n\t}\n\t/**\n\t * Makes a predefined request\n\t *\n\t * Lookups a predefined request by name, and executes it.\n\t * */\n\tcall({name,requestId}) { return this.$publish('call', {name,requestId})}\n}\n/**\n * Macros\n *\n * Macro-command service\n *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc\n *\n *\n *  End-users play them, with contextual parameters\n * */\n/**\n * User API for macro debugging\n *\n * Debugger API for macro.\n * These API verbs are not intended for use by most developers.\n * @access public\n * */\nexport class MacroDebug extends Service {\n\t/**\n\t * Get default deployment id associated to MacroDebug service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'macro_0'\n\t}\n\t/**Enables or disables a breakpoint*/\n\tbreakpoint({breakpoint,token,enabled}) { return this.$publish('breakpoint', {breakpoint,token,enabled})}\n\t/**Requests some information*/\n\tinfo({token,path,exp,requestId,frame}) { return this.$publish('info', {token,path,exp,requestId,frame})}\n\t/**\n\t * Debugs a previously recorded macro\n\t *\n\t * The given breakpoints will be honored, causing a suspension of the execution, resumable via 'resume'.\n\t * Only one debug session can be active at any given time.\n\t * */\n\tlivedebug({parameters,token,breakpoints,hardFail,name,requestId,debug}) { return this.$publish('livedebug', {parameters,token,breakpoints,hardFail,name,requestId,debug})}\n\t/**Resumes a paused macro*/\n\tresume({token,type}) { return this.$publish('resume', {token,type})}\n\t/**Sets a variable value*/\n\tvariable({token,name,frame,data}) { return this.$publish('variable', {token,name,frame,data})}\n}\n/**\n * User API for macro execution\n *\n * Simple errors are reported as usual.\n * However, the macro execution verbs treat most errors in a particular way : instead of reporting errors on the usual 'error' channel, errors are put in the returned 'MacroCompletion' result.\n * This behavior can be tuned on a per-call basis with the hardFail parameter.\n * Note that some particular errors will always behave as if hardFail were true, because they are related to programming errors, or prevent processing from ending gracefully : STACK_OVERFLOW, NO_SUCH_FUNCTION, RAM_EXCEEDED, CYCLES_EXCEEDED, TIME_EXCEEDED, QUOTA_EXCEEDED, RATE_EXCEEDED, BAD_COMPARATOR_VALUE\n * @access public\n * */\nexport class Macro extends Service {\n\t/**\n\t * Get default deployment id associated to Macro service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'macro_0'\n\t}\n\t/**\n\t * Plays a previously recorded macro\n\t *\n\t * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.\n\t * You can override the default notification channel when defining the macro.\n\t * */\n\tcall({parameters,hardFail,name,requestId,debug}) { return this.$publish('call', {parameters,hardFail,name,requestId,debug})}\n}\n/**\n * Mail sender\n *\n * Sends email through SMTP\n * */\n/**\n * Mail service user API\n *\n * This service is statically configured with an outgoing SMTP server.\n * Users call the API here to actually send emails.\n * @access public\n * */\nexport class Sendmail extends Service {\n\t/**\n\t * Get default deployment id associated to Sendmail service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sendmail_0'\n\t}\n}\n/**\n * Messaging service\n *\n * Messaging service\n * */\n/**\n * Messaging service\n *\n * Simple and flexible user-to-user or user-to-group messaging service.\n * @access public\n * */\nexport class Messaging extends Service {\n\t/**\n\t * Get default deployment id associated to Messaging service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'messaging_0'\n\t}\n\t/**\n\t * Sends a message to a target\n\t *\n\t * Sends the given message to the specified target on the given (optional) channel.\n\t * The administratively given default channel name is used when none is provided in the message itself.\n\t * */\n\tsend({target,channel,data}) { return this.$publish('send', {target,channel,data})}\n}\n/**\n * Producer consumer\n *\n * Producer consumer service\n *  Users can submit tasks and other users consume them\n * */\n/**\n * Producer / consumer real-time API\n *\n * Task producers submits their tasks.\n * The server dispatches the tasks.\n * Consumers process them and report completion back to the server.\n * Tasks are global to the service (i.e. NOT per user).\n * @access public\n * */\nexport class Queue extends Service {\n\t/**\n\t * Get default deployment id associated to Queue service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'queue_0'\n\t}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be returned to the caller.\n\t * When called from inside a macro, the comsumer generated result is available for further use.\n\t * */\n\tcall({description,originBusinessId,originDeploymentId,data,owner}) { return this.$publish('call', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Notifies completion of a task\n\t *\n\t * Consumer API.\n\t * The tasker notifies completion of the given task to the server.\n\t * The tasker can optionally include a result or an error code.\n\t * */\n\tdone({result,taskId,success}) { return this.$publish('done', {result,taskId,success})}\n\t/**\n\t * Registers a consumer\n\t *\n\t * Consumer API.\n\t * Registers the current user resource as an available task consumer.\n\t * Tasks will be then dispatched to that consumer.\n\t * */\n\tregister({capacity}) { return this.$publish('register', {capacity})}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).\n\t * This verb will return immediately : you can use this API to asynchronously submit a task.\n\t * */\n\tsubmit({description,originBusinessId,originDeploymentId,data,owner}) { return this.$publish('submit', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Unregisters a consumer\n\t *\n\t * Consumer API.\n\t * Unregisters the current user resource as an available task consumer.\n\t * All non finished tasks are returned to the server.\n\t * */\n\tunregister() { return this.$publish('unregister', {})}\n}\n/**\n * Push Notifications\n *\n * Native Push Notifications for Android, iOS\n *\n *\n *\n * */\n/**\n * Notification User API\n *\n * User API for notifications.\n * For notifications to work properly, it is imperative that the resource name of a device remain constant over time.\n * @access public\n * */\nexport class Notif extends Service {\n\t/**\n\t * Get default deployment id associated to Notif service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'notif_0'\n\t}\n}\n/**\n * RDBMS\n *\n * Relational Database : SQL storage\n * */\n/**\n * RDBMS User API\n *\n * User API for SQL queries.\n * Contrary to GDA or Stacks, the data are not stored on a per-user basis.\n * Users can store, get, list their data.\n * @access public\n * */\nexport class Rdbms extends Service {\n\t/**\n\t * Get default deployment id associated to Rdbms service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'rdbms_0'\n\t}\n}\n/**\n * SMS via OVH\n *\n * SMS sender, to send text messages to mobile phones\n * This SMS sending service uses the OVH API\n *\n * */\n/**\n * SMS service\n *\n * User API for SMS.\n * @access public\n * */\nexport class Sms_ovh extends Service {\n\t/**\n\t * Get default deployment id associated to Sms_ovh service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sms_ovh_0'\n\t}\n}\n/**\n * Scheduler\n *\n * Scheduler service\n *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)\n * */\n/**\n * User API for the Scheduler\n *\n * User endpoints for scheduling : users can schedule, list and delete tasks.\n * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.\n * Tasks are run on the server and thus can call api verbs marked as server-only.\n * @access public\n * */\nexport class Cron extends Service {\n\t/**\n\t * Get default deployment id associated to Cron service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'cron_0'\n\t}\n\t/**\n\t * List the configured tasks\n\t *\n\t * Returns a paginated list of the asking user's tasks.\n\t * */\n\tlist({start,stop,owner,page}) { return this.$publish('list', {start,stop,owner,page})}\n}\n/**\n * Search engine\n *\n * ElasticSearch engine, to index and search data\n *  An admin creates indices\n *  Users index and search documents\n *\n * */\n/**\n * ElasticSearch Service\n *\n * This API is a very thin wrapper around ElasticSearch's API.\n * @access public\n * */\nexport class Search extends Service {\n\t/**\n\t * Get default deployment id associated to Search service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'search_0'\n\t}\n\t/**\n\t * Deletes data\n\t *\n\t * Deletes a document from the elasticsearch engine by id.\n\t * */\n\tdelete({type,id,index}) { return this.$publish('delete', {type,id,index})}\n\t/**\n\t * Gets data\n\t *\n\t * Retrieves a document from the elasticsearch engine by id.\n\t * */\n\tget({type,id,index}) { return this.$publish('get', {type,id,index})}\n\t/**\n\t * Indexes data\n\t *\n\t * Inserts or updates a document into the elasticsearch engine.\n\t * */\n\tindex({type,id,index,data}) { return this.$publish('index', {type,id,index,data})}\n\t/**Searches for data*/\n\tsearch({indices,query,sort,page,types}) { return this.$publish('search', {indices,query,sort,page,types})}\n}\n/**\n * Template engine\n *\n * Template engine to produce documents from parameterized templates\n * <br>An admin creates templates\n * <br> Users produce documents\n * <br>The implementation uses the <a href='http://freemarker\n * org/'>freemarker</a> engine\n *\n * */\n/**\n * User API for templates\n *\n * Users use this API to evaluate pre-configured templates.\n * @access public\n * */\nexport class Template extends Service {\n\t/**\n\t * Get default deployment id associated to Template service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'template_0'\n\t}\n\t/**\n\t * Evaluates a template\n\t *\n\t * Evaluates the given template and returns the result as a string.\n\t * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.\n\t * */\n\tevaluate({languageTag,name,requestId,data}) { return this.$publish('evaluate', {languageTag,name,requestId,data})}\n}\n/**\n * Triggers\n *\n * Register callbacks for events and trigger them when needed\n *\n * */\n/**\n * Trigger service\n *\n * Register listeners and trigger events.\n * @access public\n * */\nexport class Trigger extends Service {\n\t/**\n\t * Get default deployment id associated to Trigger service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'trigger_0'\n\t}\n}\n/**\n * Upload: S3\n *\n * Upload service with S3 storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3 extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3 service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * Upload: local\n *\n * Upload service with local HDFS storage\n * */\n/**\n * User API for local file management\n *\n * User API for file content manipulation\n * @access public\n * */\nexport class Zpfs_hdfs extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_hdfs service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_hdfs_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * Upload: pseudo-S3\n *\n * Upload service with pseudo-S3compatible storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3compat extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3compat service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3compat_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,path,owner}) { return this.$publish('cp', {oldPath,path,owner})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({path,owner}) { return this.$publish('du', {path,owner})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,path,owner}) { return this.$publish('link', {oldPath,path,owner})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { return this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({parents,folder,owner}) { return this.$publish('mkdir', {parents,folder,owner})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,path,owner}) { return this.$publish('mv', {oldPath,path,owner})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({tags,guid,metadata,owner}) { return this.$publish('newFile', {tags,guid,metadata,owner})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,path,owner}) { return this.$publish('newUploadUrl', {contentType,path,owner})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({path,owner}) { return this.$publish('rm', {path,owner})}\n\t/**\n\t * Creates a snapshot in a new folder\n\t *\n\t * Creates a new folder and then copies the given files inside\n\t * */\n\tsnapshot({parents,folder,items,flatten,owner}) { return this.$publish('snapshot', {parents,folder,items,flatten,owner})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({path,owner}) { return this.$publish('stat', {path,owner})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({path,metadataFiles,metadata,owner}) { return this.$publish('updateMeta', {path,metadataFiles,metadata,owner})}\n}\n/**\n * User directory service\n *\n * User directory service\n * */\n/**\n * User API for user information\n *\n * @access public\n * */\nexport class Userdir extends Service {\n\t/**\n\t * Get default deployment id associated to Userdir service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'userdir_0'\n\t}\n\t/**Searches for users matching the request*/\n\tsearch({requestId,query,page}) { return this.$publish('search', {requestId,query,page})}\n\t/**Requests public data for the specified users*/\n\tuserInfo({userKeys}) { return this.$publish('userInfo', {userKeys})}\n}\n","/**\n * Match unsecure pattern web\n * @type {RegExp}\n */\nconst HTTP_PATTERN = /^http:\\/\\/|^\\/\\//\n\n/**\n * Http protocol\n * @type {string}\n */\nconst HTTP_PROTOCOL = 'http:'\n\n/**\n * Https protocol\n * @type {string}\n */\nconst HTTPS_PROTOCOL = 'https:'\n\n/**\n * Alpha numeric dictionary\n */\nconst DICTIONARY = 'abcdefghijklmnopqrstuvwxyz0123456789'\n\n/**\n * Default ZetaPush API URL\n * @access private\n */\nexport const API_URL = 'https://api.zpush.io/'\n\n/**\n * Force ssl based protocol for network echange\n * Cross Env (Browser/Node) test\n * @access private\n * @type boolean\n */\nexport const FORCE_HTTPS = typeof location === 'undefined' ? false : location.protocol === HTTPS_PROTOCOL\n\n/**\n * @access private\n * @param {string} apiUrl\n * @return {string}\n */\nconst normalizeApiUrl = (apiUrl) => {\n  const last = apiUrl.charAt(apiUrl.length - 1)\n  const SLASH = '/'\n  return last === SLASH ? apiUrl : apiUrl + SLASH\n}\n\n/**\n * @access private\n * @param {Array<Object>} list\n * @return {Object}\n */\nexport const shuffle = (list) => {\n  const index = Math.floor(Math.random() * list.length)\n  return list[index]\n}\n\n/**\n * @access private\n * @param {string} url\n * @param {boolean} forceHttps\n * @return {string}\n */\nexport const getSecureUrl = (url, forceHttps) => {\n  return forceHttps ? url.replace(HTTP_PATTERN, `${HTTPS_PROTOCOL}//`) : url\n}\n\n/**\n * @access private\n * @param {{apiUrl: string, sandboxId: string, forceHttps: boolean, transports: Transports}} parameters\n * @return {Promise}\n */\nexport const getServers = ({ apiUrl, sandboxId, forceHttps, transports }) => {\n  const normalizedSecuresApiUrl = normalizeApiUrl(getSecureUrl(apiUrl, forceHttps))\n  const url = `${normalizedSecuresApiUrl}${sandboxId}`\n  const options = { protocol: forceHttps ? HTTPS_PROTOCOL : HTTP_PROTOCOL }\n  return transports.fetch(url, options)\n    .then((response) => response.json())\n    // TODO: Replace by a server side implementation when available\n    .then(({ servers }) => servers.map((server) => getSecureUrl(server, forceHttps)))\n}\n\n/**\n * @access private\n * @param Class Derived\n * @param Class Parent\n * @return {boolean}\n */\nexport const isDerivedOf = (Derived, Parent) => {\n  let prototype = Object.getPrototypeOf(Derived)\n  let is = false\n  while (!(is || prototype === null)) {\n    is = prototype === Parent\n    prototype = Object.getPrototypeOf(prototype)\n  }\n  return is\n}\n\n/**\n * Get random id\n * @return {string}\n */\nexport const uuid = (entropy = 7, dictionary = DICTIONARY) => Array.from(Array(entropy)).reduce((previous) => {\n  const next = dictionary.charAt(Math.floor(Math.random() * dictionary.length))\n  return `${previous}${next}`\n}, '')\n","import { CometD, Transports } from 'zetapush-cometd'\nimport { ConnectionStatusListener } from '../connection/connection-status'\nimport { Macro } from '../mapping/services'\nimport { getServers, isDerivedOf, shuffle, uuid } from '../utils/index'\n\n/**\n * CometD Messages enumeration\n * @type {Object}\n */\nconst Message = {\n  RECONNECT_HANDSHAKE_VALUE: 'handshake',\n  RECONNECT_NONE_VALUE: 'none',\n  RECONNECT_RETRY_VALUE: 'retry'\n}\n\n/**\n * Delay to update server url\n * @type {integer}\n */\nconst UPDATE_SERVER_URL_DELAY = 250\n\n/**\n * Default macro channel\n * @type {string}\n */\nconst DEFAULT_MACRO_CHANNEL = 'completed'\n\n/**\n * Provide utilities and abstraction on CometD Transport layer\n * @access private\n */\nexport class ClientHelper {\n  /**\n   * Create a new ZetaPush client helper\n   */\n  constructor({ apiUrl, sandboxId, forceHttps = false, authentication, resource = null, transports = Transports }) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access private\n     * @type {function():AbstractHandshake}\n     */\n    this.authentication = authentication\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.resource = resource\n    /**\n     * @access private\n     * @type {number}\n     */\n    this.requestId = 0\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.userId = null\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.uniqId = uuid()\n    /**\n     * @access private\n     * @type {Promise}\n     */\n    this.servers = getServers({ apiUrl, sandboxId, forceHttps, transports }).catch((error) => {\n      // Notify error in connection to server step\n      this.connectionToServerFail(error)\n      // Return empty list\n      return []\n    })\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.connectionListeners = []\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.connected = false\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.wasConnected = false\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.serverUrl = null\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sessionId = null\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.subscribeQueue = []\n    /**\n     * @access private\n     * @type {CometD}\n     */\n    this.cometd = new CometD()\n\n    // Register transports layers\n    transports.ALL.forEach(({ type, Transport }) => {\n      this.cometd.registerTransport(type, new Transport())\n    })\n\n    // Handle transport exception\n    this.cometd.onTransportException = (cometd, transport) => {\n      // Try to find an other available server\n      // Remove the current one from the _serverList array\n      this.updateServerUrl()\n    }\n\n    this.cometd.addListener('/meta/handshake', ({ ext, successful, advice, error }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      if (successful) {\n        const { authentication = null } = ext\n        this.initialized(authentication)\n      } else {\n        this.handshakeFailure(error)\n      }\n    })\n\n    this.cometd.addListener('/meta/handshake', ({ advice, error, ext, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      // AuthNegotiation\n      if (!successful) {\n        if (typeof advice === 'undefined') {\n          return\n        }\n        if (Message.RECONNECT_NONE_VALUE === advice.reconnect) {\n          this.authenticationFailed(error)\n        } else if (Message.RECONNECT_HANDSHAKE_VALUE === advice.reconnect) {\n          this.negotiate(ext)\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/connect', ({ advice, channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/connect', { advice, channel, successful })\n      // ConnectionListener\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection will close\n        this.connectionWillClose()\n      } else {\n        this.wasConnected = this.connected\n        this.connected = successful\n        if (!this.wasConnected && this.connected) {\n          this.cometd.batch(this, () => {\n            // Unqueue subscriptions\n            this.subscribeQueue.forEach(({ prefix, listener, subscriptions }) => {\n              this.subscribe(prefix, listener, subscriptions)\n            })\n          })\n          // Notify connection is established\n          this.connectionEstablished()\n        } else if (this.wasConnected && !this.connected) {\n          // Notify connection is broken\n          this.connectionBroken()\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/disconnect', ({ channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/disconnect', { channel, successful })\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection is closed\n        this.connectionClosed()\n      }\n    })\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    this.connectionListeners.push({\n      enabled: true,\n      listener: Object.assign(new ConnectionStatusListener(), listener)\n    })\n    return this.connectionListeners.length - 1\n  }\n  /**\n   * Notify listeners when handshake step succeed\n   */\n  authenticationFailed(error) {\n    this.userId = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onFailedHandshake(error)\n      })\n  }\n  /**\n   * Connect client using CometD Transport\n   */\n  connect() {\n    this.servers.then((servers) => {\n      if (servers.length > 0) {\n        // Get a random server url\n        this.serverUrl = shuffle(servers)\n        // Configure CometD\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`,\n          backoffIncrement: 1000,\n          maxBackoff: 60000,\n          appendMessageTypeToURL: false\n        })\n        // Send handshake fields\n        this.cometd.handshake(this.getHandshakeFields())\n      } else {\n        // No servers available\n        this.noServerUrlAvailable()\n      }\n    })\n  }\n  /**\n   * Notify listeners when connection is broken\n   */\n  connectionBroken() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionBroken()\n      })\n  }\n  /**\n   * Notify listeners when connection is closed\n   */\n  connectionClosed() {\n    this.userId = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionClosed()\n      })\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  connectionEstablished() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionEstablished()\n      })\n  }\n  /**\n   * Notify listeners when connection to server fail\n   */\n  connectionToServerFail(failure) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionToServerFail(failure)\n      })\n  }\n  /**\n   * Notify listeners when connection will close\n   */\n  connectionWillClose() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionWillClose()\n      })\n  }\n  /**\n   * Create a promise based macro service\n   * @experimental\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createAsyncMacroService({ listener, Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`\n    const $publish = this.getAsyncMacroPublisher(prefix)\n    // Create service by publisher\n    return this.createServiceByPublisher({ listener, prefix, Type, $publish })\n  }\n  /**\n   * Create a publish/subscribe service\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createService({ listener, Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const isMacroType = isDerivedOf(Type, Macro)\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`\n    const $publish = isMacroType ? this.getMacroPublisher(prefix) : this.getServicePublisher(prefix)\n    // Create service by publisher\n    return this.createServiceByPublisher({ listener, prefix, Type, $publish })\n  }\n  /**\n   * @param {{listener: Object, prefix: string, Type: class, $publish: Function}} parameters\n   * @return {Object} service\n   */\n  createServiceByPublisher({ listener, prefix, Type, $publish }) {\n    const service = new Type({ $publish })\n    // Store subscription in service instance\n    service.$subscriptions = this.subscribe(prefix, listener)\n    return service\n  }\n  /**\n   * Disconnect CometD client\n   */\n  disconnect() {\n    this.cometd.disconnect(true)\n  }\n  /**\n   * Get a publisher for a macro service that return a promise\n   * @experimental\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getAsyncMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`\n      const uniqRequestId = this.getUniqRequestId()\n      const subscriptions = {}\n      return new Promise((resolve, reject) => {\n        const handler = ({ data = {} }) => {\n          const { result = {}, errors = [], requestId } = data\n          if (requestId === uniqRequestId) {\n            // Handle errors\n            if (errors.length > 0) {\n              reject(errors)\n            } else {\n              resolve(result)\n            }\n            this.unsubscribe(subscriptions)\n          }\n        }\n        // Create dynamic listener method\n        const listener = {\n          [name]: handler,\n          [DEFAULT_MACRO_CHANNEL]: handler\n        }\n        // Ad-Hoc subscription\n        this.subscribe(prefix, listener, subscriptions)\n        // Publish message on channel\n        this.publish(channel, {\n          debug,\n          hardFail,\n          name,\n          parameters,\n          requestId: uniqRequestId\n        })\n      })\n    }\n  }\n  /**\n   * Get client id\n   * @return {string} clientId\n   */\n  getClientId() {\n    return this.cometd.getClientId()\n  }\n  /**\n   * Get CometD handshake parameters\n   * @return {Object}\n   */\n  getHandshakeFields() {\n    const handshake = this.authentication()\n    return handshake.getHandshakeFields(this)\n  }\n  /**\n   * Get a publisher for a macro service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`\n      const requestId = this.getUniqRequestId()\n      return this.publish(channel, {\n        debug,\n        hardFail,\n        name,\n        parameters,\n        requestId\n      })\n    }\n  }\n  /**\n   * Get queued subscription index\n   * @return {Object} index\n   */\n  getQueuedSubscription(subscriptions = {}) {\n    const index = this.subscribeQueue.findIndex((element) => subscriptions === element.subscriptions)\n    return {\n      index,\n      queued: index > -1\n    }\n  }\n  /**\n   * Get resource\n   * @return {string}\n   */\n  getResource() {\n    return this.resource\n  }\n  /**\n   * Get sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.sandboxId\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.servers\n  }\n  /**\n   * Get a publisher for a service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getServicePublisher(prefix) {\n    return (method, parameters) => {\n      const channel = `${prefix}/${method}`\n      return this.publish(channel, parameters)\n    }\n  }\n  /**\n   * Get uniq request id\n   * @return {string}\n   */\n  getUniqRequestId() {\n    return `${this.getClientId()}:${this.uniqId}:${++this.requestId}`\n  }\n  /**\n   * Get user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.userId\n  }\n  /**\n   * Manage handshake failure case\n   */\n  handshakeFailure() {\n    this.userId = null\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  initialized(authentication) {\n    if (authentication) {\n      this.userId = authentication.userId\n    }\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onSuccessfulHandshake(authentication)\n      })\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return !this.cometd.isDisconnected()\n  }\n  /**\n   * Notify listeners when a message is lost\n   */\n  messageLost(channel, data) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onMessageLost(channel, data)\n      })\n  }\n  /**\n   * Negociate authentication\n   */\n  negotiate(ext) {\n    this.cometd._debug('ClientHelper::negotiate', ext)\n  }\n  /**\n   * Notify listeners when no server url available\n   */\n  noServerUrlAvailable() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onNoServerUrlAvailable()\n      })\n  }\n  /**\n   * Wrap CometdD publish method\n   * @param {String} channel\n   * @param {Object} parameters\n   * @return {Object}\n   */\n  publish(channel, parameters = {}) {\n    this.cometd.publish(channel, parameters)\n    return { channel, parameters }\n  }\n  /**\n   * Remove a connection status listener\n   */\n  removeConnectionStatusListener(handler) {\n    const listener = this.connectionListeners[handler]\n    if (listener) {\n      listener.enabled = false\n    }\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.authentication = authentication\n  }\n  /**\n   * Set logging level for CometD client\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.cometd.setLogLevel(level)\n  }\n  /**\n   * Subsribe all methods defined in the listener for the given prefixed channel\n   * @param {string} prefix - Channel prefix\n   * @param {Object} listener\n   * @param {Object} subscriptions\n   * @return {Object} subscriptions\n   */\n  subscribe(prefix, listener = {}, subscriptions = {}) {\n    const { queued } = this.getQueuedSubscription(subscriptions)\n    if (!queued) {\n      // Store arguments to renew subscriptions on connection\n      this.subscribeQueue.push({ prefix, listener, subscriptions })\n    }\n    // Subscribe if user is connected\n    if (!this.cometd.isDisconnected()) {\n      for (let method in listener) {\n        if (listener.hasOwnProperty(method)) {\n          const channel = `${prefix}/${method}`\n          subscriptions[method] = this.cometd.subscribe(channel, listener[method])\n        }\n      }\n    }\n    return subscriptions\n  }\n  /**\n  * Remove current server url from the server list and shuffle for another one\n  */\n  updateServerUrl() {\n    this.servers.then((servers) => {\n      const index = servers.indexOf(this.serverUrl)\n      if (index > -1) {\n        servers.splice(index, 1)\n      }\n      if (servers.length === 0) {\n        // No more server available\n        this.noServerUrlAvailable()\n      } else {\n        this.serverUrl = shuffle(servers)\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`\n        })\n        setTimeout(() => {\n          this.cometd.handshake(this.getHandshakeFields())\n        }, UPDATE_SERVER_URL_DELAY)\n      }\n    })\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} subscriptions\n   */\n  unsubscribe(subscriptions = {}) {\n    // Unsubscribe\n    for (let method in subscriptions) {\n      if (subscriptions.hasOwnProperty(method)) {\n        const subscription = subscriptions[method]\n        this.cometd.unsubscribe(subscription)\n      }\n    }\n    // Remove subscription from queue\n    const { index, queued } = this.getQueuedSubscription(subscriptions)\n    if (queued) {\n      this.subscribeQueue.splice(index, 1)\n    }\n  }\n}\n","import { ClientHelper } from './helper'\nimport { API_URL, FORCE_HTTPS } from '../utils/index'\nimport { ConnectionStatusListener } from '../connection/connection-status'\n\n/**\n * Client config object.\n * @typedef {Object} ClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {function():AbstractHandshake} authentication - Return authentication properties\n * @property {string} resource - Client resource id\n * @property {Transports} transports - Client transports implementation\n */\n\n/**\n * ZetaPush Client to connect\n * @access public\n * @example\n * // Securized client with token based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       token: null\n *    })\n *   }\n * })\n * @example\n * // Client with authentication based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * @example\n * // Explicit deploymentId\n * const clientSimple = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * const clientWeak = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n *       token: '<SESSION-TOKEN>'\n *    })\n *   }\n * })\n */\nexport class Client {\n  /**\n   * Create a new ZetaPush Client\n   * @param {ClientConfig} config\n   */\n  constructor({ apiUrl = API_URL, sandboxId, forceHttps = FORCE_HTTPS, authentication, resource, transports }) {\n    /**\n     * @access private\n     * @type {ClientHelper}\n     */\n    this.helper = new ClientHelper({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      authentication,\n      resource,\n      transports\n    })\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    return this.helper.addConnectionStatusListener(listener)\n  }\n  /**\n   * Safely connect client to ZetaPush\n   */\n  connect() {\n    if (this.isConnected()) {\n      const handler = this.addConnectionStatusListener({\n        onConnectionClosed: () => {\n          this.removeConnectionStatusListener(handler)\n          this.helper.connect()\n        }\n      })\n      this.disconnect()\n    } else {\n      this.helper.connect()\n    }\n  }\n  /**\n   * Create a promise based service instance\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const api = client.createAsyncMacroService({\n   *   Type: WelcomeMacro\n   * })\n   * api.welcome({\n   *   message: Hello'\n   * }).then(({ message }) => {\n   *   console.log(message)\n   * })\n   */\n  createAsyncMacroService({ deploymentId, listener, Type }) {\n    return this.helper.createAsyncMacroService({ deploymentId, listener, Type })\n  }\n  /**\n   * Create a publish/subscribe for a service type\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const service = client.createService({\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * const service = client.createService({\n   *   deploymentId: 'stack_0'\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   */\n  createService({ deploymentId, listener, Type }) {\n    return this.helper.createService({ deploymentId, listener, Type })\n  }\n  /**\n   * Disonnect client from ZetaPush\n   */\n  disconnect() {\n    if (this.isConnected()) {\n      this.helper.disconnect()\n    }\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return this.helper.isConnected()\n  }\n  /**\n   * Get the client sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.helper.getSandboxId()\n  }\n  /**\n   * Get the client resource\n   * @return {string}\n   */\n  getResource() {\n    return this.helper.getResource()\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.helper.getServers()\n  }\n  /**\n   * Get the client user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.helper.getUserId()\n  }\n  /**\n   * Remove a connection status listener\n   * @param {number} handler\n   */\n  removeConnectionStatusListener(handler) {\n    return this.helper.removeConnectionStatusListener(handler)\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.helper.setAuthentication(authentication)\n  }\n  /**\n   * Set logging level\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.helper.setLogLevel(level)\n  }\n  /**\n   * Set new client resource value\n   * @param {string} resource\n   */\n  setResource(resource) {\n    this.helper.setResource(resource)\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} service\n   */\n  unsubscribe(service) {\n    if (!service.$subscriptions) {\n      throw new TypeError('Missing $subscriptions property in service')\n    }\n    return this.helper.unsubscribe(service.$subscriptions)\n  }\n}\n\n/**\n * Add shorthand connection status method\n */\nObject.getOwnPropertyNames(ConnectionStatusListener.prototype).forEach((method) => {\n  // Only implements unsupported methods\n  if (!Client.prototype.hasOwnProperty(method)) {\n    Client.prototype[method] = function addListener(listener) {\n      return this.addConnectionStatusListener({\n        [method]: listener\n      })\n    }\n  }\n})\n","/**\n * Provide fallback for DOMStorage\n * @access protected\n */\nclass MemoryStorage {\n  constructor() {\n    this._map = new Map()\n  }\n  getItem(key) {\n    return this._map.get(key)\n  }\n  setItem(key, value) {\n    return this._map.get(key)\n  }\n  removeItem(key) {\n    this._map.delete(key)\n  }\n  clear() {\n    this._map = new Map()\n  }\n  key(n) {\n    return Array.from(this._map.keys())[n]\n  }\n  get length() {\n    return this._map.size\n  }\n}\n\n/**\n * @type {Storage}\n * @access protected\n */\nexport const platformStorage = typeof localStorage === 'undefined' ? new MemoryStorage() : localStorage\n","import { platformStorage } from './storage'\n\n/**\n * @type {string}\n */\nexport const ZETAPUSH_SESSION_KEY = 'zetapush.token'\n\n/**\n * Provide abstraction for token persistence\n * @access protected\n */\nexport class SessionPersistenceStrategy {\n  /**\n   * @param {{sandboxId: string, storage: DOMStorage}} parameters\n   */\n  constructor({ sandboxId, storage = platformStorage } = {}) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.key = `${ZETAPUSH_SESSION_KEY}.${sandboxId}`\n    /**\n     * @access private\n     * @type {DOMStorage}\n     */\n    this.storage = storage\n  }\n  /**\n   * @return {string} session The stored session\n   */\n  get() {\n    const { key, storage } = this\n    const json = storage.getItem(key) || '{}'\n    let session = {}\n    try {\n      session = JSON.parse(json)\n    } catch (e) { }\n    return session\n  }\n  /**\n   * @param {Object} session The session to store\n   */\n  set(session = {}) {\n    const { key, storage } = this\n    const json = JSON.stringify(session)\n    try {\n      storage.setItem(key, json)\n    } catch (e) { }\n    return session\n  }\n}\n","import { Client } from './basic'\nimport { Authentication } from '../authentication/handshake'\nimport { SessionPersistenceStrategy } from '../utils/session-persistence'\n\n/**\n * SmartClient config object.\n * @typedef {Object} SmartClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.SmartClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class SmartClient extends Client {\n  /**\n   * Create a new ZetaPush SmartClient\n   * @param {SmartClientConfig} config\n   */\n  constructor({ apiUrl, sandboxId, forceHttps, resource, transports }) {\n    const persistence = new SessionPersistenceStrategy({ sandboxId })\n\n    /**\n     * @return {AbstractHandshakeManager}\n     */\n    const authentication = () => {\n      const session = persistence.get()\n      const { token } = session\n\n      if (this.hasCredentials()) {\n        const { login, password } = this.getCredentials()\n        this.setCredentials({})\n        return Authentication.simple({\n          login,\n          password\n        })\n      } else {\n        if (this.isStronglyAuthenticated(session)) {\n          return Authentication.simple({\n            login: token,\n            password: null\n          })\n        } else {\n          return Authentication.weak({\n            token\n          })\n        }\n      }\n    }\n    // Initialize base client\n    super({\n      apiUrl, sandboxId, authentication, forceHttps, resource, transports\n    })\n    /**\n     * @access protected\n     * @type {SessionPersistenceStrategy}\n     */\n    this.persistence = persistence\n    /**\n     * @access protected\n     * @type {Object}\n     */\n    this.credentials = {}\n    /**\n     * Handle connection lifecycle events\n     * @access protected\n     * @type {Object}\n     */\n    this.lifeCycleConnectionHandler = this.addConnectionStatusListener({\n      onConnectionClosed() {\n        persistence.set({})\n      },\n      onSuccessfulHandshake(session) {\n        if (session.token) {\n          persistence.set(session)\n        }\n      }\n    })\n    // Properly disconnect client to avoir ghost connections\n    /*\n    window.addEventListener('beforeunload', () => {\n      this.removeConnectionStatusListener(this.lifeCycleConnectionHandler)\n      super.disconnect()\n    })\n    */\n  }\n  /**\n   * Disconnect client from ZetaPush backend\n   */\n  disconnect() {\n    super.disconnect()\n  }\n  /**\n   * @return {Object}\n   */\n  getCredentials() {\n    return this.credentials\n  }\n  /**\n   * @return {Object}\n   */\n  getSession() {\n    return this.persistence.get()\n  }\n  /**\n   * @return {boolean}\n   */\n  hasCredentials() {\n    const { login, password } = this.getCredentials()\n    return login && password\n  }\n  /**\n   * @return {boolean}\n   */\n  isStronglyAuthenticated(session = this.persistence.get()) {\n    return !this.isWeaklyAuthenticated(session) && typeof session.token === 'string'\n  }\n  /**\n   * @return {boolean}\n   */\n  isWeaklyAuthenticated(session = this.persistence.get()) {\n    return typeof session.publicToken === 'string'\n  }\n  /**\n   * @param {{login: string, password: string}} parameters\n   */\n  setCredentials({ login, password }) {\n    this.credentials = { login, password }\n  }\n}\n","import { Client } from './basic'\nimport { Authentication } from '../authentication/handshake'\nimport { SessionPersistenceStrategy } from '../utils/session-persistence'\n\n/**\n * WeakClient config object.\n * @typedef {Object} WeakClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} deploymentId - Authentication deployment id, default value is 'weak_0'\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.WeakClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n * @example\n * // Explicit deploymentId\n * // WeakClient provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n * // deploymentId default value is weak_0\n * const client = new ZetaPush.WeakClient({\n *   deploymentId: 'weak_0',\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class WeakClient extends Client {\n  /**\n   * Create a new ZetaPush WeakClient\n   * @param {WeakClientConfig} config\n   */\n  constructor({ apiUrl, sandboxId, deploymentId, forceHttps, resource, transports }) {\n    const authentication = () => {\n      const token = this.getToken()\n      const handshake = Authentication.weak({\n        deploymentId,\n        token\n      })\n      return handshake\n    }\n    /**\n     * Call Client constructor with specific parameters\n     */\n    super({ apiUrl, sandboxId, forceHttps, authentication, resource, transports })\n    // Handle successful handshake\n    const onSuccessfulHandshake = ({ publicToken, userId, token }) => {\n      if (token) {\n        this.strategy.set({ publicToken, userId, token })\n      }\n    }\n    this.addConnectionStatusListener({ onSuccessfulHandshake })\n    /**\n     * @access private\n     * @type {SessionPersistenceStrategy}\n     */\n    this.strategy = new SessionPersistenceStrategy({ sandboxId })\n  }\n  /**\n   * @return {string} The stored token\n   */\n  getToken() {\n    const { token } = this.strategy.get()\n    return token\n  }\n}\n","export { Authentication } from './authentication/handshake'\nexport { ConnectionStatusListener } from './connection/connection-status'\n\nexport { Client } from './client/basic'\nexport { SmartClient } from './client/smart'\nexport { WeakClient } from './client/weak'\n\nexport { services } from './mapping'\n\n/**\n * SDK Version\n * @type {string}\n */\nexport const VERSION = '3.2.0-alpha.1'\n"],"names":["FetchLongPollingTransport","_super","LongPollingTransport","that","Transport","derive","xhrSend","packet","fetch","url","method","body","headers","Object","assign","Content-Type","then","response","json","onSuccess","catch","onError","WebSocketTransport","_forceClose","context","event","this","webSocketClose","code","reason","onClose","_sameContext","_connecting","_context","_storeEnvelope","envelope","metaConnect","messageIds","i","messages","length","message","id","push","envelopes","join","_debug","getType","_websocketConnect","_cometd","getURL","replace","protocol","getConfiguration","WebSocket","webSocket","x","_webSocketSupported","_stickyReconnect","stickyReconnect","self","connectTimeout","connectTimer","setTimeout","call","onopen","clearTimeout","_webSocketConnected","onOpen","_warn","onclose","onmessage","wsMessage","onMessage","onerror","_webSocketSend","JSON","stringify","send","maxDelay","maxNetworkDelay","delay","getAdvice","timeout","_connected","timeouts","_send","exception","_self","_successCallback","reset","init","_notifySuccess","fn","_notifyFailure","failure","key","hasOwnProperty","element","close","convertToMessages","data","test","channel","undefined","removed","j","ids","split","index","Utils","inArray","splice","websocketCode","onFailure","registered","type","cometd","accept","version","crossDomain","websocketEnabled","abort","Service","$publish","Delegating","Simple","Weak","control","publicToken","fullRights","getToken","release","AbstractHandshake","authType","sandboxId","deploymentId","getHandshakeFields","client","authentication","authData","getSandboxId","authVersion","getResource","resource","TokenHandshake","token","_AbstractHandshake","CredentialsHandshake","login","password","_AbstractHandshake2","Authentication","simple","DEFAULT_DEPLOYMENT_ID","create","DeployableNames","weak","delegating","ConnectionStatusListener","onConnectionBroken","onConnectionClosed","onConnectionEstablished","onConnectionToServerFail","onNoServerUrlAvailable","onConnectionWillClose","onFailedHandshake","onMessageLost","onSuccessfulHandshake","_types","_transports","getTransportTypes","slice","findTransportTypes","result","negotiateTransport","types","transport","add","existing","find","remove","clear","value","String","Array","array","funktion","timeoutHandle","name","_fieldValue","object","_isString","isString","_isFunction","_zeroPad","Math","pow","_log","level","args","console","logger","now","Date","getHours","getMinutes","getSeconds","getMilliseconds","apply","_splitURL","exec","_configure","configuration","_config","_mixin","urlParts","hostAndPort","uri","afterURI","_crossDomain","_isCrossDomain","appendMessageTypeToURL","_info","uriSegments","lastSegmentIndex","match","indexOf","_removeListener","subscription","subscriptions","_listeners","listener","_removeSubscription","_clearSubscriptions","_setStatus","newStatus","_status","_isDisconnected","_nextMessageId","_messageId","_applyExtension","scope","callback","outgoing","handler","onExtensionException","xx","_applyIncomingExtensions","_extensions","extension","reverseIncomingExtensions","incoming","_applyOutgoingExtensions","_notify","onListenerException","_notifyListeners","channelParts","last","channelPart","_cancelDelayedSend","_scheduledSend","_delayedSend","operation","_backoff","time","_advice","interval","sync","extraPath","messageId","_clientId","clientId","_callbacks","rcvdMessages","_handleMessages","conduit","getTransport","connectionType","_handleFailure","_transport","_queueSend","_batch","_internalBatch","_messageQueue","_resetBackoff","_increaseBackoff","maxBackoff","backoffIncrement","_startBatch","_flushBatch","_endBatch","_connect","bayeuxMessage","advice","_delayedConnect","_updateAdvice","newAdvice","_disconnect","_notifyTransportFailure","oldTransport","newTransport","onTransportException","_handshake","handshakeProps","handshakeCallback","reconnect","_handshakeProps","_handshakeCallback","transportTypes","minimumVersion","supportedConnectionTypes","_putCallback","_delayedHandshake","_notifyCallback","onCallbackException","_handleCallback","_getCallback","_handleRemoteCall","_remoteCalls","_failHandshake","_handshakeResponse","successful","reestablish","_reestablish","action","_handshakeFailure","_failConnect","_connectResponse","_connectFailure","_failDisconnect","_disconnectResponse","_disconnectFailure","_failSubscribe","_subscribeResponse","_subscribeFailure","_failUnsubscribe","_unsubscribeResponse","_unsubscribeFailure","_failMessage","_messageResponse","_handshakeMessages","_messageFailure","_receive","_unconnectTime","_hasSubscriptions","_resolveScopedCallback","delegate","_addListener","isListener","_name","TransportRegistry","maxConnections","logLevel","requestHeaders","autoBatch","urls","maxURILength","maxInterval","deep","target","objects","arguments","propName","prop","targ","source","host","location","receive","failureMessage","registerTransport","unregisterTransport","unregistered","unregisterTransports","findTransport","getTransportRegistry","configure","handshake","disconnect","disconnectProps","disconnectCallback","startBatch","endBatch","batch","addListener","removeListener","clearListeners","subscribe","subscribeProps","subscribeCallback","unsubscribe","unsubscribeProps","unsubscribeCallback","resubscribe","clearSubscriptions","publish","content","publishProps","publishCallback","remoteCall","error","getStatus","isDisconnected","setBackoffIncrement","period","getBackoffIncrement","getBackoffPeriod","increaseBackoffPeriod","resetBackoffPeriod","setLogLevel","registerExtension","unregisterExtension","ext","getExtension","getName","getClientId","_type","_url","handle","parse","isArray","setURL","toString","baseObject","F","prototype","_coalesceEnvelopes","_envelopes","envelopeAndRequest","newEnvelope","newRequest","shift","concat","_transportSend","request","transportSend","expired","errorMessage","xhr","httpCode","xhrStatus","abortXHR","complete","requestId","_requestIds","_requests","_metaConnectComplete","_metaConnectRequest","_complete","success","nextEnvelope","nextRequest","_metaConnectSend","transportSuccess","responses","transportFailure","state","readyState","XMLHttpRequest","UNSENT","status","RequestTransport","_supportsCrossDomain","sameStack","received","window","WEBSOCKET_TRANSPORT","TRANSPORT_TYPES","LONG_POLLING_TRANSPORT","require$$0","Aggreg","items","owner","Stack","getListeners","stack","list","page","purge","guids","setListeners","listeners","update","guid","Echo","echo","parameter","Game","available","role","gameId","userId","userName","organize","options","play","start","unjoin","GameEngine","join_result","msgId","payload","callerId","organize_result","register","maxGames","gameInfo","start_result","unjoin_result","Gda","get","table","getCells","key2","column","inc","columns","put","puts","rows","range","stop","removeCell","removeColumn","removeRange","removeRow","Remoting","fromResource","cmd","from","capabilities","askingResource","answeringResource","execute","getCapabilities","notify","ping","pong","user","uid","GroupManagement","addMe","group","addUser","addUsers","users","allGroups","createGroup","groupName","delGroup","delUser","delUsers","exists","grant","groupUsers","groups","listGrants","listPresences","memberOf","hardFail","mgrant","actions","mrevoke","myGroups","revoke","Httpclient","MacroDebug","breakpoint","enabled","info","path","exp","frame","livedebug","parameters","breakpoints","debug","resume","variable","Macro","Sendmail","Messaging","Queue","description","originBusinessId","originDeploymentId","done","taskId","capacity","submit","unregister","Notif","Rdbms","Sms_ovh","Cron","Search","delete","search","indices","query","sort","Template","evaluate","languageTag","Trigger","Zpfs_s3","cp","oldPath","du","link","ls","folder","mkdir","parents","mv","newFile","tags","metadata","newUploadUrl","contentType","rm","snapshot","flatten","stat","updateMeta","metadataFiles","Zpfs_hdfs","Zpfs_s3compat","Userdir","userInfo","userKeys","HTTP_PATTERN","API_URL","FORCE_HTTPS","normalizeApiUrl","apiUrl","charAt","shuffle","floor","random","getSecureUrl","forceHttps","HTTPS_PROTOCOL","getServers","transports","servers","map","server","isDerivedOf","Derived","Parent","getPrototypeOf","is","uuid","entropy","dictionary","reduce","previous","Message","ClientHelper","Transports","uniqId","connectionToServerFail","connectionListeners","connected","wasConnected","serverUrl","sessionId","subscribeQueue","CometD","ALL","forEach","updateServerUrl","initialized","handshakeFailure","RECONNECT_NONE_VALUE","authenticationFailed","RECONNECT_HANDSHAKE_VALUE","negotiate","_this","connectionWillClose","prefix","connectionEstablished","connectionBroken","connectionClosed","addConnectionStatusListener","filter","connect","_this2","noServerUrlAvailable","createAsyncMacroService","Type","getAsyncMacroPublisher","createServiceByPublisher","createService","isMacroType","getMacroPublisher","getServicePublisher","service","$subscriptions","uniqRequestId","_this3","getUniqRequestId","Promise","resolve","reject","errors","_this4","getQueuedSubscription","findIndex","_this5","getUserId","isConnected","messageLost","removeConnectionStatusListener","setAuthentication","queued","_this6","Client","helper","setResource","TypeError","getOwnPropertyNames","MemoryStorage","_map","Map","getItem","setItem","removeItem","n","keys","size","platformStorage","localStorage","ZETAPUSH_SESSION_KEY","SessionPersistenceStrategy","storage","session","e","set","SmartClient","persistence","hasCredentials","getCredentials","setCredentials","isStronglyAuthenticated","_Client","credentials","lifeCycleConnectionHandler","getSession","isWeaklyAuthenticated","WeakClient","strategy"],"mappings":"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"}