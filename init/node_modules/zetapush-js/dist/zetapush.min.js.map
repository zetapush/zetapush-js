{"version":3,"file":"zetapush.min.js","sources":["../src/mapping/core.js","../src/mapping/authentications.js","../src/authentication/handshake.js","../src/connection/connection-status.js","../node_modules/zetapush-cometd/lib/Utils.js","../node_modules/zetapush-cometd/lib/TransportTypes.js","../node_modules/zetapush-cometd/lib/Transport.js","../node_modules/zetapush-cometd/lib/RequestTransport.js","../node_modules/zetapush-cometd/lib/LongPollingTransport.js","../node_modules/zetapush-cometd/lib/FetchLongPollingTransport.js","../node_modules/zetapush-cometd/lib/WebSocketTransport.js","../node_modules/zetapush-cometd/lib/browser/Transports.js","../node_modules/zetapush-cometd/lib/CometD.js","../node_modules/zetapush-cometd/lib/TransportRegistry.js","../src/mapping/services.js","../src/utils/index.js","../src/client/helper.js","../src/client/basic.js","../src/utils/storage.js","../src/utils/session-persistence.js","../src/client/smart.js","../src/client/weak.js","../src/client/server.js","../src/index.js"],"sourcesContent":["/**\n * @access protected\n */\nexport class Service {\n  constructor({ $publish }) {\n    this.$publish = $publish;\n  }\n}\n","import { Service } from './core';\n/**\n * Delegating authentication\n *\n * This authentication delegates authentication to an external auth provider\n * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL\n * <br>The response must be in JSON format\n *  Each key of the response will be considered a user information field name\n * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)\n * */\n/**\n * End-user API for the delegating authentication\n *\n * Provisionning verbs.\n * @access public\n * */\nexport class Delegating extends Service {\n  /**\n   * Get default deployment id associated to Delegating service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'delegating_0';\n  }\n}\n/**\n * Local authentication\n *\n * Zetapush local authentication\n *  The configurer can choose the primary key and mandatory user fields for account creation\n *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)\n * */\n/**\n * End-user API for the simple local authentication\n *\n * These API verbs allow end-users to manage their account.\n * @access public\n * */\nexport class Simple extends Service {\n  /**\n   * Get default deployment id associated to Simple service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'simple_0';\n  }\n}\n/**\n * Weak authentication\n *\n * The weak authentication allows for anonymous authentication of devices\n *  Such devices can display a qrcode to allow regular users to take control of them\n * */\n/**\n * User API for weak devices control\n *\n * User API for control and release of weakly authenticated user sessions.\n * @access public\n * */\nexport class Weak extends Service {\n  /**\n   * Get default deployment id associated to Weak service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'weak_0';\n  }\n  /**\n   * Controls a session\n   *\n   * Takes control of a weak user session, identified by the given public token.\n   * The public token has been previously made available by the controlled device, for example by displaying a QRCode.\n   * Upon control notification, the client SDK of the controlled session is expected to re-handshake.\n   * */\n  control({ publicToken, fullRights }) {\n    return this.$publish('control', { publicToken, fullRights });\n  }\n  /**\n   * Returns the current token\n   *\n   * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.\n   * The token can be used to log in as the same weak user another time.\n   * */\n  getToken() {\n    return this.$publish('getToken', {});\n  }\n  /**\n   * Releases a session\n   *\n   * Releases control of a weak user session, identified by the given public token.\n   * The weak user session must have been previously controlled by a call to 'control'.\n   * */\n  release({ publicToken, fullRights }) {\n    return this.$publish('release', { publicToken, fullRights });\n  }\n}\n","import { Delegating, Simple, Weak } from '../mapping/authentications';\n\n/**\n * ZetaPush deployables names\n */\nconst DeployableNames = {\n  AUTH_SIMPLE: 'simple',\n  AUTH_WEAK: 'weak',\n  AUTH_DELEGATING: 'delegating',\n  AUTH_DEVELOPER: 'developer',\n};\n\n/**\n * Provide abstraction over CometD handshake data structure\n * @access protected\n */\nclass AbstractHandshake {\n  /**\n   * Create a new handshake manager\n   * @param {{authType: string, sandboxId: string, deploymentId: string}} parameters\n   */\n  constructor({ authType, sandboxId, deploymentId }) {\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.authType = authType;\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.sandboxId = sandboxId;\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.deploymentId = deploymentId;\n  }\n  /**\n   * @param {ClientHelper} client\n   * @return {Object}\n   */\n  getHandshakeFields(client) {\n    const authentication = {\n      data: this.authData,\n      type: `${client.getSandboxId()}.${this.deploymentId}.${this.authType}`,\n      version: this.authVersion,\n    };\n    if (client.getResource()) {\n      authentication.resource = client.getResource();\n    }\n    return {\n      ext: {\n        authentication,\n      },\n    };\n  }\n  /**\n   * Get auth version\n   * @return {string}\n   */\n  get authVersion() {\n    return 'none';\n  }\n}\n\n/**\n * Provide abstraction over CometD token base handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass TokenHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, token: string}} parameters\n   */\n  constructor({ authType, deploymentId, token }) {\n    super({\n      deploymentId,\n      authType,\n    });\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.token = token;\n  }\n  /**\n   * @return {token: string}\n   */\n  get authData() {\n    const { token } = this;\n    return {\n      token,\n    };\n  }\n}\n\n/**\n * Provide abstraction over CometD credentials based handshake data structure\n * @access protected\n * @extends {AbstractHandshake}\n */\nclass CredentialsHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   */\n  constructor({ authType, deploymentId, login, password }) {\n    super({\n      authType,\n      deploymentId,\n    });\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.login = login;\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.password = password;\n  }\n  /**\n   * Get auth data\n   * @return {login: string, password: string}\n   */\n  get authData() {\n    const { login, password } = this;\n    return {\n      login,\n      password,\n    };\n  }\n}\n\n/**\n * Factory to create handshake\n * @access public\n */\nexport class Authentication {\n  /**\n   * @param {{deploymentId: string, login: string, password: string}} parameters\n   * @return {CredentialsHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   login: <USER-LOGIN>,\n   *   password: '<USER-PASSWORD>'\n   * })\n   */\n  static simple({\n    deploymentId = Simple.DEFAULT_DEPLOYMENT_ID,\n    login,\n    password,\n  }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_SIMPLE,\n      deploymentId,\n      login,\n      password,\n    });\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static weak({ deploymentId = Weak.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_WEAK,\n      deploymentId,\n      login: token,\n      password: null,\n    });\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * Authentication.delegating({\n   *   deploymentId: '<YOUR-DELEGATING-AUTHENTICATION-DEPLOYMENT-ID>',\n   *   token: null\n   * })\n   */\n  static delegating({\n    deploymentId = Delegating.DEFAULT_DEPLOYMENT_ID,\n    token,\n  }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_DELEGATING,\n      deploymentId,\n      login: token,\n      password: null,\n    });\n  }\n  static developer({ login, password }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_DEVELOPER,\n      deploymentId: DeployableNames.AUTH_DEVELOPER,\n      login,\n      password,\n    });\n  }\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   * @return {TokenHandshake|CredentialsHandshake}\n   */\n  static create({ authType, deploymentId, login, password }) {\n    if (password === null) {\n      return new TokenHandshake({\n        authType,\n        deploymentId,\n        token: login,\n      });\n    }\n    return new CredentialsHandshake({\n      authType,\n      deploymentId,\n      login,\n      password,\n    });\n  }\n}\n","/**\n * Define life cycle connection methods\n * @access public\n */\nexport class ConnectionStatusListener {\n  /**\n   * Callback fired when connection is broken\n   */\n  onConnectionBroken() {}\n  /**\n   * Callback fired when connection is closed\n   */\n  onConnectionClosed() {}\n  /**\n   * Callback fired when connection is established\n   */\n  onConnectionEstablished() {}\n  /**\n   * Callback fired when an error occurs in connection to server step\n   * @param {Object} failure\n   */\n  onConnectionToServerFail(failure) {}\n  /**\n   * Callback fired when negociation with server failed\n   * @param {Object} failure\n   */\n  onNegotiationFailed(failure) {}\n  /**\n   * Callback no server url avaibale\n   */\n  onNoServerUrlAvailable() {}\n  /**\n   * Callback fired when connection will close\n   */\n  onConnectionWillClose() {}\n  /**\n   * Callback fired when an error occurs in handshake step\n   * @param {Object} failure\n   */\n  onFailedHandshake(failure) {}\n  /**\n   * Callback fired when a message is lost\n   */\n  onMessageLost() {}\n  /**\n   * Callback fired when handshake step succeed\n   * @param {Object} authentication\n   */\n  onSuccessfulHandshake(authentication) {}\n}\n","exports.isString = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return typeof value === 'string' || value instanceof String;\n};\n\nexports.isArray = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return value instanceof Array;\n};\n\n/**\n * Returns whether the given element is contained into the given array.\n * @param element the element to check presence for\n * @param array the array to check for the element presence\n * @return the index of the element, if present, or a negative index if the element is not present\n */\nexports.inArray = function (element, array) {\n    for (var i = 0; i < array.length; ++i) {\n        if (element === array[i]) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nexports.setTimeout = function (cometd, funktion, delay) {\n    return setTimeout(function() {\n        try {\n            cometd._debug('Invoking timed function', funktion);\n            funktion();\n        } catch (x) {\n            cometd._debug('Exception invoking timed function', funktion, x);\n        }\n    }, delay);\n};\n\nexports.clearTimeout = function (timeoutHandle) {\n    clearTimeout(timeoutHandle);\n};\n","module.exports = {\n  LONG_POLLING: 'long-polling',\n  WEBSOCKET: 'websocket'\n}","var Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports.\n */\nmodule.exports = function Transport() {\n    var _type;\n    var _cometd;\n    var _url;\n\n    /**\n     * Function invoked just after a transport has been successfully registered.\n     * @param type the type of transport (for example 'long-polling')\n     * @param cometd the cometd object this transport has been registered to\n     * @see #unregistered()\n     */\n    this.registered = function(type, cometd) {\n        _type = type;\n        _cometd = cometd;\n    };\n\n    /**\n     * Function invoked just after a transport has been successfully unregistered.\n     * @see #registered(type, cometd)\n     */\n    this.unregistered = function() {\n        _type = null;\n        _cometd = null;\n    };\n\n    this._debug = function() {\n        _cometd._debug.apply(_cometd, arguments);\n    };\n\n    this._mixin = function() {\n        return _cometd._mixin.apply(_cometd, arguments);\n    };\n\n    this.getConfiguration = function() {\n        return _cometd.getConfiguration();\n    };\n\n    this.getAdvice = function() {\n        return _cometd.getAdvice();\n    };\n\n    this.setTimeout = function(funktion, delay) {\n        return Utils.setTimeout(_cometd, funktion, delay);\n    };\n\n    this.clearTimeout = function(handle) {\n        Utils.clearTimeout(handle);\n    };\n\n    /**\n     * Converts the given response into an array of bayeux messages\n     * @param response the response to convert\n     * @return an array of bayeux messages obtained by converting the response\n     */\n    this.convertToMessages = function(response) {\n        if (Utils.isString(response)) {\n            try {\n                return JSON.parse(response);\n            } catch (x) {\n                this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n                throw x;\n            }\n        }\n        if (Utils.isArray(response)) {\n            return response;\n        }\n        if (response === undefined || response === null) {\n            return [];\n        }\n        if (response instanceof Object) {\n            return [response];\n        }\n        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n    };\n\n    /**\n     * Returns whether this transport can work for the given version and cross domain communication case.\n     * @param version a string indicating the transport version\n     * @param crossDomain a boolean indicating whether the communication is cross domain\n     * @param url the URL to connect to\n     * @return true if this transport can work for the given version and cross domain communication case,\n     * false otherwise\n     */\n    this.accept = function(version, crossDomain, url) {\n        throw 'Abstract';\n    };\n\n    /**\n     * Returns the type of this transport.\n     * @see #registered(type, cometd)\n     */\n    this.getType = function() {\n        return _type;\n    };\n\n    this.getURL = function() {\n        return _url;\n    };\n\n    this.setURL = function(url) {\n        _url = url;\n    };\n\n    this.send = function(envelope, metaConnect) {\n        throw 'Abstract';\n    };\n\n    this.reset = function(init) {\n        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n    };\n\n    this.abort = function() {\n        this._debug('Transport', _type, 'aborted');\n    };\n\n    this.toString = function() {\n        return this.getType();\n    };\n};\n\nmodule.exports.derive = function(baseObject) {\n    function F() {\n    }\n\n    F.prototype = baseObject;\n    return new F();\n};\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\n/**\n * Base object with the common functionality for transports based on requests.\n * The key responsibility is to allow at most 2 outstanding requests to the server,\n * to avoid that requests are sent behind a long poll.\n * To achieve this, we have one reserved request for the long poll, and all other\n * requests are serialized one after the other.\n */\nmodule.exports = function RequestTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _requestIds = 0;\n    var _metaConnectRequest = null;\n    var _requests = [];\n    var _envelopes = [];\n\n    function _coalesceEnvelopes(envelope) {\n        while (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes[0];\n            var newEnvelope = envelopeAndRequest[0];\n            var newRequest = envelopeAndRequest[1];\n            if (newEnvelope.url === envelope.url &&\n                newEnvelope.sync === envelope.sync) {\n                _envelopes.shift();\n                envelope.messages = envelope.messages.concat(newEnvelope.messages);\n                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n                continue;\n            }\n            break;\n        }\n    }\n\n    function _transportSend(envelope, request) {\n        this.transportSend(envelope, request);\n        request.expired = false;\n\n        if (!envelope.sync) {\n            var maxDelay = this.getConfiguration().maxNetworkDelay;\n            var delay = maxDelay;\n            if (request.metaConnect === true) {\n                delay += this.getAdvice().timeout;\n            }\n\n            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n            var self = this;\n            request.timeout = self.setTimeout(function() {\n                request.expired = true;\n                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n                var failure = {\n                    reason: errorMessage\n                };\n                var xhr = request.xhr;\n                failure.httpCode = self.xhrStatus(xhr);\n                self.abortXHR(xhr);\n                self._debug(errorMessage);\n                self.complete(request, false, request.metaConnect);\n                envelope.onFailure(xhr, envelope.messages, failure);\n            }, delay);\n        }\n    }\n\n    function _queueSend(envelope) {\n        var requestId = ++_requestIds;\n        var request = {\n            id: requestId,\n            metaConnect: false,\n            envelope: envelope\n        };\n\n        // Consider the metaConnect requests which should always be present\n        if (_requests.length < this.getConfiguration().maxConnections - 1) {\n            _requests.push(request);\n            _transportSend.call(this, envelope, request);\n        } else {\n            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n            _envelopes.push([envelope, request]);\n        }\n    }\n\n    function _metaConnectComplete(request) {\n        var requestId = request.id;\n        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);\n        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n            throw 'Longpoll request mismatch, completing request ' + requestId;\n        }\n\n        // Reset metaConnect request\n        _metaConnectRequest = null;\n    }\n\n    function _complete(request, success) {\n        var index = Utils.inArray(request, _requests);\n        // The index can be negative if the request has been aborted\n        if (index >= 0) {\n            _requests.splice(index, 1);\n        }\n\n        if (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes.shift();\n            var nextEnvelope = envelopeAndRequest[0];\n            var nextRequest = envelopeAndRequest[1];\n            this._debug('Transport dequeued request', nextRequest.id);\n            if (success) {\n                if (this.getConfiguration().autoBatch) {\n                    _coalesceEnvelopes.call(this, nextEnvelope);\n                }\n                _queueSend.call(this, nextEnvelope);\n                this._debug('Transport completed request', request.id, nextEnvelope);\n            } else {\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                var self = this;\n                self.setTimeout(function() {\n                    self.complete(nextRequest, false, nextRequest.metaConnect);\n                    var failure = {\n                        reason: 'Previous request failed'\n                    };\n                    var xhr = nextRequest.xhr;\n                    failure.httpCode = self.xhrStatus(xhr);\n                    nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n                }, 0);\n            }\n        }\n    }\n\n    _self.complete = function(request, success, metaConnect) {\n        if (metaConnect) {\n            _metaConnectComplete.call(this, request);\n        } else {\n            _complete.call(this, request, success);\n        }\n    };\n\n    /**\n     * Performs the actual send depending on the transport type details.\n     * @param envelope the envelope to send\n     * @param request the request information\n     */\n    _self.transportSend = function(envelope, request) {\n        throw 'Abstract';\n    };\n\n    _self.transportSuccess = function(envelope, request, responses) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, true, request.metaConnect);\n            if (responses && responses.length > 0) {\n                envelope.onSuccess(responses);\n            } else {\n                envelope.onFailure(request.xhr, envelope.messages, {\n                    httpCode: 204\n                });\n            }\n        }\n    };\n\n    _self.transportFailure = function(envelope, request, failure) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, false, request.metaConnect);\n            envelope.onFailure(request.xhr, envelope.messages, failure);\n        }\n    };\n\n    function _metaConnectSend(envelope) {\n        if (_metaConnectRequest !== null) {\n            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n        }\n\n        var requestId = ++_requestIds;\n        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);\n        var request = {\n            id: requestId,\n            metaConnect: true,\n            envelope: envelope\n        };\n        _transportSend.call(this, envelope, request);\n        _metaConnectRequest = request;\n    }\n\n    _self.send = function(envelope, metaConnect) {\n        if (metaConnect) {\n            _metaConnectSend.call(this, envelope);\n        } else {\n            _queueSend.call(this, envelope);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        for (var i = 0; i < _requests.length; ++i) {\n            var request = _requests[i];\n            if (request) {\n                this._debug('Aborting request', request);\n                if (!this.abortXHR(request.xhr)) {\n                    this.transportFailure(request.envelope, request, {reason: 'abort'});\n                }\n            }\n        }\n        if (_metaConnectRequest) {\n            this._debug('Aborting metaConnect request', _metaConnectRequest);\n            if (!this.abortXHR(_metaConnectRequest.xhr)) {\n                this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});\n            }\n        }\n        this.reset(true);\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _metaConnectRequest = null;\n        _requests = [];\n        _envelopes = [];\n    };\n\n    _self.abortXHR = function(xhr) {\n        if (xhr) {\n            try {\n                var state = xhr.readyState;\n                xhr.abort();\n                return state !== XMLHttpRequest.UNSENT;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return false;\n    };\n\n    _self.xhrStatus = function(xhr) {\n        if (xhr) {\n            try {\n                return xhr.status;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return -1;\n    };\n\n    return _self;\n};\n","var Transport = require('./Transport');\nvar RequestTransport = require('./RequestTransport');\n\nmodule.exports = function LongPollingTransport() {\n    var _super = new RequestTransport();\n    var _self = Transport.derive(_super);\n    // By default, support cross domain\n    var _supportsCrossDomain = true;\n\n    _self.accept = function(version, crossDomain, url) {\n        return _supportsCrossDomain || !crossDomain;\n    };\n\n    _self.xhrSend = function(packet) {\n        throw 'Abstract';\n    };\n\n    _self.transportSend = function(envelope, request) {\n        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n        var self = this;\n        try {\n            var sameStack = true;\n            request.xhr = this.xhrSend({\n                transport: this,\n                url: envelope.url,\n                sync: envelope.sync,\n                headers: this.getConfiguration().requestHeaders,\n                body: JSON.stringify(envelope.messages),\n                onSuccess: function(response) {\n                    self._debug('Transport', self.getType(), 'received response', response);\n                    var success = false;\n                    try {\n                        var received = self.convertToMessages(response);\n                        if (received.length === 0) {\n                            _supportsCrossDomain = false;\n                            self.transportFailure(envelope, request, {\n                                httpCode: 204\n                            });\n                        } else {\n                            success = true;\n                            self.transportSuccess(envelope, request, received);\n                        }\n                    } catch (x) {\n                        self._debug(x);\n                        if (!success) {\n                            _supportsCrossDomain = false;\n                            var failure = {\n                                exception: x\n                            };\n                            failure.httpCode = self.xhrStatus(request.xhr);\n                            self.transportFailure(envelope, request, failure);\n                        }\n                    }\n                },\n                onError: function(reason, exception) {\n                    self._debug('Transport', self.getType(), 'received error', reason, exception);\n                    _supportsCrossDomain = false;\n                    var failure = {\n                        reason: reason,\n                        exception: exception\n                    };\n                    failure.httpCode = self.xhrStatus(request.xhr);\n                    if (sameStack) {\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        self.setTimeout(function() {\n                            self.transportFailure(envelope, request, failure);\n                        }, 0);\n                    } else {\n                        self.transportFailure(envelope, request, failure);\n                    }\n                }\n            });\n            sameStack = false;\n        } catch (x) {\n            _supportsCrossDomain = false;\n            // Keep the semantic of calling response callbacks asynchronously after the request\n            self.setTimeout(function() {\n                self.transportFailure(envelope, request, {\n                    exception: x\n                });\n            }, 0);\n        }\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _supportsCrossDomain = true;\n    };\n\n    return _self;\n};\n","var Transport = require('./Transport')\nvar LongPollingTransport = require('./LongPollingTransport')\n\n/**\n * Implements LongPollingTransport using borwser fetch() API\n * @access private\n * @return {FetchLongPollingTransport}\n */\nfunction FetchLongPollingTransport() {\n  var _super = new LongPollingTransport()\n  var that = Transport.derive(_super)\n\n  /**\n   * Implements transport via fetch() API\n   * @param {Object} packet\n   */\n  that.xhrSend = function (packet) {\n    FetchLongPollingTransport.fetch(packet.url, {\n      method: 'post',\n      body: packet.body,\n      headers: Object.assign(packet.headers, {\n        'Content-Type': 'application/json;charset=UTF-8'\n      })\n    })\n    .then(function (response) {\n      return response.json()\n    })\n    .then(packet.onSuccess)\n    .catch(packet.onError)\n  }\n\n  return that\n}\n\n// Reference global WebSocket \nFetchLongPollingTransport.fetch = 'Abstract'\n\n// Export FetchLongPollingTransport\nmodule.exports = FetchLongPollingTransport;\n","var Transport = require('./Transport');\nvar Utils = require('./Utils');\n\nfunction WebSocketTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _cometd;\n    // By default WebSocket is supported\n    var _webSocketSupported = true;\n    // Whether we were able to establish a WebSocket connection\n    var _webSocketConnected = false;\n    var _stickyReconnect = true;\n    // The context contains the envelopes that have been sent\n    // and the timeouts for the messages that have been sent.\n    var _context = null;\n    var _connecting = null;\n    var _connected = false;\n    var _successCallback = null;\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _webSocketSupported = true;\n        if (init) {\n            _webSocketConnected = false;\n        }\n        _stickyReconnect = true;\n        _context = null;\n        _connecting = null;\n        _connected = false;\n    };\n\n    function _forceClose(context, event) {\n        if (context) {\n            this.webSocketClose(context, event.code, event.reason);\n            // Force immediate failure of pending messages to trigger reconnect.\n            // This is needed because the server may not reply to our close()\n            // and therefore the onclose function is never called.\n            this.onClose(context, event);\n        }\n    }\n\n    function _sameContext(context) {\n        return context === _connecting || context === _context;\n    }\n\n    function _storeEnvelope(context, envelope, metaConnect) {\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            var message = envelope.messages[i];\n            if (message.id) {\n                messageIds.push(message.id);\n            }\n        }\n        context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n    }\n\n    function _websocketConnect(context) {\n        // We may have multiple attempts to open a WebSocket\n        // connection, for example a /meta/connect request that\n        // may take time, along with a user-triggered publish.\n        // Early return if we are already connecting.\n        if (_connecting) {\n            return;\n        }\n\n        // Mangle the URL, changing the scheme from 'http' to 'ws'.\n        var url = _cometd.getURL().replace(/^http/, 'ws');\n        this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n        try {\n            var protocol = _cometd.getConfiguration().protocol;\n            var WebSocket = WebSocketTransport.WebSocket;\n            context.webSocket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);\n            _connecting = context;\n        } catch (x) {\n            _webSocketSupported = false;\n            this._debug('Exception while creating WebSocket object', x);\n            throw x;\n        }\n\n        // By default use sticky reconnects.\n        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\n        var self = this;\n        var connectTimeout = _cometd.getConfiguration().connectTimeout;\n        if (connectTimeout > 0) {\n            context.connectTimer = self.setTimeout(function() {\n                _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n                // The connection was not opened, close anyway.\n                _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n            }, connectTimeout);\n        }\n\n        var onopen = function() {\n            _cometd._debug('WebSocket onopen', context);\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            if (_sameContext(context)) {\n                _connecting = null;\n                _context = context;\n                _webSocketConnected = true;\n                self.onOpen(context);\n            } else {\n                // We have a valid connection already, close this one.\n                _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n                _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n            }\n        };\n\n        // This callback is invoked when the server sends the close frame.\n        // The close frame for a connection may arrive *after* another\n        // connection has been opened, so we must make sure that actions\n        // are performed only if it's the same connection.\n        var onclose = function(event) {\n            event = event || {code: 1000};\n            _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            self.onClose(context, event);\n        };\n\n        var onmessage = function(wsMessage) {\n            _cometd._debug('WebSocket onmessage', wsMessage, context);\n            self.onMessage(context, wsMessage);\n        };\n\n        context.webSocket.onopen = onopen;\n        context.webSocket.onclose = onclose;\n        context.webSocket.onerror = function() {\n            // Clients should call onclose(), but if they do not we do it here for safety.\n            onclose({code: 1000, reason: 'Error'});\n        };\n        context.webSocket.onmessage = onmessage;\n\n        this._debug('Transport', this.getType(), 'configured callbacks on', context);\n    }\n\n    function _webSocketSend(context, envelope, metaConnect) {\n        var json = JSON.stringify(envelope.messages);\n        context.webSocket.send(json);\n        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);\n\n        // Manage the timeout waiting for the response.\n        var maxDelay = this.getConfiguration().maxNetworkDelay;\n        var delay = maxDelay;\n        if (metaConnect) {\n            delay += this.getAdvice().timeout;\n            _connected = true;\n        }\n\n        var self = this;\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            (function() {\n                var message = envelope.messages[i];\n                if (message.id) {\n                    messageIds.push(message.id);\n                    context.timeouts[message.id] = self.setTimeout(function() {\n                        _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n                        _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n                    }, delay);\n                }\n            })();\n        }\n\n        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n    }\n\n    _self._notifySuccess = function(fn, messages) {\n        fn.call(this, messages);\n    };\n\n    _self._notifyFailure = function(fn, context, messages, failure) {\n        fn.call(this, context, messages, failure);\n    };\n\n    function _send(context, envelope, metaConnect) {\n        try {\n            if (context === null) {\n                context = _connecting || {\n                        envelopes: {},\n                        timeouts: {}\n                    };\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _websocketConnect.call(this, context);\n            } else {\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        } catch (x) {\n            // Keep the semantic of calling response callbacks asynchronously after the request.\n            var self = this;\n            self.setTimeout(function() {\n                _forceClose.call(self, context, {\n                    code: 1000,\n                    reason: 'Exception',\n                    exception: x\n                });\n            }, 0);\n        }\n    }\n\n    _self.onOpen = function(context) {\n        var envelopes = context.envelopes;\n        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var element = envelopes[key];\n                var envelope = element[0];\n                var metaConnect = element[1];\n                // Store the success callback, which is independent from the envelope,\n                // so that it can be used to notify arrival of messages.\n                _successCallback = envelope.onSuccess;\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        }\n    };\n\n    _self.onMessage = function(context, wsMessage) {\n        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n        var close = false;\n        var messages = this.convertToMessages(wsMessage.data);\n        var messageIds = [];\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n\n            // Detect if the message is a response to a request we made.\n            // If it's a meta message, for sure it's a response; otherwise it's\n            // a publish message and publish responses don't have the data field.\n            if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n                if (message.id) {\n                    messageIds.push(message.id);\n\n                    var timeout = context.timeouts[message.id];\n                    if (timeout) {\n                        this.clearTimeout(timeout);\n                        delete context.timeouts[message.id];\n                        this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n                    }\n                }\n            }\n\n            if ('/meta/connect' === message.channel) {\n                _connected = false;\n            }\n            if ('/meta/disconnect' === message.channel && !_connected) {\n                close = true;\n            }\n        }\n\n        // Remove the envelope corresponding to the messages.\n        var removed = false;\n        var envelopes = context.envelopes;\n        for (var j = 0; j < messageIds.length; ++j) {\n            var id = messageIds[j];\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var ids = key.split(',');\n                    var index = Utils.inArray(id, ids);\n                    if (index >= 0) {\n                        removed = true;\n                        ids.splice(index, 1);\n                        var envelope = envelopes[key][0];\n                        var metaConnect = envelopes[key][1];\n                        delete envelopes[key];\n                        if (ids.length > 0) {\n                            envelopes[ids.join(',')] = [envelope, metaConnect];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if (removed) {\n            this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n        }\n\n        this._notifySuccess(_successCallback, messages);\n\n        if (close) {\n            this.webSocketClose(context, 1000, 'Disconnect');\n        }\n    };\n\n    _self.onClose = function(context, event) {\n        this._debug('Transport', this.getType(), 'closed', context, event);\n\n        if (_sameContext(context)) {\n            // Remember if we were able to connect.\n            // This close event could be due to server shutdown,\n            // and if it restarts we want to try websocket again.\n            _webSocketSupported = _stickyReconnect && _webSocketConnected;\n            _connecting = null;\n            _context = null;\n        }\n\n        var timeouts = context.timeouts;\n        context.timeouts = {};\n        for (var id in timeouts) {\n            if (timeouts.hasOwnProperty(id)) {\n                this.clearTimeout(timeouts[id]);\n            }\n        }\n\n        var envelopes = context.envelopes;\n        context.envelopes = {};\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var envelope = envelopes[key][0];\n                var metaConnect = envelopes[key][1];\n                if (metaConnect) {\n                    _connected = false;\n                }\n                var failure = {\n                    websocketCode: event.code,\n                    reason: event.reason\n                };\n                if (event.exception) {\n                    failure.exception = event.exception;\n                }\n                this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n            }\n        }\n    };\n\n    _self.registered = function(type, cometd) {\n        _super.registered(type, cometd);\n        _cometd = cometd;\n    };\n\n    _self.accept = function(version, crossDomain, url) {\n        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n        // Using !! to return a boolean (and not the WebSocket object).\n        return _webSocketSupported && !('string' === typeof WebSocketTransport.WebSocket) && _cometd.websocketEnabled !== false;\n    };\n\n    _self.send = function(envelope, metaConnect) {\n        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);\n        _send.call(this, _context, envelope, metaConnect);\n    };\n\n    _self.webSocketClose = function(context, code, reason) {\n        try {\n            if (context.webSocket) {\n                context.webSocket.close(code, reason);\n            }\n        } catch (x) {\n            this._debug(x);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n        this.reset(true);\n    };\n\n    return _self;\n};\n\n// Reference global WebSocket \nWebSocketTransport.WebSocket = 'Abstract';\n\n// Export WebSocketTransport\nmodule.exports = WebSocketTransport;\n","var TRANSPORT_TYPES = require('../TransportTypes');\n\nvar FetchLongPollingTransport = require('../FetchLongPollingTransport');\nvar WebSocketTransport = require('../WebSocketTransport');\n\n// Use node-fetch implementation\nmodule.exports.fetch = FetchLongPollingTransport.fetch = function() {\n  return fetch.apply(window, arguments);\n};\n\n// Use node-websocket implementation\nmodule.exports.WebSocket = WebSocketTransport.WebSocket = typeof WebSocket === 'undefined' ? null : WebSocket;\n\n/**\n * Long polling transport layer\n */\nvar WEBSOCKET_TRANSPORT = {\n  type: TRANSPORT_TYPES.WEBSOCKET,\n  Transport: WebSocketTransport\n};\nmodule.exports.WEBSOCKET_TRANSPORT = WEBSOCKET_TRANSPORT;\n\n/**\n * Long polling transport layer\n */\nvar LONG_POLLING_TRANSPORT = {\n  type: TRANSPORT_TYPES.LONG_POLLING,\n  Transport: FetchLongPollingTransport\n};\nmodule.exports.LONG_POLLING_TRANSPORT = LONG_POLLING_TRANSPORT;\n\n/**\n * CometD Transports Layers map\n */\nvar ALL = [\n  WEBSOCKET_TRANSPORT,\n  LONG_POLLING_TRANSPORT\n];\nmodule.exports.ALL = ALL;\n","var TransportRegistry = require('./TransportRegistry');\nvar Utils = require('./Utils');\n/**\n * The constructor for a CometD object, identified by an optional name.\n * The default name is the string 'default'.\n * In the rare case a page needs more than one Bayeux conversation,\n * a new instance can be created via:\n * <pre>\n * var bayeuxUrl2 = ...;\n *\n * // Dojo style\n * var cometd2 = new dojox.CometD('another_optional_name');\n *\n * // jQuery style\n * var cometd2 = new $.CometD('another_optional_name');\n *\n * cometd2.init({url: bayeuxUrl2});\n * </pre>\n * @param name the optional name of this cometd object\n */\nmodule.exports = function CometD(name) {\n    var _cometd = this;\n    var _name = name || 'default';\n    var _crossDomain = false;\n    var _transports = new TransportRegistry();\n    var _transport;\n    var _status = 'disconnected';\n    var _messageId = 0;\n    var _clientId = null;\n    var _batch = 0;\n    var _messageQueue = [];\n    var _internalBatch = false;\n    var _listeners = {};\n    var _backoff = 0;\n    var _scheduledSend = null;\n    var _extensions = [];\n    var _advice = {};\n    var _handshakeProps;\n    var _handshakeCallback;\n    var _callbacks = {};\n    var _remoteCalls = {};\n    var _reestablish = false;\n    var _connected = false;\n    var _unconnectTime = 0;\n    var _handshakeMessages = 0;\n    var _config = {\n        protocol: null,\n        stickyReconnect: true,\n        connectTimeout: 0,\n        maxConnections: 2,\n        backoffIncrement: 1000,\n        maxBackoff: 60000,\n        logLevel: 'info',\n        reverseIncomingExtensions: true,\n        maxNetworkDelay: 10000,\n        requestHeaders: {},\n        appendMessageTypeToURL: true,\n        autoBatch: false,\n        urls: {},\n        maxURILength: 2000,\n        advice: {\n            timeout: 60000,\n            interval: 0,\n            reconnect: 'retry',\n            maxInterval: 0\n        }\n    };\n\n    function _fieldValue(object, name) {\n        try {\n            return object[name];\n        } catch (x) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Mixes in the given objects into the target object by copying the properties.\n     * @param deep if the copy must be deep\n     * @param target the target object\n     * @param objects the objects whose properties are copied into the target\n     */\n    this._mixin = function(deep, target, objects) {\n        var result = target || {};\n\n        // Skip first 2 parameters (deep and target), and loop over the others\n        for (var i = 2; i < arguments.length; ++i) {\n            var object = arguments[i];\n\n            if (object === undefined || object === null) {\n                continue;\n            }\n\n            for (var propName in object) {\n                if (object.hasOwnProperty(propName)) {\n                    var prop = _fieldValue(object, propName);\n                    var targ = _fieldValue(result, propName);\n\n                    // Avoid infinite loops\n                    if (prop === target) {\n                        continue;\n                    }\n                    // Do not mixin undefined values\n                    if (prop === undefined) {\n                        continue;\n                    }\n\n                    if (deep && typeof prop === 'object' && prop !== null) {\n                        if (prop instanceof Array) {\n                            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n                        } else {\n                            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                            result[propName] = this._mixin(deep, source, prop);\n                        }\n                    } else {\n                        result[propName] = prop;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    function _isString(value) {\n        return Utils.isString(value);\n    }\n\n    function _isFunction(value) {\n        if (value === undefined || value === null) {\n            return false;\n        }\n        return typeof value === 'function';\n    }\n\n    function _zeroPad(value, length) {\n        var result = '';\n        while (--length > 0) {\n            if (value >= Math.pow(10, length)) {\n                break;\n            }\n            result += '0';\n        }\n        result += value;\n        return result;\n    }\n\n    function _log(level, args) {\n        if ('undefined' !== typeof console) {\n            var logger = console[level];\n            if (_isFunction(logger)) {\n                var now = new Date();\n                [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n                logger.apply(console, args);\n            }\n        }\n    }\n\n    this._warn = function() {\n        _log('warn', arguments);\n    };\n\n    this._info = function() {\n        if (_config.logLevel !== 'warn') {\n            _log('info', arguments);\n        }\n    };\n\n    this._debug = function() {\n        if (_config.logLevel === 'debug') {\n            _log('debug', arguments);\n        }\n    };\n\n    function _splitURL(url) {\n        // [1] = protocol://,\n        // [2] = host:port,\n        // [3] = host,\n        // [4] = IPv6_host,\n        // [5] = IPv4_host,\n        // [6] = :port,\n        // [7] = port,\n        // [8] = uri,\n        // [9] = rest (query / fragment)\n        return /(^https?:\\/\\/)?(((\\[[^\\]]+\\])|([^:\\/\\?#]+))(:(\\d+))?)?([^\\?#]*)(.*)?/.exec(url);\n    }\n\n    /**\n     * Returns whether the given hostAndPort is cross domain.\n     * The default implementation checks against window.location.host\n     * but this function can be overridden to make it work in non-browser\n     * environments.\n     *\n     * @param hostAndPort the host and port in format host:port\n     * @return whether the given hostAndPort is cross domain\n     */\n    this._isCrossDomain = function(hostAndPort) {\n        var host = typeof location === 'undefined' ? hostAndPort : location.host;\n        return hostAndPort && hostAndPort !== host;\n    };\n\n    function _configure(configuration) {\n        _cometd._debug('Configuring cometd object with', configuration);\n        // Support old style param, where only the Bayeux server URL was passed\n        if (_isString(configuration)) {\n            configuration = { url: configuration };\n        }\n        if (!configuration) {\n            configuration = {};\n        }\n\n        _config = _cometd._mixin(false, _config, configuration);\n\n        var url = _cometd.getURL();\n        if (!url) {\n            throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n        }\n\n        // Check if we're cross domain.\n        var urlParts = _splitURL(url);\n        var hostAndPort = urlParts[2];\n        var uri = urlParts[8];\n        var afterURI = urlParts[9];\n        _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\n        // Check if appending extra path is supported\n        if (_config.appendMessageTypeToURL) {\n            if (afterURI !== undefined && afterURI.length > 0) {\n                _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                _config.appendMessageTypeToURL = false;\n            } else {\n                var uriSegments = uri.split('/');\n                var lastSegmentIndex = uriSegments.length - 1;\n                if (uri.match(/\\/$/)) {\n                    lastSegmentIndex -= 1;\n                }\n                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n                    // It will be difficult to add the extra path in this case\n                    _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                    _config.appendMessageTypeToURL = false;\n                }\n            }\n        }\n    }\n\n    function _removeListener(subscription) {\n        if (subscription) {\n            var subscriptions = _listeners[subscription.channel];\n            if (subscriptions && subscriptions[subscription.id]) {\n                delete subscriptions[subscription.id];\n                _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n            }\n        }\n    }\n\n    function _removeSubscription(subscription) {\n        if (subscription && !subscription.listener) {\n            _removeListener(subscription);\n        }\n    }\n\n    function _clearSubscriptions() {\n        for (var channel in _listeners) {\n            if (_listeners.hasOwnProperty(channel)) {\n                var subscriptions = _listeners[channel];\n                if (subscriptions) {\n                    for (var i = 0; i < subscriptions.length; ++i) {\n                        _removeSubscription(subscriptions[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    function _setStatus(newStatus) {\n        if (_status !== newStatus) {\n            _cometd._debug('Status', _status, '->', newStatus);\n            _status = newStatus;\n        }\n    }\n\n    function _isDisconnected() {\n        return _status === 'disconnecting' || _status === 'disconnected';\n    }\n\n    function _nextMessageId() {\n        var result = ++_messageId;\n        return '' + result;\n    }\n\n    function _applyExtension(scope, callback, name, message, outgoing) {\n        try {\n            return callback.call(scope, message);\n        } catch (x) {\n            var handler = _cometd.onExtensionException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking extension exception handler', name, x);\n                try {\n                    handler.call(_cometd, x, name, outgoing, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of extension exception handler', name, xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of extension', name, x);\n            }\n            return message;\n        }\n    }\n\n    function _applyIncomingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;\n            var extension = _extensions[index];\n            var callback = extension.extension.incoming;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _applyOutgoingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var extension = _extensions[i];\n            var callback = extension.extension.outgoing;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _notify(channel, message) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions && subscriptions.length > 0) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                var subscription = subscriptions[i];\n                // Subscriptions may come and go, so the array may have 'holes'\n                if (subscription) {\n                    try {\n                        subscription.callback.call(subscription.scope, message);\n                    } catch (x) {\n                        var handler = _cometd.onListenerException;\n                        if (_isFunction(handler)) {\n                            _cometd._debug('Invoking listener exception handler', subscription, x);\n                            try {\n                                handler.call(_cometd, x, subscription, subscription.listener, message);\n                            } catch (xx) {\n                                _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                            }\n                        } else {\n                            _cometd._info('Exception during execution of listener', subscription, message, x);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function _notifyListeners(channel, message) {\n        // Notify direct listeners\n        _notify(channel, message);\n\n        // Notify the globbing listeners\n        var channelParts = channel.split('/');\n        var last = channelParts.length - 1;\n        for (var i = last; i > 0; --i) {\n            var channelPart = channelParts.slice(0, i).join('/') + '/*';\n            // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n            // so we stop at the first non recursive globbing\n            if (i === last) {\n                _notify(channelPart, message);\n            }\n            // Add the recursive globber and notify\n            channelPart += '*';\n            _notify(channelPart, message);\n        }\n    }\n\n    function _cancelDelayedSend() {\n        if (_scheduledSend !== null) {\n            Utils.clearTimeout(_scheduledSend);\n        }\n        _scheduledSend = null;\n    }\n\n    function _delayedSend(operation, delay) {\n        if ('undefined' === typeof delay) {\n          delay = _backoff\n        }\n        _cancelDelayedSend();\n        var time = _advice.interval + delay;\n        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n        _scheduledSend = Utils.setTimeout(_cometd, operation, time);\n    }\n\n    // Needed to break cyclic dependencies between function definitions\n    var _handleMessages;\n    var _handleFailure;\n\n    /**\n     * Delivers the messages to the CometD server\n     * @param sync whether the send is synchronous\n     * @param messages the array of messages to send\n     * @param metaConnect true if this send is on /meta/connect\n     * @param extraPath an extra path to append to the Bayeux server URL\n     */\n    function _send(sync, messages, metaConnect, extraPath) {\n        // We must be sure that the messages have a clientId.\n        // This is not guaranteed since the handshake may take time to return\n        // (and hence the clientId is not known yet) and the application\n        // may create other messages.\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var messageId = message.id;\n\n            if (_clientId) {\n                message.clientId = _clientId;\n            }\n\n            message = _applyOutgoingExtensions(message);\n            if (message !== undefined && message !== null) {\n                // Extensions may have modified the message id, but we need to own it.\n                message.id = messageId;\n                messages[i] = message;\n            } else {\n                delete _callbacks[messageId];\n                messages.splice(i--, 1);\n            }\n        }\n\n        if (messages.length === 0) {\n            return;\n        }\n\n        var url = _cometd.getURL();\n        if (_config.appendMessageTypeToURL) {\n            // If url does not end with '/', then append it\n            if (!url.match(/\\/$/)) {\n                url = url + '/';\n            }\n            if (extraPath) {\n                url = url + extraPath;\n            }\n        }\n\n        var envelope = {\n            url: url,\n            sync: sync,\n            messages: messages,\n            onSuccess: function(rcvdMessages) {\n                try {\n                    _handleMessages.call(_cometd, rcvdMessages);\n                } catch (x) {\n                    _cometd._info('Exception during handling of messages', x);\n                }\n            },\n            onFailure: function(conduit, messages, failure) {\n                try {\n                    var transport = _cometd.getTransport();\n                    failure.connectionType = transport ? transport.getType() : \"unknown\";\n                    _handleFailure.call(_cometd, conduit, messages, failure);\n                } catch (x) {\n                    _cometd._info('Exception during handling of failure', x);\n                }\n            }\n        };\n        _cometd._debug('Send', envelope);\n        _transport.send(envelope, metaConnect);\n    }\n\n    function _queueSend(message) {\n        if (_batch > 0 || _internalBatch === true) {\n            _messageQueue.push(message);\n        } else {\n            _send(false, [message], false);\n        }\n    }\n\n    /**\n     * Sends a complete bayeux message.\n     * This method is exposed as a public so that extensions may use it\n     * to send bayeux message directly, for example in case of re-sending\n     * messages that have already been sent but that for some reason must\n     * be resent.\n     */\n    this.send = _queueSend;\n\n    function _resetBackoff() {\n        _backoff = 0;\n    }\n\n    function _increaseBackoff() {\n        if (_backoff < _config.maxBackoff) {\n            _backoff += _config.backoffIncrement;\n        }\n        return _backoff;\n    }\n\n    /**\n     * Starts a the batch of messages to be sent in a single request.\n     * @see #_endBatch(sendMessages)\n     */\n    function _startBatch() {\n        ++_batch;\n        _cometd._debug('Starting batch, depth', _batch);\n    }\n\n    function _flushBatch() {\n        var messages = _messageQueue;\n        _messageQueue = [];\n        if (messages.length > 0) {\n            _send(false, messages, false);\n        }\n    }\n\n    /**\n     * Ends the batch of messages to be sent in a single request,\n     * optionally sending messages present in the message queue depending\n     * on the given argument.\n     * @see #_startBatch()\n     */\n    function _endBatch() {\n        --_batch;\n        _cometd._debug('Ending batch, depth', _batch);\n        if (_batch < 0) {\n            throw 'Calls to startBatch() and endBatch() are not paired';\n        }\n\n        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n            _flushBatch();\n        }\n    }\n\n    /**\n     * Sends the connect message\n     */\n    function _connect() {\n        if (!_isDisconnected()) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/connect',\n                connectionType: _transport.getType()\n            };\n\n            // In case of reload or temporary loss of connection\n            // we want the next successful connect to return immediately\n            // instead of being held by the server, so that connect listeners\n            // can be notified that the connection has been re-established\n            if (!_connected) {\n                bayeuxMessage.advice = { timeout: 0 };\n            }\n\n            _setStatus('connecting');\n            _cometd._debug('Connect sent', bayeuxMessage);\n            _send(false, [bayeuxMessage], true, 'connect');\n            _setStatus('connected');\n        }\n    }\n\n    function _delayedConnect(delay) {\n        _setStatus('connecting');\n        _delayedSend(function() {\n            _connect();\n        }, delay);\n    }\n\n    function _updateAdvice(newAdvice) {\n        if (newAdvice) {\n            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n            _cometd._debug('New advice', _advice);\n        }\n    }\n\n    function _disconnect(abort) {\n        _cancelDelayedSend();\n        if (abort && _transport) {\n            _transport.abort();\n        }\n        _clientId = null;\n        _setStatus('disconnected');\n        _batch = 0;\n        _resetBackoff();\n        _transport = null;\n\n        // Fail any existing queued message\n        if (_messageQueue.length > 0) {\n            var messages = _messageQueue;\n            _messageQueue = [];\n            _handleFailure.call(_cometd, undefined, messages, {\n                reason: 'Disconnected'\n            });\n        }\n    }\n\n    function _notifyTransportFailure(oldTransport, newTransport, failure) {\n        var handler = _cometd.onTransportException;\n        if (_isFunction(handler)) {\n            _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n            try {\n                handler.call(_cometd, failure, oldTransport, newTransport);\n            } catch (x) {\n                _cometd._info('Exception during execution of transport exception handler', x);\n            }\n        }\n    }\n\n    /**\n     * Sends the initial handshake message\n     */\n    function _handshake(handshakeProps, handshakeCallback) {\n        if (_isFunction(handshakeProps)) {\n            handshakeCallback = handshakeProps;\n            handshakeProps = undefined;\n        }\n\n        _clientId = null;\n\n        _clearSubscriptions();\n\n        // Reset the transports if we're not retrying the handshake\n        if (_isDisconnected()) {\n            _transports.reset(true);\n            _updateAdvice(_config.advice);\n        } else {\n            // We are retrying the handshake, either because another handshake failed\n            // and we're backing off, or because the server timed us out and asks us to\n            // re-handshake: in both cases, make sure that if the handshake succeeds\n            // the next action is a connect.\n            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));\n        }\n\n        _batch = 0;\n\n        // Mark the start of an internal batch.\n        // This is needed because handshake and connect are async.\n        // It may happen that the application calls init() then subscribe()\n        // and the subscribe message is sent before the connect message, if\n        // the subscribe message is not held until the connect message is sent.\n        // So here we start a batch to hold temporarily any message until\n        // the connection is fully established.\n        _internalBatch = true;\n\n        // Save the properties provided by the user, so that\n        // we can reuse them during automatic re-handshake\n        _handshakeProps = handshakeProps;\n        _handshakeCallback = handshakeCallback;\n\n        var version = '1.0';\n\n        // Figure out the transports to send to the server\n        var url = _cometd.getURL();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            version: version,\n            minimumVersion: version,\n            channel: '/meta/handshake',\n            supportedConnectionTypes: transportTypes,\n            advice: {\n                timeout: _advice.timeout,\n                interval: _advice.interval\n            }\n        };\n        // Do not allow the user to override important fields.\n        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, handshakeCallback);\n\n        // Pick up the first available transport as initial transport\n        // since we don't know if the server supports it\n        if (!_transport) {\n            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n            if (!_transport) {\n                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                _cometd._warn(failure);\n                throw failure;\n            }\n        }\n\n        _cometd._debug('Initial transport is', _transport.getType());\n\n        // We started a batch to hold the application messages,\n        // so here we must bypass it and send immediately.\n        _setStatus('handshaking');\n        _cometd._debug('Handshake sent', message);\n        _send(false, [message], false, 'handshake');\n    }\n\n    function _delayedHandshake(delay) {\n        _setStatus('handshaking');\n\n        // We will call _handshake() which will reset _clientId, but we want to avoid\n        // that between the end of this method and the call to _handshake() someone may\n        // call publish() (or other methods that call _queueSend()).\n        _internalBatch = true;\n\n        _delayedSend(function() {\n            _handshake(_handshakeProps, _handshakeCallback);\n        }, delay);\n    }\n\n    function _notifyCallback(callback, message) {\n        try {\n            callback.call(_cometd, message);\n        } catch (x) {\n            var handler = _cometd.onCallbackException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking callback exception handler', x);\n                try {\n                    handler.call(_cometd, x, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of callback exception handler', xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of message callback', x);\n            }\n        }\n    }\n\n    this._getCallback = function(messageId) {\n        return _callbacks[messageId];\n    };\n\n    this._putCallback = function(messageId, callback) {\n        var result = this._getCallback(messageId);\n        if (_isFunction(callback)) {\n            _callbacks[messageId] = callback;\n        }\n        return result;\n    };\n\n    function _handleCallback(message) {\n        var callback = _cometd._getCallback([message.id]);\n        if (_isFunction(callback)) {\n            delete _callbacks[message.id];\n            _notifyCallback(callback, message);\n        }\n    }\n\n    function _handleRemoteCall(message) {\n        var context = _remoteCalls[message.id];\n        delete _remoteCalls[message.id];\n        _cometd._debug('Handling remote call response for', message, 'with context', context);\n        if (context) {\n            // Clear the timeout, if present.\n            var timeout = context.timeout;\n            if (timeout) {\n                Utils.clearTimeout(timeout);\n            }\n\n            var callback = context.callback;\n            if (_isFunction(callback)) {\n                _notifyCallback(callback, message);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _failHandshake(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/handshake', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // Only try again if we haven't been disconnected and\n        // the advice permits us to retry the handshake\n        var retry = !_isDisconnected() && _advice.reconnect !== 'none';\n        if (retry) {\n            _increaseBackoff();\n            _delayedHandshake();\n        } else {\n            _disconnect(true);\n        }\n    }\n\n    function _handshakeResponse(message) {\n        if (message.successful) {\n            // Save clientId, figure out transport, then follow the advice to connect\n            _clientId = message.clientId;\n\n            var url = _cometd.getURL();\n            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);\n            if (newTransport === null) {\n                var failure = 'Could not negotiate transport with server; client=[' +\n                    _transports.findTransportTypes(message.version, _crossDomain, url) +\n                    '], server=[' + message.supportedConnectionTypes + ']';\n                var oldTransport = _cometd.getTransport();\n                _notifyTransportFailure(oldTransport.getType(), null, {\n                    reason: failure,\n                    connectionType: oldTransport.getType(),\n                    transport: oldTransport\n                });\n                _cometd._warn(failure);\n                _disconnect(true);\n                return;\n            } else if (_transport !== newTransport) {\n                _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n                _transport = newTransport;\n            }\n\n            // End the internal batch and allow held messages from the application\n            // to go to the server (see _handshake() where we start the internal batch).\n            _internalBatch = false;\n            _flushBatch();\n\n            // Here the new transport is in place, as well as the clientId, so\n            // the listeners can perform a publish() if they want.\n            // Notify the listeners before the connect below.\n            message.reestablish = _reestablish;\n            _reestablish = true;\n\n            _handleCallback(message);\n            _notifyListeners('/meta/handshake', message);\n\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    _disconnect(true);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failHandshake(message);\n        }\n    }\n\n    function _handshakeFailure(message) {\n        var version = '1.0';\n        var url = _cometd.getURL();\n        var oldTransport = _cometd.getTransport();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n        var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n        if (!newTransport) {\n            _notifyTransportFailure(oldTransport.getType(), null, message.failure);\n            _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');\n            _disconnect(true);\n            _failHandshake(message);\n        } else {\n            _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());\n            _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);\n            _failHandshake(message);\n            _transport = newTransport;\n        }\n    }\n\n    function _failConnect(message) {\n        // Notify the listeners after the status change but before the next action\n        _notifyListeners('/meta/connect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // This may happen when the server crashed, the current clientId\n        // will be invalid, and the server will ask to handshake again\n        // Listeners can call disconnect(), so check the state after they run\n        var action = _isDisconnected() ? 'none' : _advice.reconnect;\n        switch (action) {\n            case 'retry':\n                _delayedConnect();\n                _increaseBackoff();\n                break;\n            case 'handshake':\n                // The current transport may be failed (e.g. network disconnection)\n                // Reset the transports so the new handshake picks up the right one\n                _transports.reset(true);\n                _resetBackoff();\n                _delayedHandshake();\n                break;\n            case 'none':\n                _disconnect(true);\n                break;\n            default:\n                throw 'Unrecognized advice action' + action;\n        }\n    }\n\n    function _connectResponse(message) {\n        _connected = message.successful;\n\n        if (_connected) {\n            _notifyListeners('/meta/connect', message);\n\n            // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n            // and the server will hold the request, so when a response returns\n            // we immediately call the server again (long polling)\n            // Listeners can call disconnect(), so check the state after they run\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    // Wait for the /meta/disconnect to arrive.\n                    _disconnect(false);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failConnect(message);\n        }\n    }\n\n    function _connectFailure(message) {\n        _connected = false;\n        _failConnect(message);\n    }\n\n    function _failDisconnect(message) {\n        _disconnect(true);\n        _handleCallback(message);\n        _notifyListeners('/meta/disconnect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _disconnectResponse(message) {\n        if (message.successful) {\n            // Wait for the /meta/connect to arrive.\n            _disconnect(false);\n            _handleCallback(message);\n            _notifyListeners('/meta/disconnect', message);\n        } else {\n            _failDisconnect(message);\n        }\n    }\n\n    function _disconnectFailure(message) {\n        _failDisconnect(message);\n    }\n\n    function _failSubscribe(message) {\n        var subscriptions = _listeners[message.subscription];\n        if (subscriptions) {\n            for (var i = subscriptions.length - 1; i >= 0; --i) {\n                var subscription = subscriptions[i];\n                if (subscription && !subscription.listener) {\n                    delete subscriptions[i];\n                    _cometd._debug('Removed failed subscription', subscription);\n                    break;\n                }\n            }\n        }\n        _handleCallback(message);\n        _notifyListeners('/meta/subscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _subscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/subscribe', message);\n        } else {\n            _failSubscribe(message);\n        }\n    }\n\n    function _subscribeFailure(message) {\n        _failSubscribe(message);\n    }\n\n    function _failUnsubscribe(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/unsubscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _unsubscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/unsubscribe', message);\n        } else {\n            _failUnsubscribe(message);\n        }\n    }\n\n    function _unsubscribeFailure(message) {\n        _failUnsubscribe(message);\n    }\n\n    function _failMessage(message) {\n        if (!_handleRemoteCall(message)) {\n            _handleCallback(message);\n            _notifyListeners('/meta/publish', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n    }\n\n    function _messageResponse(message) {\n        if (message.data !== undefined) {\n            if (!_handleRemoteCall(message)) {\n                _notifyListeners(message.channel, message);\n                if (_handshakeMessages > 0) {\n                    --_handshakeMessages;\n                    if (_handshakeMessages === 0) {\n                        _cometd._debug('Processed last handshake-delivered message');\n                        _delayedConnect(0);\n                    }\n                }\n            }\n        } else {\n            if (message.successful === undefined) {\n                _cometd._warn('Unknown Bayeux Message', message);\n            } else {\n                if (message.successful) {\n                    _handleCallback(message);\n                    _notifyListeners('/meta/publish', message);\n                } else {\n                    _failMessage(message);\n                }\n            }\n        }\n    }\n\n    function _messageFailure(failure) {\n        _failMessage(failure);\n    }\n\n    function _receive(message) {\n        _unconnectTime = 0;\n\n        message = _applyIncomingExtensions(message);\n        if (message === undefined || message === null) {\n            return;\n        }\n\n        _updateAdvice(message.advice);\n\n        var channel = message.channel;\n        switch (channel) {\n            case '/meta/handshake':\n                _handshakeResponse(message);\n                break;\n            case '/meta/connect':\n                _connectResponse(message);\n                break;\n            case '/meta/disconnect':\n                _disconnectResponse(message);\n                break;\n            case '/meta/subscribe':\n                _subscribeResponse(message);\n                break;\n            case '/meta/unsubscribe':\n                _unsubscribeResponse(message);\n                break;\n            default:\n                _messageResponse(message);\n                break;\n        }\n    }\n\n    /**\n     * Receives a message.\n     * This method is exposed as a public so that extensions may inject\n     * messages simulating that they had been received.\n     */\n    this.receive = _receive;\n\n    _handleMessages = function(rcvdMessages) {\n        _cometd._debug('Received', rcvdMessages);\n\n        for (var i = 0; i < rcvdMessages.length; ++i) {\n            var message = rcvdMessages[i];\n            _receive(message);\n        }\n    };\n\n    _handleFailure = function(conduit, messages, failure) {\n        _cometd._debug('handleFailure', conduit, messages, failure);\n\n        failure.transport = conduit;\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var failureMessage = {\n                id: message.id,\n                successful: false,\n                channel: message.channel,\n                failure: failure\n            };\n            failure.message = message;\n            switch (message.channel) {\n                case '/meta/handshake':\n                    _handshakeFailure(failureMessage);\n                    break;\n                case '/meta/connect':\n                    _connectFailure(failureMessage);\n                    break;\n                case '/meta/disconnect':\n                    _disconnectFailure(failureMessage);\n                    break;\n                case '/meta/subscribe':\n                    failureMessage.subscription = message.subscription;\n                    _subscribeFailure(failureMessage);\n                    break;\n                case '/meta/unsubscribe':\n                    failureMessage.subscription = message.subscription;\n                    _unsubscribeFailure(failureMessage);\n                    break;\n                default:\n                    _messageFailure(failureMessage);\n                    break;\n            }\n        }\n    };\n\n    function _hasSubscriptions(channel) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                if (subscriptions[i]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function _resolveScopedCallback(scope, callback) {\n        var delegate = {\n            scope: scope,\n            method: callback\n        };\n        if (_isFunction(scope)) {\n            delegate.scope = undefined;\n            delegate.method = scope;\n        } else {\n            if (_isString(callback)) {\n                if (!scope) {\n                    throw 'Invalid scope ' + scope;\n                }\n                delegate.method = scope[callback];\n                if (!_isFunction(delegate.method)) {\n                    throw 'Invalid callback ' + callback + ' for scope ' + scope;\n                }\n            } else if (!_isFunction(callback)) {\n                throw 'Invalid callback ' + callback;\n            }\n        }\n        return delegate;\n    }\n\n    function _addListener(channel, scope, callback, isListener) {\n        // The data structure is a map<channel, subscription[]>, where each subscription\n        // holds the callback to be called and its scope.\n\n        var delegate = _resolveScopedCallback(scope, callback);\n        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n        var subscription = {\n            channel: channel,\n            scope: delegate.scope,\n            callback: delegate.method,\n            listener: isListener\n        };\n\n        var subscriptions = _listeners[channel];\n        if (!subscriptions) {\n            subscriptions = [];\n            _listeners[channel] = subscriptions;\n        }\n\n        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.\n        // Note that if:\n        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');\n        // then:\n        // hc==3, a.join()=='a',,'c', a.length==3\n        subscription.id = subscriptions.push(subscription) - 1;\n\n        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n        // For backward compatibility: we used to return [channel, subscription.id]\n        subscription[0] = channel;\n        subscription[1] = subscription.id;\n\n        return subscription;\n    }\n\n    //\n    // PUBLIC API\n    //\n\n    /**\n     * Registers the given transport under the given transport type.\n     * The optional index parameter specifies the \"priority\" at which the\n     * transport is registered (where 0 is the max priority).\n     * If a transport with the same type is already registered, this function\n     * does nothing and returns false.\n     * @param type the transport type\n     * @param transport the transport object\n     * @param index the index at which this transport is to be registered\n     * @return true if the transport has been registered, false otherwise\n     * @see #unregisterTransport(type)\n     */\n    this.registerTransport = function(type, transport, index) {\n        var result = _transports.add(type, transport, index);\n        if (result) {\n            this._debug('Registered transport', type);\n\n            if (_isFunction(transport.registered)) {\n                transport.registered(type, this);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Unregisters the transport with the given transport type.\n     * @param type the transport type to unregister\n     * @return the transport that has been unregistered,\n     * or null if no transport was previously registered under the given transport type\n     */\n    this.unregisterTransport = function(type) {\n        var transport = _transports.remove(type);\n        if (transport !== null) {\n            this._debug('Unregistered transport', type);\n\n            if (_isFunction(transport.unregistered)) {\n                transport.unregistered();\n            }\n        }\n        return transport;\n    };\n\n    this.unregisterTransports = function() {\n        _transports.clear();\n    };\n\n    /**\n     * @return an array of all registered transport types\n     */\n    this.getTransportTypes = function() {\n        return _transports.getTransportTypes();\n    };\n\n    this.findTransport = function(name) {\n        return _transports.find(name);\n    };\n\n    /**\n     * @returns the TransportRegistry object\n     */\n    this.getTransportRegistry = function() {\n        return _transports;\n    };\n\n    /**\n     * Configures the initial Bayeux communication with the Bayeux server.\n     * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n     * of type string containing the URL of the Bayeux server.\n     * @param configuration the configuration object\n     */\n    this.configure = function(configuration) {\n        _configure.call(this, configuration);\n    };\n\n    /**\n     * Configures and establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param configuration the configuration object\n     * @param handshakeProps an object to be merged with the handshake message\n     * @see #configure(configuration)\n     * @see #handshake(handshakeProps)\n     */\n    this.init = function(configuration, handshakeProps) {\n        this.configure(configuration);\n        this.handshake(handshakeProps);\n    };\n\n    /**\n     * Establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param handshakeProps an object to be merged with the handshake message\n     * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n     */\n    this.handshake = function(handshakeProps, handshakeCallback) {\n        _setStatus('disconnected');\n        _reestablish = false;\n        _handshake(handshakeProps, handshakeCallback);\n    };\n\n    /**\n     * Disconnects from the Bayeux server.\n     * It is possible to suggest to attempt a synchronous disconnect, but this feature\n     * may only be available in certain transports (for example, long-polling may support\n     * it, callback-polling certainly does not).\n     * @param sync whether attempt to perform a synchronous disconnect\n     * @param disconnectProps an object to be merged with the disconnect message\n     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n     */\n    this.disconnect = function(sync, disconnectProps, disconnectCallback) {\n        if (_isDisconnected()) {\n            return;\n        }\n\n        if (typeof sync !== 'boolean') {\n            disconnectCallback = disconnectProps;\n            disconnectProps = sync;\n            sync = false;\n        }\n        if (_isFunction(disconnectProps)) {\n            disconnectCallback = disconnectProps;\n            disconnectProps = undefined;\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: '/meta/disconnect'\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, disconnectCallback);\n\n        _setStatus('disconnecting');\n        _send(sync === true, [message], false, 'disconnect');\n    };\n\n    /**\n     * Marks the start of a batch of application messages to be sent to the server\n     * in a single request, obtaining a single response containing (possibly) many\n     * application reply messages.\n     * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n     * If startBatch() is called multiple times, then an equal number of endBatch()\n     * calls must be made to close and send the batch of messages.\n     * @see #endBatch()\n     */\n    this.startBatch = function() {\n        _startBatch();\n    };\n\n    /**\n     * Marks the end of a batch of application messages to be sent to the server\n     * in a single request.\n     * @see #startBatch()\n     */\n    this.endBatch = function() {\n        _endBatch();\n    };\n\n    /**\n     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n     * and {@link #endBatch()} calls.\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n     */\n    this.batch = function(scope, callback) {\n        var delegate = _resolveScopedCallback(scope, callback);\n        this.startBatch();\n        try {\n            delegate.method.call(delegate.scope);\n            this.endBatch();\n        } catch (x) {\n            this._info('Exception during execution of batch', x);\n            this.endBatch();\n            throw x;\n        }\n    };\n\n    /**\n     * Adds a listener for bayeux messages, performing the given callback in the given scope\n     * when a message for the given channel arrives.\n     * @param channel the channel the listener is interested to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @returns the subscription handle to be passed to {@link #removeListener(object)}\n     * @see #removeListener(subscription)\n     */\n    this.addListener = function(channel, scope, callback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n\n        return _addListener(channel, scope, callback, true);\n    };\n\n    /**\n     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @see #addListener(channel, scope, callback)\n     */\n    this.removeListener = function(subscription) {\n        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n        if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n            throw 'Invalid argument: expected subscription, not ' + subscription;\n        }\n\n        _removeListener(subscription);\n    };\n\n    /**\n     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n     * {@link #subscribe(channel, scope, callback)}.\n     */\n    this.clearListeners = function() {\n        _listeners = {};\n    };\n\n    /**\n     * Subscribes to the given channel, performing the given callback in the given scope\n     * when a message for the channel arrives.\n     * @param channel the channel to subscribe to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @param subscribeProps an object to be merged with the subscribe message\n     * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n     * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n     */\n    this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        // Normalize arguments\n        if (_isFunction(scope)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = callback;\n            callback = scope;\n            scope = undefined;\n        }\n        if (_isFunction(subscribeProps)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = undefined;\n        }\n\n        // Only send the message to the server if this client has not yet subscribed to the channel\n        var send = !_hasSubscriptions(channel);\n\n        var subscription = _addListener(channel, scope, callback, false);\n\n        if (send) {\n            // Send the subscription message after the subscription registration to avoid\n            // races where the server would send a message to the subscribers, but here\n            // on the client the subscription has not been added yet to the data structures\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/subscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, subscribeCallback);\n\n            _queueSend(message);\n        }\n\n        return subscription;\n    };\n\n    /**\n     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @param unsubscribeProps an object to be merged with the unsubscribe message\n     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n     */\n    this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(unsubscribeProps)) {\n            unsubscribeCallback = unsubscribeProps;\n            unsubscribeProps = undefined;\n        }\n\n        // Remove the local listener before sending the message\n        // This ensures that if the server fails, this client does not get notifications\n        this.removeListener(subscription);\n\n        var channel = subscription.channel;\n        // Only send the message to the server if this client unsubscribes the last subscription\n        if (!_hasSubscriptions(channel)) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/unsubscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, unsubscribeCallback);\n\n            _queueSend(message);\n        }\n    };\n\n    this.resubscribe = function(subscription, subscribeProps) {\n        _removeSubscription(subscription);\n        if (subscription) {\n            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n        }\n        return undefined;\n    };\n\n    /**\n     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n     */\n    this.clearSubscriptions = function() {\n        _clearSubscriptions();\n    };\n\n    /**\n     * Publishes a message on the given channel, containing the given content.\n     * @param channel the channel to publish the message to\n     * @param content the content of the message\n     * @param publishProps an object to be merged with the publish message\n     * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n     */\n    this.publish = function(channel, content, publishProps, publishCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (/^\\/meta\\//.test(channel)) {\n            throw 'Illegal argument: cannot publish to meta channels';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            publishCallback = content;\n            content = publishProps = {};\n        } else if (_isFunction(publishProps)) {\n            publishCallback = publishProps;\n            publishProps = {};\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, publishCallback);\n\n        _queueSend(message);\n    };\n\n    this.remoteCall = function(target, content, timeout, callback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(target)) {\n            throw 'Illegal argument type: target must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            callback = content;\n            content = {};\n            timeout = _config.maxNetworkDelay;\n        } else if (_isFunction(timeout)) {\n            callback = timeout;\n            timeout = _config.maxNetworkDelay;\n        }\n\n        if (typeof timeout !== 'number') {\n            throw 'Illegal argument type: timeout must be a number';\n        }\n\n        if (!target.match(/^\\//)) {\n            target = '/' + target;\n        }\n        var channel = '/service' + target;\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n\n        var context = {\n            callback: callback\n        };\n        if (timeout > 0) {\n            context.timeout = Utils.setTimeout(_cometd, function() {\n                _cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');\n                _failMessage({\n                    id: bayeuxMessage.id,\n                    error: '406::timeout',\n                    successful: false,\n                    failure: {\n                        message : bayeuxMessage,\n                        reason: 'Remote Call Timeout'\n                    }\n                });\n            }, timeout);\n            _cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');\n        }\n        _remoteCalls[bayeuxMessage.id] = context;\n\n        _queueSend(bayeuxMessage);\n    };\n\n    /**\n     * Returns a string representing the status of the bayeux communication with the Bayeux server.\n     */\n    this.getStatus = function() {\n        return _status;\n    };\n\n    /**\n     * Returns whether this instance has been disconnected.\n     */\n    this.isDisconnected = _isDisconnected;\n\n    /**\n     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * Default value is 1 second, which means if there is a persistent failure the retries will happen\n     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n     * @param period the backoff period to set\n     * @see #getBackoffIncrement()\n     */\n    this.setBackoffIncrement = function(period) {\n        _config.backoffIncrement = period;\n    };\n\n    /**\n     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * @see #setBackoffIncrement(period)\n     */\n    this.getBackoffIncrement = function() {\n        return _config.backoffIncrement;\n    };\n\n    /**\n     * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n     */\n    this.getBackoffPeriod = function() {\n        return _backoff;\n    };\n\n    /**\n     * Increases the backoff period up to the maximum value configured.\n     * @returns the backoff period after increment\n     * @see getBackoffIncrement\n     */\n    this.increaseBackoffPeriod = function() {\n        return _increaseBackoff();\n    };\n\n    /**\n     * Resets the backoff period to zero.\n     */\n    this.resetBackoffPeriod = function() {\n        _resetBackoff();\n    };\n\n    /**\n     * Sets the log level for console logging.\n     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n     * less verbose to more verbose.\n     * @param level the log level string\n     */\n    this.setLogLevel = function(level) {\n        _config.logLevel = level;\n    };\n\n    /**\n     * Registers an extension whose callbacks are called for every incoming message\n     * (that comes from the server to this client implementation) and for every\n     * outgoing message (that originates from this client implementation for the\n     * server).\n     * The format of the extension object is the following:\n     * <pre>\n     * {\n     *     incoming: function(message) { ... },\n     *     outgoing: function(message) { ... }\n     * }\n     * </pre>\n     * Both properties are optional, but if they are present they will be called\n     * respectively for each incoming message and for each outgoing message.\n     * @param name the name of the extension\n     * @param extension the extension to register\n     * @return true if the extension was registered, false otherwise\n     * @see #unregisterExtension(name)\n     */\n    this.registerExtension = function(name, extension) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var existing = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var existingExtension = _extensions[i];\n            if (existingExtension.name === name) {\n                existing = true;\n                break;\n            }\n        }\n        if (!existing) {\n            _extensions.push({\n                name: name,\n                extension: extension\n            });\n            this._debug('Registered extension', name);\n\n            // Callback for extensions\n            if (_isFunction(extension.registered)) {\n                extension.registered(name, this);\n            }\n\n            return true;\n        } else {\n            this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n            return false;\n        }\n    };\n\n    /**\n     * Unregister an extension previously registered with\n     * {@link #registerExtension(name, extension)}.\n     * @param name the name of the extension to unregister.\n     * @return true if the extension was unregistered, false otherwise\n     */\n    this.unregisterExtension = function(name) {\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var unregistered = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                _extensions.splice(i, 1);\n                unregistered = true;\n                this._debug('Unregistered extension', name);\n\n                // Callback for extensions\n                var ext = extension.extension;\n                if (_isFunction(ext.unregistered)) {\n                    ext.unregistered();\n                }\n\n                break;\n            }\n        }\n        return unregistered;\n    };\n\n    /**\n     * Find the extension registered with the given name.\n     * @param name the name of the extension to find\n     * @return the extension found or null if no extension with the given name has been registered\n     */\n    this.getExtension = function(name) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                return extension.extension;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns the name assigned to this CometD object, or the string 'default'\n     * if no name has been explicitly passed as parameter to the constructor.\n     */\n    this.getName = function() {\n        return _name;\n    };\n\n    /**\n     * Returns the clientId assigned by the Bayeux server during handshake.\n     */\n    this.getClientId = function() {\n        return _clientId;\n    };\n\n    /**\n     * Returns the URL of the Bayeux server.\n     */\n    this.getURL = function() {\n        if (_transport) {\n            var url = _transport.getURL();\n            if (url) {\n                return url;\n            }\n            url = _config.urls[_transport.getType()];\n            if (url) {\n                return url;\n            }\n        }\n        return _config.url;\n    };\n\n    this.getTransport = function() {\n        return _transport;\n    };\n\n    this.getConfiguration = function() {\n        return this._mixin(true, {}, _config);\n    };\n\n    this.getAdvice = function() {\n        return this._mixin(true, {}, _advice);\n    };\n};\n","/**\n * A registry for transports used by the CometD object.\n */\nmodule.exports = function TransportRegistry() {\n    var _types = [];\n    var _transports = {};\n\n    this.getTransportTypes = function() {\n        return _types.slice(0);\n    };\n\n    this.findTransportTypes = function(version, crossDomain, url) {\n        var result = [];\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            if (_transports[type].accept(version, crossDomain, url) === true) {\n                result.push(type);\n            }\n        }\n        return result;\n    };\n\n    this.negotiateTransport = function(types, version, crossDomain, url) {\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            for (var j = 0; j < types.length; ++j) {\n                if (type === types[j]) {\n                    var transport = _transports[type];\n                    if (transport.accept(version, crossDomain, url) === true) {\n                        return transport;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    this.add = function(type, transport, index) {\n        var existing = false;\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                existing = true;\n                break;\n            }\n        }\n\n        if (!existing) {\n            if (typeof index !== 'number') {\n                _types.push(type);\n            } else {\n                _types.splice(index, 0, type);\n            }\n            _transports[type] = transport;\n        }\n\n        return !existing;\n    };\n\n    this.find = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                return _transports[type];\n            }\n        }\n        return null;\n    };\n\n    this.remove = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                _types.splice(i, 1);\n                var transport = _transports[type];\n                delete _transports[type];\n                return transport;\n            }\n        }\n        return null;\n    };\n\n    this.clear = function() {\n        _types = [];\n        _transports = {};\n    };\n\n    this.reset = function(init) {\n        for (var i = 0; i < _types.length; ++i) {\n            _transports[_types[i]].reset(init);\n        }\n    };\n};\n","import { Service } from './core';\n/**\n * Data aggregation\n *\n * Provides data aggregation over time and across different items\n *  User devices push items data on developer-defined categories\n *  This service automatically aggregates the data\n * Raw data is not available for reading, only the generated aggregation result\n *\n * */\n/**\n * User API for item aggregation\n *\n * Users can push data and be notified of aggregated data.\n * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.\n * @access public\n * */\nexport class Aggreg extends Service {\n  /**\n   * Get default deployment id associated to Aggreg service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'aggreg_0';\n  }\n  /**\n   * Pushes some data\n   *\n   * Pushes the given data.\n   * All the items are processed according to the defined rules.\n   * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.\n   * */\n  push({ items, owner }) {\n    return this.$publish('push', { items, owner });\n  }\n}\n/**\n * Data stacks\n *\n * Stacks are a per-user named persistent queue of data\n *  An administrator creates a stack service\n *  End-users can push data on an arbitrary number of their own arbitrary named stacks\n * */\n/**\n * Data stack user API\n *\n * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.\n * Stack names are arbitrary and do not need to be explicitly initialized.\n * @access public\n * */\nexport class Stack extends Service {\n  /**\n   * Get default deployment id associated to Stack service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'stack_0';\n  }\n  /**\n   * Lists the listeners\n   *\n   * Returns the whole list of listeners for the given stack.\n   * */\n  getListeners({ stack, owner }) {\n    return this.$publish('getListeners', { stack, owner });\n  }\n  /**\n   * Lists content\n   *\n   * Returns a paginated list of contents for the given stack.\n   * Content is sorted according to the statically configured order.\n   * */\n  list({ stack, owner, page }) {\n    return this.$publish('list', { stack, owner, page });\n  }\n  /**\n   * Empties a stack\n   *\n   * Removes all items from the given stack.\n   * */\n  purge({ stack, owner }) {\n    return this.$publish('purge', { stack, owner });\n  }\n  /**\n   * Pushes an item\n   *\n   * Pushes an item onto the given stack.\n   * The stack does not need to be created.\n   * */\n  push({ stack, data, owner }) {\n    return this.$publish('push', { stack, data, owner });\n  }\n  /**\n   * Removes items\n   *\n   * Removes the item with the given guid from the given stack.\n   * */\n  remove({ guids, stack, owner }) {\n    return this.$publish('remove', { guids, stack, owner });\n  }\n  /**\n   * Sets the listeners\n   *\n   * Sets the listeners for the given stack.\n   * */\n  setListeners({ listeners, stack, owner }) {\n    return this.$publish('setListeners', { listeners, stack, owner });\n  }\n  /**\n   * Updates an item\n   *\n   * Updates an existing item of the given stack.\n   * The item MUST exist prior to the call.\n   * */\n  update({ guid, stack, data, owner }) {\n    return this.$publish('update', { guid, stack, data, owner });\n  }\n}\n/**\n * Echo\n *\n * Echo\n * */\n/**\n * Echo service\n *\n * Simple echo service, for development purposes.\n * @access public\n * */\nexport class Echo extends Service {\n  /**\n   * Get default deployment id associated to Echo service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'echo_0';\n  }\n  /**\n   * Echoes an object\n   *\n   * Echoes an object: the server will echo that object on channel 'echo' for the current user.\n   * */\n  echo(parameter) {\n    return this.$publish('echo', parameter);\n  }\n}\n/**\n * Game engine\n *\n * Abstract Game Engine\n *  Concrete game engines are remote cometd clients or internal macros\n * */\n/**\n * User API for games\n *\n * Users can list, start, join games, and play.\n * @access public\n * */\nexport class Game extends Service {\n  /**\n   * Get default deployment id associated to Game service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'game_0';\n  }\n  /**\n   * Lists game types\n   *\n   * Returns the list of game types supported by the server and the currently registered game engines.\n   * */\n  available() {\n    return this.$publish('available', {});\n  }\n  /**A user joins a game*/\n  join({ role, gameId, userId, userName }) {\n    return this.$publish('join', { role, gameId, userId, userName });\n  }\n  /**Organizes a game*/\n  organize({ type, owner, options }) {\n    return this.$publish('organize', { type, owner, options });\n  }\n  /**Gives some command to the game engine*/\n  play({ gameId, userId, data }) {\n    return this.$publish('play', { gameId, userId, data });\n  }\n  /**Starts a game*/\n  start({ gameId }) {\n    return this.$publish('start', { gameId });\n  }\n  /**A user cancels joining a game*/\n  unjoin({ role, gameId, userId, userName }) {\n    return this.$publish('unjoin', { role, gameId, userId, userName });\n  }\n}\n/**\n * Game Engine API\n *\n * The Game Engine API is for game engine clients, not end-users.\n * @access public\n * */\nexport class GameEngine extends Service {\n  /**\n   * Get default deployment id associated to GameEngine service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'game_0';\n  }\n  /**\n   * Notify the result for a join request\n   *\n   * A Game Engine notifies the STR of the result of a join request that it received on join_callback\n   * */\n  join_result({ msgId, payload, error, callerId }) {\n    return this.$publish('join_result', { msgId, payload, error, callerId });\n  }\n  /**\n   * Notify the result for an organization request\n   *\n   * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback\n   * */\n  organize_result({ msgId, payload, error, callerId }) {\n    return this.$publish('organize_result', {\n      msgId,\n      payload,\n      error,\n      callerId,\n    });\n  }\n  /**\n   * Registers a game engine\n   *\n   * A client registers itself to the STR as a Game Engine.\n   * The STR may, from now on, dispatch game of the given game type to said client.\n   * Unregistration is done automatically on logoff.\n   * */\n  register({ maxGames, gameInfo, location }) {\n    return this.$publish('register', { maxGames, gameInfo, location });\n  }\n  /**\n   * Notify the result for a start request\n   *\n   * A Game Engine notifies the STR of the result of a start request that it received on start_callback\n   * */\n  start_result({ gameId }) {\n    return this.$publish('start_result', { gameId });\n  }\n  /**\n   * Notify a game event\n   *\n   * A Game Engine notifies the STR of some arbitrary game event.\n   * */\n  state({ status, gameId, data }) {\n    return this.$publish('state', { status, gameId, data });\n  }\n  /**\n   * Notify the result for an unjoin request\n   *\n   * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback\n   * */\n  unjoin_result({ msgId, payload, error, callerId }) {\n    return this.$publish('unjoin_result', { msgId, payload, error, callerId });\n  }\n}\n/**\n * Generic Data Access\n *\n * Generic Data Access Service : NoSQL storage\n * */\n/**\n * GDA User API\n *\n * User API for Generic Data Access.\n * The data are stored on a per-user basis.\n * Users can put, get, list their data.\n * @access public\n * */\nexport class Gda extends Service {\n  /**\n   * Get default deployment id associated to Gda service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'gda_0';\n  }\n  /**\n   * Asks for a data row\n   *\n   * Returns a full data row.\n   * */\n  get({ table, key, owner }) {\n    return this.$publish('get', { table, key, owner });\n  }\n  /**\n   * Asks for a data cell\n   *\n   * Returns a precise list of cells from a column in a data row.\n   * */\n  getCells({ table, key, key2, owner, column }) {\n    return this.$publish('getCells', { table, key, key2, owner, column });\n  }\n  /**\n   * Increments an integer value\n   *\n   * Increments a cell 64-bit signed integer value and returns the result in the data field.\n   * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.\n   * */\n  inc({ table, data, key, key2, owner, column }) {\n    return this.$publish('inc', { table, data, key, key2, owner, column });\n  }\n  /**\n   * Asks for a list of rows\n   *\n   * Returns a paginated list of rows from the given table.\n   * */\n  list({ columns, table, owner, page }) {\n    return this.$publish('list', { columns, table, owner, page });\n  }\n  /**\n   * Puts some data into a cell\n   *\n   * Creates or replaces the contents of a particular cell.\n   * */\n  put({ table, data, key, key2, owner, column }) {\n    return this.$publish('put', { table, data, key, key2, owner, column });\n  }\n  /**\n   * Puts several rows\n   *\n   * Creates or replaces the (maybe partial) contents of a collection of rows.\n   * This method only creates or replaces cells for non-null input values.\n   * */\n  puts({ rows, table, owner }) {\n    return this.$publish('puts', { rows, table, owner });\n  }\n  /**\n   * Asks for a range of rows\n   *\n   * Returns a paginated range of rows from the given table.\n   * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n   * You can specify partial keys for the start and stop fields.\n   * */\n  range({ columns, start, table, stop, owner, page }) {\n    return this.$publish('range', { columns, start, table, stop, owner, page });\n  }\n  /**\n   * Removes one cell inside a column of a row\n   *\n   * Removes only one cell of the given column of the given row from the given table.\n   * */\n  removeCell({ table, key, key2, owner, column }) {\n    return this.$publish('removeCell', { table, key, key2, owner, column });\n  }\n  /**\n   * Removes one full column of a row\n   *\n   * Removes all cells of the given column of the given row from the given table.\n   * */\n  removeColumn({ table, key, owner, column }) {\n    return this.$publish('removeColumn', { table, key, owner, column });\n  }\n  /**\n   * Removes a range of rows\n   *\n   * Removes the specified columns of the given range of rows from the given table.\n   * */\n  removeRange({ columns, start, table, stop, owner }) {\n    return this.$publish('removeRange', { columns, start, table, stop, owner });\n  }\n  /**\n   * Removes one full row\n   *\n   * Removes all columns of the given row from the given table.\n   * */\n  removeRow({ table, key, owner }) {\n    return this.$publish('removeRow', { table, key, owner });\n  }\n}\n/**\n * Groups Management\n *\n * Groups management for users, grants on resources, remote commands on devices\n *  This is where you can configure rights for any resource\n *\n * */\n/**\n * User API for remote control\n *\n * @access public\n * */\nexport class Remoting extends Service {\n  /**\n   * Get default deployment id associated to Remoting service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'groups_0';\n  }\n  /**\n   * Adds a listener\n   *\n   * A user requests notifications from a device owned by anyone who granted him the right authorizations.\n   * Whenever the device calls 'notify', notifications will be sent to the caller of this verb.\n   * */\n  addListener({ resource, fromResource, cmd, from, data, owner }) {\n    return this.$publish('addListener', {\n      resource,\n      fromResource,\n      cmd,\n      from,\n      data,\n      owner,\n    });\n  }\n  /**Response to 'getCapabilities'*/\n  capabilities({ askingResource, capabilities, answeringResource }) {\n    return this.$publish('capabilities', {\n      askingResource,\n      capabilities,\n      answeringResource,\n    });\n  }\n  /**\n   * Executes a command\n   *\n   * A user executes a command on a device owned by anyone who granted him the right authorizations.\n   * The command is issued on channel 'command'\n   * */\n  execute({ resource, cmd, data, owner }) {\n    return this.$publish('execute', { resource, cmd, data, owner });\n  }\n  /**\n   * Requests capabilities\n   *\n   * A user requests all his devices for the whole list of their capabilities.\n   * Devices are expected to answer on channel 'capabilities'\n   * */\n  getCapabilities() {\n    return this.$publish('getCapabilities', {});\n  }\n  /**\n   * Notifies of some event\n   *\n   * A device notifies the registered users/devices on this channel.\n   * The server forwards the notification to said users.\n   * */\n  notify({ resource, fromResource, cmd, from, data, owner }) {\n    return this.$publish('notify', {\n      resource,\n      fromResource,\n      cmd,\n      from,\n      data,\n      owner,\n    });\n  }\n  /**\n   * Pings devices\n   *\n   * A user requests all devices (of all owners) on which he has authorizations to respond on channel 'pong'\n   * */\n  ping({ action }) {\n    return this.$publish('ping', { action });\n  }\n  /**Response to ping*/\n  pong({ user, resource, available, uid, owner, action }) {\n    return this.$publish('pong', {\n      user,\n      resource,\n      available,\n      uid,\n      owner,\n      action,\n    });\n  }\n  /**\n   * Removes a listener\n   *\n   * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations\n   * */\n  removeListener({ resource, fromResource, cmd, from, data, owner }) {\n    return this.$publish('removeListener', {\n      resource,\n      fromResource,\n      cmd,\n      from,\n      data,\n      owner,\n    });\n  }\n}\n/**\n * User API for groups and rights.\n *\n * Groups are stored per user.\n * This means that two users can own a group with the same identifier. A couple (owner, group) is needed to uniquely identify a group inside a group management service.\n * The triplet (deploymentId, owner, group) is actually needed to fully qualify a group outside of the scope of this service.\n * @access public\n * */\nexport class GroupManagement extends Service {\n  /**\n   * Get default deployment id associated to GroupManagement service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'groups_0';\n  }\n  /**\n   * Adds me to a group\n   *\n   * Adds me (the caller) to a group.\n   * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.\n   * The 'user' field is implicitly set to the current user's key.\n   * */\n  addMe({ group, owner }) {\n    return this.$publish('addMe', { group, owner });\n  }\n  /**\n   * Adds a user to a group\n   *\n   * Adds the given user to the given group.\n   * Addition may fail if the given group does not already exist.\n   * */\n  addUser({ user, group, owner }) {\n    return this.$publish('addUser', { user, group, owner });\n  }\n  /**Adds users to a group*/\n  addUsers({ users, group, owner }) {\n    return this.$publish('addUsers', { users, group, owner });\n  }\n  /**\n   * Lists my owned groups, with details\n   *\n   * Returns the whole list of groups owned by the current user, with their members\n   * */\n  allGroups({ owner }) {\n    return this.$publish('allGroups', { owner });\n  }\n  /**\n   * Creates a group\n   *\n   * Creates a group owned by the current user.\n   * Group creation may fail if the group already exists.\n   * */\n  createGroup({ group, groupName, owner }) {\n    return this.$publish('createGroup', { group, groupName, owner });\n  }\n  /**\n   * Removes a group\n   *\n   * Removes the given group owned by the current user or the given owner.\n   * Also removes all grants to that group.\n   * */\n  delGroup({ group, owner }) {\n    return this.$publish('delGroup', { group, owner });\n  }\n  /**Removes a user from a group*/\n  delUser({ user, group, owner }) {\n    return this.$publish('delUser', { user, group, owner });\n  }\n  /**Removes users from a group*/\n  delUsers({ users, group, groupName, owner }) {\n    return this.$publish('delUsers', { users, group, groupName, owner });\n  }\n  /**\n   * Tests for a group's existence\n   *\n   * Returns whether a group exists or not.\n   * */\n  exists({ group, owner }) {\n    return this.$publish('exists', { group, owner });\n  }\n  /**\n   * Grants a right to a group\n   *\n   * The granting API does not do any check when storing permissions.\n   * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.\n   * */\n  grant({ resource, group, owner, action }) {\n    return this.$publish('grant', { resource, group, owner, action });\n  }\n  /**\n   * Lists the group users\n   *\n   * Returns the whole list of users configured inside the given group.\n   * */\n  groupUsers({ group, owner }) {\n    return this.$publish('groupUsers', { group, owner });\n  }\n  /**\n   * Lists my owned groups\n   *\n   * Returns the whole list of groups owned by the current user\n   * */\n  groups({ owner }) {\n    return this.$publish('groups', { owner });\n  }\n  /**\n   * Lists rights for a group\n   *\n   * This API lists explicitly configured rights.\n   * Effective rights include configured rights, implicit rights and inherited rights.\n   * */\n  listGrants({ group, owner }) {\n    return this.$publish('listGrants', { group, owner });\n  }\n  /**\n   * Lists presences for a group\n   *\n   * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.\n   * The current implementation does not include information about the particular devices users are connected with.\n   * If a user is connected twice with two different devices, two identical entries will be returned.\n   * */\n  listPresences({ group, owner }) {\n    return this.$publish('listPresences', { group, owner });\n  }\n  /**\n   * Tests membership\n   *\n   * Tests whether I (the caller) am a member of the given group.\n   * This verb exists so that users can determine if they are part of a group without being granted particular rights.\n   * The 'user' field is implicitly set to the current user's key.\n   * */\n  memberOf({ hardFail, group, owner }) {\n    return this.$publish('memberOf', { hardFail, group, owner });\n  }\n  /**\n   * Grants rights to a group\n   *\n   * Grant several rights at once.\n   * */\n  mgrant({ resource, actions, group, owner }) {\n    return this.$publish('mgrant', { resource, actions, group, owner });\n  }\n  /**Revokes rights for a group*/\n  mrevoke({ resource, actions, group, owner }) {\n    return this.$publish('mrevoke', { resource, actions, group, owner });\n  }\n  /**\n   * Lists the groups I am part of\n   *\n   * Returns the whole list of groups the current user is part of.\n   * Groups may be owned by anyone, including the current user.\n   * */\n  myGroups({ owner }) {\n    return this.$publish('myGroups', { owner });\n  }\n  /**Revokes a right for a group*/\n  revoke({ resource, group, owner, action }) {\n    return this.$publish('revoke', { resource, group, owner, action });\n  }\n}\n/**\n * HTTP client\n *\n * Web-service client\n *  An admin records URL templates that can be called by users\n *  Calls are not configurable by end-users\n *  However an admin may leverage the macro service to achieve URL, headers and body configurability\n * */\n/**\n * User API for http requests\n *\n * @access public\n * */\nexport class Httpclient extends Service {\n  /**\n   * Get default deployment id associated to Httpclient service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'httpclient_0';\n  }\n  /**\n   * Makes a predefined request\n   *\n   * Lookups a predefined request by name, and executes it.\n   * */\n  call({ name, requestId }) {\n    return this.$publish('call', { name, requestId });\n  }\n}\n/**\n * Macros\n *\n * Macro-command service\n *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc\n *\n *\n *  End-users play them, with contextual parameters\n * */\n/**\n * User API for macro debugging\n *\n * Debugger API for macro.\n * These API verbs are not intended for use by most developers.\n * @access public\n * */\nexport class MacroDebug extends Service {\n  /**\n   * Get default deployment id associated to MacroDebug service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'macro_0';\n  }\n  /**Enables or disables a breakpoint*/\n  breakpoint({ breakpoint, token, enabled }) {\n    return this.$publish('breakpoint', { breakpoint, token, enabled });\n  }\n  /**Requests some information*/\n  info({ token, path, exp, requestId, frame }) {\n    return this.$publish('info', { token, path, exp, requestId, frame });\n  }\n  /**\n   * Debugs a previously recorded macro\n   *\n   * The given breakpoints will be honored, causing a suspension of the execution, resumable via 'resume'.\n   * Only one debug session can be active at any given time.\n   * */\n  livedebug({\n    parameters,\n    token,\n    breakpoints,\n    hardFail,\n    name,\n    requestId,\n    debug,\n  }) {\n    return this.$publish('livedebug', {\n      parameters,\n      token,\n      breakpoints,\n      hardFail,\n      name,\n      requestId,\n      debug,\n    });\n  }\n  /**Resumes a paused macro*/\n  resume({ token, type }) {\n    return this.$publish('resume', { token, type });\n  }\n  /**Sets a variable value*/\n  variable({ token, name, frame, data }) {\n    return this.$publish('variable', { token, name, frame, data });\n  }\n}\n/**\n * User API for macro execution\n *\n * Simple errors are reported as usual.\n * However, the macro execution verbs treat most errors in a particular way : instead of reporting errors on the usual 'error' channel, errors are put in the returned 'MacroCompletion' result.\n * This behavior can be tuned on a per-call basis with the hardFail parameter.\n * Note that some particular errors will always behave as if hardFail were true, because they are related to programming errors, or prevent processing from ending gracefully : STACK_OVERFLOW, NO_SUCH_FUNCTION, RAM_EXCEEDED, CYCLES_EXCEEDED, TIME_EXCEEDED, QUOTA_EXCEEDED, RATE_EXCEEDED, BAD_COMPARATOR_VALUE\n * @access public\n * */\nexport class Macro extends Service {\n  /**\n   * Get default deployment id associated to Macro service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'macro_0';\n  }\n  /**\n   * Plays a previously recorded macro\n   *\n   * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.\n   * You can override the default notification channel when defining the macro.\n   * */\n  call({ parameters, hardFail, name, requestId, debug }) {\n    return this.$publish('call', {\n      parameters,\n      hardFail,\n      name,\n      requestId,\n      debug,\n    });\n  }\n}\n/**\n * Mail sender\n *\n * Sends email through SMTP\n * */\n/**\n * Mail service user API\n *\n * This service is statically configured with an outgoing SMTP server.\n * Users call the API here to actually send emails.\n * @access public\n * */\nexport class Sendmail extends Service {\n  /**\n   * Get default deployment id associated to Sendmail service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'sendmail_0';\n  }\n}\n/**\n * Messaging service\n *\n * Messaging service\n * */\n/**\n * Messaging service\n *\n * Simple and flexible user-to-user or user-to-group messaging service.\n * @access public\n * */\nexport class Messaging extends Service {\n  /**\n   * Get default deployment id associated to Messaging service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'messaging_0';\n  }\n  /**\n   * Sends a message to a target\n   *\n   * Sends the given message to the specified target on the given (optional) channel.\n   * The administratively given default channel name is used when none is provided in the message itself.\n   * */\n  send({ target, channel, data }) {\n    return this.$publish('send', { target, channel, data });\n  }\n}\n/**\n * Producer consumer\n *\n * Producer consumer service\n *  Users can submit tasks and other users consume them\n * */\n/**\n * Producer / consumer real-time API\n *\n * Task producers submits their tasks.\n * The server dispatches the tasks.\n * Consumers process them and report completion back to the server.\n * Tasks are global to the service (i.e. NOT per user).\n * @access public\n * */\nexport class Queue extends Service {\n  /**\n   * Get default deployment id associated to Queue service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'queue_0';\n  }\n  /**\n   * Submits a task\n   *\n   * Producer API.\n   * A task producer submits the given task to the server.\n   * The server will find a tasker with processing capacity and dispatch the task.\n   * The task result will be returned to the caller.\n   * When called from inside a macro, the comsumer generated result is available for further use.\n   * */\n  call({ description, originBusinessId, originDeploymentId, data, owner }) {\n    return this.$publish('call', {\n      description,\n      originBusinessId,\n      originDeploymentId,\n      data,\n      owner,\n    });\n  }\n  /**\n   * Notifies completion of a task\n   *\n   * Consumer API.\n   * The tasker notifies completion of the given task to the server.\n   * The tasker can optionally include a result or an error code.\n   * */\n  done({ target, result, taskId, requestId, success }) {\n    return this.$publish('done', {\n      target,\n      result,\n      taskId,\n      requestId,\n      success,\n    });\n  }\n  /**\n   * Registers a consumer\n   *\n   * Consumer API.\n   * Registers the current user resource as an available task consumer.\n   * Tasks will be then dispatched to that consumer.\n   * */\n  register({ capacity }) {\n    return this.$publish('register', { capacity });\n  }\n  /**\n   * Submits a task\n   *\n   * Producer API.\n   * A task producer submits the given task to the server.\n   * The server will find a tasker with processing capacity and dispatch the task.\n   * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).\n   * This verb will return immediately : you can use this API to asynchronously submit a task.\n   * */\n  submit({ description, originBusinessId, originDeploymentId, data, owner }) {\n    return this.$publish('submit', {\n      description,\n      originBusinessId,\n      originDeploymentId,\n      data,\n      owner,\n    });\n  }\n  /**\n   * Unregisters a consumer\n   *\n   * Consumer API.\n   * Unregisters the current user resource as an available task consumer.\n   * All non finished tasks are returned to the server.\n   * */\n  unregister() {\n    return this.$publish('unregister', {});\n  }\n}\n/**\n * Push Notifications\n *\n * Native Push Notifications for Android, iOS\n *\n *\n *\n * */\n/**\n * Notification User API\n *\n * User API for notifications.\n * For notifications to work properly, it is imperative that the resource name of a device remain constant over time.\n * @access public\n * */\nexport class Notif extends Service {\n  /**\n   * Get default deployment id associated to Notif service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'notif_0';\n  }\n}\n/**\n * RDBMS\n *\n * Relational Database : SQL storage\n * */\n/**\n * RDBMS User API\n *\n * User API for SQL queries.\n * Contrary to GDA or Stacks, the data are not stored on a per-user basis.\n * Users can store, get, list their data.\n * @access public\n * */\nexport class Rdbms extends Service {\n  /**\n   * Get default deployment id associated to Rdbms service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'rdbms_0';\n  }\n}\n/**\n * SMS via OVH\n *\n * SMS sender, to send text messages to mobile phones\n * This SMS sending service uses the OVH API\n *\n * */\n/**\n * SMS service\n *\n * User API for SMS.\n * @access public\n * */\nexport class Sms_ovh extends Service {\n  /**\n   * Get default deployment id associated to Sms_ovh service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'sms_ovh_0';\n  }\n}\n/**\n * Scheduler\n *\n * Scheduler service\n *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)\n * */\n/**\n * User API for the Scheduler\n *\n * User endpoints for scheduling : users can schedule, list and delete tasks.\n * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.\n * Tasks are run on the server and thus can call api verbs marked as server-only.\n * @access public\n * */\nexport class Cron extends Service {\n  /**\n   * Get default deployment id associated to Cron service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'cron_0';\n  }\n  /**\n   * List the configured tasks\n   *\n   * Returns a paginated list of the asking user's tasks.\n   * */\n  list({ start, stop, owner, page }) {\n    return this.$publish('list', { start, stop, owner, page });\n  }\n}\n/**\n * Search engine\n *\n * ElasticSearch engine, to index and search data\n *  An admin creates indices\n *  Users index and search documents\n *\n * */\n/**\n * ElasticSearch Service\n *\n * This API is a very thin wrapper around ElasticSearch's API.\n * @access public\n * */\nexport class Search extends Service {\n  /**\n   * Get default deployment id associated to Search service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'search_0';\n  }\n  /**\n   * Deletes data\n   *\n   * Deletes a document from the elasticsearch engine by id.\n   * */\n  delete({ type, id, index }) {\n    return this.$publish('delete', { type, id, index });\n  }\n  /**\n   * Gets data\n   *\n   * Retrieves a document from the elasticsearch engine by id.\n   * */\n  get({ type, id, index }) {\n    return this.$publish('get', { type, id, index });\n  }\n  /**\n   * Indexes data\n   *\n   * Inserts or updates a document into the elasticsearch engine.\n   * */\n  index({ type, id, index, data }) {\n    return this.$publish('index', { type, id, index, data });\n  }\n  /**Searches for data*/\n  search({ indices, query, sort, page, types }) {\n    return this.$publish('search', { indices, query, sort, page, types });\n  }\n}\n/**\n * Template engine\n *\n * Template engine to produce documents from parameterized templates\n * <br>An admin creates templates\n * <br> Users produce documents\n * <br>The implementation uses the <a href='http://freemarker\n * org/'>freemarker</a> engine\n *\n * */\n/**\n * User API for templates\n *\n * Users use this API to evaluate pre-configured templates.\n * @access public\n * */\nexport class Template extends Service {\n  /**\n   * Get default deployment id associated to Template service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'template_0';\n  }\n  /**\n   * Evaluates a template\n   *\n   * Evaluates the given template and returns the result as a string.\n   * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.\n   * */\n  evaluate({ languageTag, name, requestId, data }) {\n    return this.$publish('evaluate', { languageTag, name, requestId, data });\n  }\n}\n/**\n * Triggers\n *\n * Register callbacks for events and trigger them when needed\n *\n * */\n/**\n * Trigger service\n *\n * Register listeners and trigger events.\n * @access public\n * */\nexport class Trigger extends Service {\n  /**\n   * Get default deployment id associated to Trigger service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'trigger_0';\n  }\n}\n/**\n * Upload: S3\n *\n * Upload service with S3 storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3 extends Service {\n  /**\n   * Get default deployment id associated to Zpfs_s3 service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'zpfs_s3_0';\n  }\n  /**\n   * Copies a file\n   *\n   * Copies a file or folder (recursively) to a new location.\n   * May fail if the target location is not empty.\n   * */\n  cp({ oldPath, path, owner }) {\n    return this.$publish('cp', { oldPath, path, owner });\n  }\n  /**\n   * Returns disk usage\n   *\n   * Returns an recursively aggregated number of used bytes, starting at the given path.\n   * */\n  du({ path, owner }) {\n    return this.$publish('du', { path, owner });\n  }\n  /**\n   * Links a file\n   *\n   * Links a file or folder to another location.\n   * May fail if the target location is not empty.\n   * */\n  link({ oldPath, path, owner }) {\n    return this.$publish('link', { oldPath, path, owner });\n  }\n  /**\n   * Lists a folder content\n   *\n   * Returns a paginated list of the folder's content.\n   * */\n  ls({ folder, owner, page }) {\n    return this.$publish('ls', { folder, owner, page });\n  }\n  /**\n   * Creates a folder\n   *\n   * Creates a new folder.\n   * May fail if the target location is not empty.\n   * */\n  mkdir({ parents, folder, owner }) {\n    return this.$publish('mkdir', { parents, folder, owner });\n  }\n  /**\n   * Moves a file\n   *\n   * Moves a file or folder (recursively) to a new location.\n   * May fail if the target location is not empty.\n   * */\n  mv({ oldPath, path, owner }) {\n    return this.$publish('mv', { oldPath, path, owner });\n  }\n  /**\n   * Notifies of upload completion\n   *\n   * The client application calls this verb to notify that it's done uploading to the cloud.\n   * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n   * */\n  newFile({ tags, guid, metadata, owner }) {\n    return this.$publish('newFile', { tags, guid, metadata, owner });\n  }\n  /**\n   * Requests an upload URL\n   *\n   * Requests an HTTP upload URL.\n   * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n   * */\n  newUploadUrl({ contentType, path, owner }) {\n    return this.$publish('newUploadUrl', { contentType, path, owner });\n  }\n  /**\n   * Removes a file\n   *\n   * Removes a file or folder (recursively).\n   * */\n  rm({ path, owner }) {\n    return this.$publish('rm', { path, owner });\n  }\n  /**\n   * Creates a snapshot in a new folder\n   *\n   * Creates a new folder and then copies the given files inside\n   * */\n  snapshot({ parents, folder, items, flatten, owner }) {\n    return this.$publish('snapshot', {\n      parents,\n      folder,\n      items,\n      flatten,\n      owner,\n    });\n  }\n  /**\n   * Returns information about a file\n   *\n   * Returns information about a single file.\n   * The entry field will be null if the path does not exist\n   * */\n  stat({ path, owner }) {\n    return this.$publish('stat', { path, owner });\n  }\n  /**Updates a file's metadata*/\n  updateMeta({ path, metadataFiles, metadata, owner }) {\n    return this.$publish('updateMeta', {\n      path,\n      metadataFiles,\n      metadata,\n      owner,\n    });\n  }\n}\n/**\n * Upload: local\n *\n * Upload service with local HDFS storage\n * */\n/**\n * User API for local file management\n *\n * User API for file content manipulation\n * @access public\n * */\nexport class Zpfs_hdfs extends Service {\n  /**\n   * Get default deployment id associated to Zpfs_hdfs service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'zpfs_hdfs_0';\n  }\n  /**\n   * Copies a file\n   *\n   * Copies a file or folder (recursively) to a new location.\n   * May fail if the target location is not empty.\n   * */\n  cp({ oldPath, path, owner }) {\n    return this.$publish('cp', { oldPath, path, owner });\n  }\n  /**\n   * Returns disk usage\n   *\n   * Returns an recursively aggregated number of used bytes, starting at the given path.\n   * */\n  du({ path, owner }) {\n    return this.$publish('du', { path, owner });\n  }\n  /**\n   * Links a file\n   *\n   * Links a file or folder to another location.\n   * May fail if the target location is not empty.\n   * */\n  link({ oldPath, path, owner }) {\n    return this.$publish('link', { oldPath, path, owner });\n  }\n  /**\n   * Lists a folder content\n   *\n   * Returns a paginated list of the folder's content.\n   * */\n  ls({ folder, owner, page }) {\n    return this.$publish('ls', { folder, owner, page });\n  }\n  /**\n   * Creates a folder\n   *\n   * Creates a new folder.\n   * May fail if the target location is not empty.\n   * */\n  mkdir({ parents, folder, owner }) {\n    return this.$publish('mkdir', { parents, folder, owner });\n  }\n  /**\n   * Moves a file\n   *\n   * Moves a file or folder (recursively) to a new location.\n   * May fail if the target location is not empty.\n   * */\n  mv({ oldPath, path, owner }) {\n    return this.$publish('mv', { oldPath, path, owner });\n  }\n  /**\n   * Notifies of upload completion\n   *\n   * The client application calls this verb to notify that it's done uploading to the cloud.\n   * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n   * */\n  newFile({ tags, guid, metadata, owner }) {\n    return this.$publish('newFile', { tags, guid, metadata, owner });\n  }\n  /**\n   * Requests an upload URL\n   *\n   * Requests an HTTP upload URL.\n   * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n   * */\n  newUploadUrl({ contentType, path, owner }) {\n    return this.$publish('newUploadUrl', { contentType, path, owner });\n  }\n  /**\n   * Removes a file\n   *\n   * Removes a file or folder (recursively).\n   * */\n  rm({ path, owner }) {\n    return this.$publish('rm', { path, owner });\n  }\n  /**\n   * Creates a snapshot in a new folder\n   *\n   * Creates a new folder and then copies the given files inside\n   * */\n  snapshot({ parents, folder, items, flatten, owner }) {\n    return this.$publish('snapshot', {\n      parents,\n      folder,\n      items,\n      flatten,\n      owner,\n    });\n  }\n  /**\n   * Returns information about a file\n   *\n   * Returns information about a single file.\n   * The entry field will be null if the path does not exist\n   * */\n  stat({ path, owner }) {\n    return this.$publish('stat', { path, owner });\n  }\n  /**Updates a file's metadata*/\n  updateMeta({ path, metadataFiles, metadata, owner }) {\n    return this.$publish('updateMeta', {\n      path,\n      metadataFiles,\n      metadata,\n      owner,\n    });\n  }\n}\n/**\n * Upload: pseudo-S3\n *\n * Upload service with pseudo-S3compatible storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3compat extends Service {\n  /**\n   * Get default deployment id associated to Zpfs_s3compat service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'zpfs_s3compat_0';\n  }\n  /**\n   * Copies a file\n   *\n   * Copies a file or folder (recursively) to a new location.\n   * May fail if the target location is not empty.\n   * */\n  cp({ oldPath, path, owner }) {\n    return this.$publish('cp', { oldPath, path, owner });\n  }\n  /**\n   * Returns disk usage\n   *\n   * Returns an recursively aggregated number of used bytes, starting at the given path.\n   * */\n  du({ path, owner }) {\n    return this.$publish('du', { path, owner });\n  }\n  /**\n   * Links a file\n   *\n   * Links a file or folder to another location.\n   * May fail if the target location is not empty.\n   * */\n  link({ oldPath, path, owner }) {\n    return this.$publish('link', { oldPath, path, owner });\n  }\n  /**\n   * Lists a folder content\n   *\n   * Returns a paginated list of the folder's content.\n   * */\n  ls({ folder, owner, page }) {\n    return this.$publish('ls', { folder, owner, page });\n  }\n  /**\n   * Creates a folder\n   *\n   * Creates a new folder.\n   * May fail if the target location is not empty.\n   * */\n  mkdir({ parents, folder, owner }) {\n    return this.$publish('mkdir', { parents, folder, owner });\n  }\n  /**\n   * Moves a file\n   *\n   * Moves a file or folder (recursively) to a new location.\n   * May fail if the target location is not empty.\n   * */\n  mv({ oldPath, path, owner }) {\n    return this.$publish('mv', { oldPath, path, owner });\n  }\n  /**\n   * Notifies of upload completion\n   *\n   * The client application calls this verb to notify that it's done uploading to the cloud.\n   * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n   * */\n  newFile({ tags, guid, metadata, owner }) {\n    return this.$publish('newFile', { tags, guid, metadata, owner });\n  }\n  /**\n   * Requests an upload URL\n   *\n   * Requests an HTTP upload URL.\n   * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n   * */\n  newUploadUrl({ contentType, path, owner }) {\n    return this.$publish('newUploadUrl', { contentType, path, owner });\n  }\n  /**\n   * Removes a file\n   *\n   * Removes a file or folder (recursively).\n   * */\n  rm({ path, owner }) {\n    return this.$publish('rm', { path, owner });\n  }\n  /**\n   * Creates a snapshot in a new folder\n   *\n   * Creates a new folder and then copies the given files inside\n   * */\n  snapshot({ parents, folder, items, flatten, owner }) {\n    return this.$publish('snapshot', {\n      parents,\n      folder,\n      items,\n      flatten,\n      owner,\n    });\n  }\n  /**\n   * Returns information about a file\n   *\n   * Returns information about a single file.\n   * The entry field will be null if the path does not exist\n   * */\n  stat({ path, owner }) {\n    return this.$publish('stat', { path, owner });\n  }\n  /**Updates a file's metadata*/\n  updateMeta({ path, metadataFiles, metadata, owner }) {\n    return this.$publish('updateMeta', {\n      path,\n      metadataFiles,\n      metadata,\n      owner,\n    });\n  }\n}\n/**\n * User directory service\n *\n * User directory service\n * */\n/**\n * User API for user information\n *\n * @access public\n * */\nexport class Userdir extends Service {\n  /**\n   * Get default deployment id associated to Userdir service\n   * @return {string}\n   */\n  static get DEFAULT_DEPLOYMENT_ID() {\n    return 'userdir_0';\n  }\n  /**Searches for users matching the request*/\n  search({ requestId, query, page }) {\n    return this.$publish('search', { requestId, query, page });\n  }\n  /**Requests public data for the specified users*/\n  userInfo({ userKeys }) {\n    return this.$publish('userInfo', { userKeys });\n  }\n}\n","/**\n * Match unsecure pattern web\n * @type {RegExp}\n */\nconst HTTP_PATTERN = /^http:\\/\\/|^\\/\\//;\n\n/**\n * Http protocol\n * @type {string}\n */\nconst HTTP_PROTOCOL = 'http:';\n\n/**\n * Https protocol\n * @type {string}\n */\nconst HTTPS_PROTOCOL = 'https:';\n\n/**\n * Alpha numeric dictionary\n */\nconst DICTIONARY = 'abcdefghijklmnopqrstuvwxyz0123456789';\n\n/**\n * Default ZetaPush API URL\n * @access private\n */\nexport const API_URL = 'https://api.zpush.io/';\n\n/**\n * Force ssl based protocol for network echange\n * Cross Env (Browser/Node) test\n * @access private\n * @type boolean\n */\nexport const FORCE_HTTPS =\n  typeof location === 'undefined'\n    ? false\n    : location.protocol === HTTPS_PROTOCOL;\n\n/**\n * @access private\n * @param {string} apiUrl\n * @return {string}\n */\nconst normalizeApiUrl = (apiUrl) => {\n  const last = apiUrl.charAt(apiUrl.length - 1);\n  const SLASH = '/';\n  return last === SLASH ? apiUrl : apiUrl + SLASH;\n};\n\n/**\n * @access private\n * @param {Array<Object>} list\n * @return {Object}\n */\nexport const shuffle = (list) => {\n  const index = Math.floor(Math.random() * list.length);\n  return list[index];\n};\n\n/**\n * @access private\n * @param {string} url\n * @param {boolean} forceHttps\n * @return {string}\n */\nexport const getSecureUrl = (url, forceHttps) => {\n  return forceHttps ? url.replace(HTTP_PATTERN, `${HTTPS_PROTOCOL}//`) : url;\n};\n\n/**\n * @access private\n * @param {{apiUrl: string, sandboxId: string, forceHttps: boolean, transports: Transports}} parameters\n * @return {Promise}\n */\nexport const getServers = ({ apiUrl, sandboxId, forceHttps, transports }) => {\n  const normalizedSecuresApiUrl = normalizeApiUrl(\n    getSecureUrl(apiUrl, forceHttps),\n  );\n  const url = `${normalizedSecuresApiUrl}${sandboxId}`;\n  const options = { protocol: forceHttps ? HTTPS_PROTOCOL : HTTP_PROTOCOL };\n  return (\n    transports\n      .fetch(url, options)\n      .then((response) => response.json())\n      // TODO: Replace by a server side implementation when available\n      .then(({ servers }) =>\n        servers.map((server) => getSecureUrl(server, forceHttps)),\n      )\n  );\n};\n\n/**\n * @access private\n * @param Class Derived\n * @param Class Parent\n * @return {boolean}\n */\nexport const isDerivedOf = (Derived, Parent) => {\n  let prototype = Object.getPrototypeOf(Derived);\n  let is = false;\n  while (!(is || prototype === null)) {\n    is = prototype === Parent;\n    prototype = Object.getPrototypeOf(prototype);\n  }\n  return is;\n};\n\n/**\n * Get random id\n * @return {string}\n */\nexport const uuid = (entropy = 7, dictionary = DICTIONARY) =>\n  Array.from(Array(entropy)).reduce((previous) => {\n    const next = dictionary.charAt(\n      Math.floor(Math.random() * dictionary.length),\n    );\n    return `${previous}${next}`;\n  }, '');\n","import { CometD, Transports } from 'zetapush-cometd';\nimport { ConnectionStatusListener } from '../connection/connection-status';\nimport { Macro } from '../mapping/services';\nimport { getServers, isDerivedOf, shuffle, uuid } from '../utils/index';\n\n/**\n * CometD Messages enumeration\n * @type {Object}\n */\nconst Message = {\n  RECONNECT_HANDSHAKE_VALUE: 'handshake',\n  RECONNECT_NONE_VALUE: 'none',\n  RECONNECT_RETRY_VALUE: 'retry',\n};\n\n/**\n * Delay to update server url\n * @type {integer}\n */\nconst UPDATE_SERVER_URL_DELAY = 250;\n\n/**\n * Default macro channel\n * @type {string}\n */\nconst DEFAULT_MACRO_CHANNEL = 'completed';\n\n/**\n * Provide utilities and abstraction on CometD Transport layer\n * @access private\n */\nexport class ClientHelper {\n  /**\n   * Create a new ZetaPush client helper\n   */\n  constructor({\n    apiUrl,\n    sandboxId,\n    forceHttps = false,\n    authentication,\n    resource = null,\n    transports = Transports,\n  }) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sandboxId = sandboxId;\n    /**\n     * @access private\n     * @type {function():AbstractHandshake}\n     */\n    this.authentication = authentication;\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.resource = resource;\n    /**\n     * @access private\n     * @type {number}\n     */\n    this.requestId = 0;\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.userId = null;\n    /**\n     * @access private\n     * @type {Object}\n     */\n    this.userInfo = null;\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.uniqId = uuid();\n    /**\n     * @access private\n     * @type {Promise}\n     */\n    this.servers = getServers({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      transports,\n    }).catch((error) => {\n      // Notify error in connection to server step\n      this.connectionToServerFail(error);\n      // Return empty list\n      return [];\n    });\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.connectionListeners = [];\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.connected = false;\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.wasConnected = false;\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.serverUrl = null;\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sessionId = null;\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.subscribeQueue = [];\n    /**\n     * @access private\n     * @type {CometD}\n     */\n    this.cometd = new CometD();\n\n    // Register transports layers\n    transports.ALL.forEach(({ type, Transport }) => {\n      this.cometd.registerTransport(type, new Transport());\n    });\n\n    // Handle transport exception\n    this.cometd.onTransportException = (cometd, transport) => {\n      // Try to find an other available server\n      // Remove the current one from the _serverList array\n      this.updateServerUrl();\n    };\n\n    this.cometd.addListener(\n      '/meta/handshake',\n      ({ ext, successful, advice, error }) => {\n        this.cometd._debug('ClientHelper::/meta/handshake', {\n          ext,\n          successful,\n          advice,\n          error,\n        });\n        if (successful) {\n          const { authentication = null } = ext;\n          this.initialized(authentication);\n        } else {\n          this.handshakeFailure(error);\n        }\n      },\n    );\n\n    this.cometd.addListener(\n      '/meta/handshake',\n      ({ advice, error, ext, successful }) => {\n        this.cometd._debug('ClientHelper::/meta/handshake', {\n          ext,\n          successful,\n          advice,\n          error,\n        });\n        // AuthNegotiation\n        if (!successful) {\n          if (typeof advice === 'undefined') {\n            return;\n          }\n          if (Message.RECONNECT_NONE_VALUE === advice.reconnect) {\n            this.authenticationFailed(error);\n          } else if (Message.RECONNECT_HANDSHAKE_VALUE === advice.reconnect) {\n            this.negotiationFailed(error);\n          }\n        }\n      },\n    );\n\n    this.cometd.addListener(\n      '/meta/connect',\n      ({ advice, channel, successful }) => {\n        this.cometd._debug('ClientHelper::/meta/connect', {\n          advice,\n          channel,\n          successful,\n        });\n        // ConnectionListener\n        if (this.cometd.isDisconnected()) {\n          this.connected = false;\n          // Notify connection will close\n          this.connectionWillClose();\n        } else {\n          this.wasConnected = this.connected;\n          this.connected = successful;\n          if (!this.wasConnected && this.connected) {\n            this.cometd.batch(this, () => {\n              // Unqueue subscriptions\n              this.subscribeQueue.forEach(\n                ({ prefix, listener, subscriptions }) => {\n                  this.subscribe(prefix, listener, subscriptions);\n                },\n              );\n            });\n            // Notify connection is established\n            this.connectionEstablished();\n          } else if (this.wasConnected && !this.connected) {\n            // Notify connection is broken\n            this.connectionBroken();\n          }\n        }\n      },\n    );\n\n    this.cometd.addListener('/meta/disconnect', ({ channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/disconnect', {\n        channel,\n        successful,\n      });\n      if (this.cometd.isDisconnected()) {\n        this.connected = false;\n        // Notify connection is closed\n        this.connectionClosed();\n      }\n    });\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    this.connectionListeners.push({\n      enabled: true,\n      listener: Object.assign(new ConnectionStatusListener(), listener),\n    });\n    return this.connectionListeners.length - 1;\n  }\n  /**\n   * Notify listeners when handshake step succeed\n   */\n  authenticationFailed(error) {\n    this.userId = null;\n    this.userInfo = null;\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onFailedHandshake(error);\n      });\n  }\n  /**\n   * Connect client using CometD Transport\n   */\n  connect() {\n    this.servers.then((servers) => {\n      if (servers.length > 0) {\n        // Get a random server url\n        this.serverUrl = shuffle(servers);\n        // Configure CometD\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`,\n          backoffIncrement: 1000,\n          maxBackoff: 60000,\n          appendMessageTypeToURL: false,\n        });\n        // Send handshake fields\n        this.cometd.handshake(this.getHandshakeFields());\n      } else {\n        // No servers available\n        this.noServerUrlAvailable();\n      }\n    });\n  }\n  /**\n   * Notify listeners when connection is broken\n   */\n  connectionBroken() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionBroken();\n      });\n  }\n  /**\n   * Notify listeners when connection is closed\n   */\n  connectionClosed() {\n    this.userId = null;\n    this.userInfo = null;\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionClosed();\n      });\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  connectionEstablished() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionEstablished();\n      });\n  }\n  /**\n   * Notify listeners when connection to server fail\n   */\n  connectionToServerFail(failure) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionToServerFail(failure);\n      });\n  }\n  /**\n   * Notify listeners when connection will close\n   */\n  connectionWillClose() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionWillClose();\n      });\n  }\n  /**\n   * Create a promise based macro service\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createAsyncMacroService({\n    listener,\n    Type,\n    deploymentId = Type.DEFAULT_DEPLOYMENT_ID,\n  }) {\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`;\n    const $publish = this.getAsyncMacroPublisher(prefix);\n    // Create service by publisher\n    return this.createServiceByPublisher({\n      listener,\n      prefix,\n      Type,\n      $publish,\n    });\n  }\n\n  /**\n   * Create a promise based task service\n   * @experimental\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createAsyncTaskService({ Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`;\n    const $publish = this.getAsyncTaskPublisher(prefix);\n    // Create service by publisher\n    return this.createServiceByPublisher({\n      listener: {},\n      prefix,\n      Type,\n      $publish,\n    });\n  }\n  /**\n   * Create a publish/subscribe service\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   */\n  createService({ listener, Type, deploymentId = Type.DEFAULT_DEPLOYMENT_ID }) {\n    const isMacroType = isDerivedOf(Type, Macro);\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`;\n    const $publish = isMacroType\n      ? this.getMacroPublisher(prefix)\n      : this.getServicePublisher(prefix);\n    // Create service by publisher\n    return this.createServiceByPublisher({\n      listener,\n      prefix,\n      Type,\n      $publish,\n    });\n  }\n  /**\n   * @param {{listener: Object, prefix: string, Type: class, $publish: Function}} parameters\n   * @return {Object} service\n   */\n  createServiceByPublisher({ listener, prefix, Type, $publish }) {\n    const service = new Type({\n      $publish,\n    });\n    // Store subscription in service instance\n    service.$subscriptions = this.subscribe(prefix, listener);\n    return service;\n  }\n  /**\n   * Disconnect CometD client\n   */\n  disconnect() {\n    this.cometd.disconnect(true);\n  }\n  /**\n   * Get a publisher for a macro service that return a promise\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getAsyncMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`;\n      const uniqRequestId = this.getUniqRequestId();\n      const subscriptions = {};\n      return new Promise((resolve, reject) => {\n        const handler = ({ data = {} }) => {\n          const { result = {}, errors = [], requestId } = data;\n          if (requestId === uniqRequestId) {\n            // Handle errors\n            if (errors.length > 0) {\n              reject(errors);\n            } else {\n              resolve(result);\n            }\n            this.unsubscribe(subscriptions);\n          }\n        };\n        // Create dynamic listener method\n        const listener = {\n          [name]: handler,\n          [DEFAULT_MACRO_CHANNEL]: handler,\n        };\n        // Ad-Hoc subscription\n        this.subscribe(prefix, listener, subscriptions);\n        // Publish message on channel\n        this.publish(channel, {\n          debug,\n          hardFail,\n          name,\n          parameters,\n          requestId: uniqRequestId,\n        });\n      });\n    };\n  }\n\n  /**\n   * Get a publisher for a task service that return a promise\n   * @experimental\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getAsyncTaskPublisher(prefix) {\n    const DEFAULT_TASK_CHANNEL = 'call';\n    return (name, namespace = '', parameters = null) => {\n      const channel = `${prefix}/${DEFAULT_TASK_CHANNEL}`;\n      const uniqRequestId = this.getUniqRequestId();\n      const subscriptions = {};\n      return new Promise((resolve, reject) => {\n        const handler = ({ data = {} }) => {\n          const { result = {}, success, requestId } = data;\n          if (requestId === uniqRequestId) {\n            // Handle errors\n            if (success) {\n              resolve(result);\n            } else {\n              reject(result);\n            }\n            this.unsubscribe(subscriptions);\n          }\n        };\n        // Create dynamic listener method\n        const listener = {\n          [DEFAULT_TASK_CHANNEL]: handler,\n        };\n        // Ad-Hoc subscription\n        this.subscribe(prefix, listener, subscriptions);\n        // Publish message on channel\n        this.publish(channel, {\n          data: {\n            name,\n            namespace,\n            parameters,\n          },\n          requestId: uniqRequestId,\n        });\n      });\n    };\n  }\n  /**\n   * Get client id\n   * @return {string} clientId\n   */\n  getClientId() {\n    return this.cometd.getClientId();\n  }\n  /**\n   * Get CometD handshake parameters\n   * @return {Object}\n   */\n  getHandshakeFields() {\n    const handshake = this.authentication();\n    return handshake.getHandshakeFields(this);\n  }\n  /**\n   * Get a publisher for a macro service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getMacroPublisher(prefix) {\n    return (name, parameters, hardFail = false, debug = 1) => {\n      const channel = `${prefix}/call`;\n      const requestId = this.getUniqRequestId();\n      return this.publish(channel, {\n        debug,\n        hardFail,\n        name,\n        parameters,\n        requestId,\n      });\n    };\n  }\n  /**\n   * Get queued subscription index\n   * @return {Object} index\n   */\n  getQueuedSubscription(subscriptions = {}) {\n    const index = this.subscribeQueue.findIndex(\n      (element) => subscriptions === element.subscriptions,\n    );\n    return {\n      index,\n      queued: index > -1,\n    };\n  }\n  /**\n   * Get resource\n   * @return {string}\n   */\n  getResource() {\n    return this.resource;\n  }\n  /**\n   * Get sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.sandboxId;\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.servers;\n  }\n  /**\n   * Get a publisher for a service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getServicePublisher(prefix) {\n    return (method, parameters) => {\n      const channel = `${prefix}/${method}`;\n      return this.publish(channel, parameters);\n    };\n  }\n  /**\n   * Get uniq request id\n   * @return {string}\n   */\n  getUniqRequestId() {\n    return `${this.getClientId()}:${this.uniqId}:${++this.requestId}`;\n  }\n  /**\n   * Get user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.userId;\n  }\n  /**\n   * Get user info\n   * @return {Objet}\n   */\n  getUserInfo() {\n    return this.userInfo;\n  }\n  /**\n   * Manage handshake failure case\n   */\n  handshakeFailure() {\n    this.userId = null;\n    this.userInfo = null;\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  initialized(authentication) {\n    if (authentication) {\n      this.userId = authentication.userId;\n      this.userInfo = authentication.userInfo;\n    }\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onSuccessfulHandshake(authentication);\n      });\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return !this.cometd.isDisconnected();\n  }\n  /**\n   * Notify listeners when a message is lost\n   */\n  messageLost(channel, data) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onMessageLost(channel, data);\n      });\n  }\n  /**\n   * Negociate authentication\n   * @param {error} error\n   */\n  negotiationFailed(error) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onNegotiationFailed(error);\n      });\n  }\n  /**\n   * Notify listeners when no server url available\n   */\n  noServerUrlAvailable() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onNoServerUrlAvailable();\n      });\n  }\n  /**\n   * Wrap CometdD publish method\n   * @param {String} channel\n   * @param {Object} parameters\n   * @return {Object}\n   */\n  publish(channel, parameters = {}) {\n    this.cometd.publish(channel, parameters);\n    return {\n      channel,\n      parameters,\n    };\n  }\n  /**\n   * Remove a connection status listener\n   */\n  removeConnectionStatusListener(handler) {\n    const listener = this.connectionListeners[handler];\n    if (listener) {\n      listener.enabled = false;\n    }\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.authentication = authentication;\n  }\n  /**\n   * Set logging level for CometD client\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.cometd.setLogLevel(level);\n  }\n  /**\n   * Subsribe all methods defined in the listener for the given prefixed channel\n   * @param {string} prefix - Channel prefix\n   * @param {Object} listener\n   * @param {Object} subscriptions\n   * @return {Object} subscriptions\n   */\n  subscribe(prefix, listener = {}, subscriptions = {}) {\n    const { queued } = this.getQueuedSubscription(subscriptions);\n    if (!queued) {\n      // Store arguments to renew subscriptions on connection\n      this.subscribeQueue.push({\n        prefix,\n        listener,\n        subscriptions,\n      });\n    }\n    // Subscribe if user is connected\n    if (!this.cometd.isDisconnected()) {\n      for (let method in listener) {\n        if (listener.hasOwnProperty(method)) {\n          if (subscriptions[method] === void 0) {\n            const channel = `${prefix}/${method}`;\n            subscriptions[method] = this.cometd.subscribe(\n              channel,\n              listener[method],\n            );\n          }\n        }\n      }\n    }\n    return subscriptions;\n  }\n  /**\n   * Remove current server url from the server list and shuffle for another one\n   */\n  updateServerUrl() {\n    this.servers.then((servers) => {\n      const index = servers.indexOf(this.serverUrl);\n      if (index > -1) {\n        servers.splice(index, 1);\n      }\n      if (servers.length === 0) {\n        // No more server available\n        this.noServerUrlAvailable();\n      } else {\n        this.serverUrl = shuffle(servers);\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`,\n        });\n        setTimeout(() => {\n          this.cometd.handshake(this.getHandshakeFields());\n        }, UPDATE_SERVER_URL_DELAY);\n      }\n    });\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} subscriptions\n   */\n  unsubscribe(subscriptions = {}) {\n    // Unsubscribe\n    for (let method in subscriptions) {\n      if (subscriptions.hasOwnProperty(method)) {\n        const subscription = subscriptions[method];\n        this.cometd.unsubscribe(subscription);\n      }\n    }\n    // Remove subscription from queue\n    const { index, queued } = this.getQueuedSubscription(subscriptions);\n    if (queued) {\n      this.subscribeQueue.splice(index, 1);\n    }\n  }\n}\n","import { ClientHelper } from './helper';\nimport { API_URL, FORCE_HTTPS } from '../utils/index';\nimport { ConnectionStatusListener } from '../connection/connection-status';\n\n/**\n * Client config object.\n * @typedef {Object} ClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {function():AbstractHandshake} authentication - Return authentication properties\n * @property {string} resource - Client resource id\n * @property {Transports} transports - Client transports implementation\n */\n\n/**\n * ZetaPush Client to connect\n * @access public\n * @example\n * // Securized client with token based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       token: null\n *    })\n *   }\n * })\n * @example\n * // Client with authentication based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * @example\n * // Explicit deploymentId\n * const clientSimple = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.simple({\n *       deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n *    })\n *   }\n * })\n * const clientWeak = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   authentication() {\n *     return ZetaPush.Authentication.weak({\n *       deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',\n *       token: '<SESSION-TOKEN>'\n *    })\n *   }\n * })\n */\nexport class Client {\n  /**\n   * Create a new ZetaPush Client\n   * @param {ClientConfig} config\n   */\n  constructor({\n    apiUrl = API_URL,\n    sandboxId,\n    forceHttps = FORCE_HTTPS,\n    authentication,\n    resource,\n    transports,\n  }) {\n    /**\n     * @access private\n     * @type {ClientHelper}\n     */\n    this.helper = new ClientHelper({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      authentication,\n      resource,\n      transports,\n    });\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    return this.helper.addConnectionStatusListener(listener);\n  }\n  /**\n   * Safely connect client to ZetaPush\n   */\n  connect() {\n    if (this.isConnected()) {\n      const handler = this.addConnectionStatusListener({\n        onConnectionClosed: () => {\n          this.removeConnectionStatusListener(handler);\n          this.helper.connect();\n        },\n      });\n      this.disconnect();\n    } else {\n      this.helper.connect();\n    }\n  }\n  /**\n   * Create a promise based macro service instance\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const api = client.createAsyncMacroService({\n   *   Type: WelcomeMacro\n   * })\n   * api.welcome({\n   *   message: Hello'\n   * }).then(({ message }) => {\n   *   console.log(message)\n   * })\n   */\n  createAsyncMacroService({ deploymentId, listener, Type }) {\n    return this.helper.createAsyncMacroService({\n      deploymentId,\n      listener,\n      Type,\n    });\n  }\n  /**\n   * Create a promise based task service instance\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const api = client.createAsyncMacroService({\n   *   Type: WelcomeMacro\n   * })\n   * api.welcome({\n   *   message: Hello'\n   * }).then(({ message }) => {\n   *   console.log(message)\n   * })\n   */\n  createAsyncTaskService({ deploymentId, Type }) {\n    return this.helper.createAsyncTaskService({\n      deploymentId,\n      Type,\n    });\n  }\n  /**\n   * Create a publish/subscribe for a service type\n   * @param {{listener: Object, Type: class, deploymentId: string}} parameters\n   * @return {Object} service\n   * @example\n   * const service = client.createService({\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   * @example\n   * // Explicit deploymentId\n   * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n   * const service = client.createService({\n   *   deploymentId: 'stack_0'\n   *   listener: {\n   *     list(message) {\n   *       console.log('Stack list callback', message)\n   *     },\n   *     push(message) {\n   *       console.log('Stack push callback', message)\n   *     }\n   *   },\n   *   Type: ZetaPush.services.Stack\n   * })\n   * service.list({\n   *   stack: '<STACK-ID>'\n   * })\n   */\n  createService({ deploymentId, listener, Type }) {\n    return this.helper.createService({\n      deploymentId,\n      listener,\n      Type,\n    });\n  }\n  /**\n   * Disonnect client from ZetaPush\n   */\n  disconnect() {\n    if (this.isConnected()) {\n      this.helper.disconnect();\n    }\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return this.helper.isConnected();\n  }\n  /**\n   * Get the client sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.helper.getSandboxId();\n  }\n  /**\n   * Get the client resource\n   * @return {string}\n   */\n  getResource() {\n    return this.helper.getResource();\n  }\n  /**\n   * Get server urls list\n   * @return {Promise} servers\n   */\n  getServers() {\n    return this.helper.getServers();\n  }\n  /**\n   * Get the client user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.helper.getUserId();\n  }\n  /*\n   * Get the client user info\n   * @return {Object}\n   * @example\n   * // Create new ZetaPush Client\n   * const client = new Client({\n   *   sandboxId: '<YOUR-SANDBOX-ID>',\n   *   authentication: () => Authentication.simple({\n   *     login: '<YOUR-USER-LOGIN>',\n   *     password: '<YOUR-USER-PASSWORD>'\n   *   })\n   * })\n   * // Add connection establised listener\n   * client.onConnectionEstablished(() => {\n   *   console.log('onConnectionEstablished')\n   *   const profile = client.getUserInfo()\n   *   console.log('Your profile', profile)\n   * })\n   * client.connect()\n   */\n  getUserInfo() {\n    return this.helper.getUserInfo();\n  }\n  /**\n   * Remove a connection status listener\n   * @param {number} handler\n   */\n  removeConnectionStatusListener(handler) {\n    return this.helper.removeConnectionStatusListener(handler);\n  }\n  /**\n   * Set a new authentication methods\n   * @param {function():AbstractHandshake} authentication\n   */\n  setAuthentication(authentication) {\n    this.helper.setAuthentication(authentication);\n  }\n  /**\n   * Set logging level\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.helper.setLogLevel(level);\n  }\n  /**\n   * Set new client resource value\n   * @param {string} resource\n   */\n  setResource(resource) {\n    this.helper.setResource(resource);\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} service\n   */\n  unsubscribe(service) {\n    if (!service.$subscriptions) {\n      throw new TypeError('Missing $subscriptions property in service');\n    }\n    return this.helper.unsubscribe(service.$subscriptions);\n  }\n}\n\n/**\n * Add shorthand connection status method\n */\nObject.getOwnPropertyNames(ConnectionStatusListener.prototype).forEach(\n  (method) => {\n    // Only implements unsupported methods\n    if (!Client.prototype.hasOwnProperty(method)) {\n      Client.prototype[method] = function addListener(listener) {\n        return this.addConnectionStatusListener({\n          [method]: listener,\n        });\n      };\n    }\n  },\n);\n","/**\n * Provide fallback for DOMStorage\n * @access protected\n */\nclass MemoryStorage {\n  constructor() {\n    this._map = new Map();\n  }\n  getItem(key) {\n    return this._map.get(key);\n  }\n  setItem(key, value) {\n    return this._map.get(key);\n  }\n  removeItem(key) {\n    this._map.delete(key);\n  }\n  clear() {\n    this._map = new Map();\n  }\n  key(n) {\n    return Array.from(this._map.keys())[n];\n  }\n  get length() {\n    return this._map.size;\n  }\n}\n\n/**\n * @type {Storage}\n * @access protected\n */\nexport const platformStorage =\n  typeof localStorage === 'undefined' ? new MemoryStorage() : localStorage;\n","import { platformStorage } from './storage';\n\n/**\n * @type {string}\n */\nexport const ZETAPUSH_SESSION_KEY = 'zetapush.token';\n\n/**\n * Provide abstraction for token persistence\n * @access protected\n */\nexport class SessionPersistenceStrategy {\n  /**\n   * @param {{sandboxId: string, storage: DOMStorage}} parameters\n   */\n  constructor({ sandboxId, storage = platformStorage } = {}) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.key = `${ZETAPUSH_SESSION_KEY}.${sandboxId}`;\n    /**\n     * @access private\n     * @type {DOMStorage}\n     */\n    this.storage = storage;\n  }\n  /**\n   * @return {string} session The stored session\n   */\n  get() {\n    const { key, storage } = this;\n    const json = storage.getItem(key) || '{}';\n    let session = {};\n    try {\n      session = JSON.parse(json);\n    } catch (e) {}\n    return session;\n  }\n  /**\n   * @param {Object} session The session to store\n   */\n  set(session = {}) {\n    const { key, storage } = this;\n    const json = JSON.stringify(session);\n    try {\n      storage.setItem(key, json);\n    } catch (e) {}\n    return session;\n  }\n}\n","import { Client } from './basic';\nimport { Authentication } from '../authentication/handshake';\nimport { SessionPersistenceStrategy } from '../utils/session-persistence';\n\n/**\n * SmartClient deployment infos.\n * @typedef {Object} SmartClientDeployment\n * @property {string} simple - Simple deployment id\n * @property {string} weak - Weak deployment id\n */\n\n/**\n * SmartClient config object.\n * @typedef {Object} SmartClientConfig\n * @property {string} apiUrl - Api Url\n * @property {SmartClientDeployment} deployment - Deployment infos\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.SmartClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class SmartClient extends Client {\n  /**\n   * Create a new ZetaPush SmartClient\n   * @param {SmartClientConfig} config\n   */\n  constructor({\n    apiUrl,\n    deployment,\n    sandboxId,\n    forceHttps,\n    resource,\n    transports,\n  }) {\n    const persistence = new SessionPersistenceStrategy({ sandboxId });\n\n    /**\n     * @return {AbstractHandshakeManager}\n     */\n    const authentication = () => {\n      const session = persistence.get();\n      const { token } = session;\n\n      if (this.hasCredentials()) {\n        const { login, password } = this.getCredentials();\n        this.setCredentials({});\n        return Authentication.simple({\n          login,\n          password,\n          deploymentId: deployment && deployment.simple,\n        });\n      } else {\n        if (this.isStronglyAuthenticated(session)) {\n          return Authentication.simple({\n            login: token,\n            password: null,\n            deploymentId: deployment && deployment.simple,\n          });\n        } else {\n          return Authentication.weak({\n            token,\n            deploymentId: deployment && deployment.weak,\n          });\n        }\n      }\n    };\n    // Initialize base client\n    super({\n      apiUrl,\n      sandboxId,\n      authentication,\n      forceHttps,\n      resource,\n      transports,\n    });\n    /**\n     * @access protected\n     * @type {SessionPersistenceStrategy}\n     */\n    this.persistence = persistence;\n    /**\n     * @access protected\n     * @type {Object}\n     */\n    this.credentials = {};\n    /**\n     * Handle connection lifecycle events\n     * @access protected\n     * @type {Object}\n     */\n    this.lifeCycleConnectionHandler = this.addConnectionStatusListener({\n      onConnectionClosed() {\n        persistence.set({});\n      },\n      onSuccessfulHandshake(session) {\n        if (session.token) {\n          persistence.set(session);\n        }\n      },\n    });\n    // Properly disconnect client to avoir ghost connections\n    /*\n    window.addEventListener('beforeunload', () => {\n      this.removeConnectionStatusListener(this.lifeCycleConnectionHandler)\n      super.disconnect()\n    })\n    */\n  }\n  /**\n   * Disconnect client from ZetaPush backend\n   */\n  disconnect() {\n    super.disconnect();\n  }\n  /**\n   * @return {Object}\n   */\n  getCredentials() {\n    return this.credentials;\n  }\n  /**\n   * @return {Object}\n   */\n  getSession() {\n    return this.persistence.get();\n  }\n  /**\n   * @return {boolean}\n   */\n  hasCredentials() {\n    const { login, password } = this.getCredentials();\n    return login && password;\n  }\n  /**\n   * @return {boolean}\n   */\n  isStronglyAuthenticated(session = this.persistence.get()) {\n    return (\n      !this.isWeaklyAuthenticated(session) && typeof session.token === 'string'\n    );\n  }\n  /**\n   * @return {boolean}\n   */\n  isWeaklyAuthenticated(session = this.persistence.get()) {\n    return typeof session.publicToken === 'string';\n  }\n  /**\n   * @param {{login: string, password: string}} parameters\n   */\n  setCredentials({ login, password }) {\n    this.credentials = { login, password };\n  }\n}\n","import { Client } from './basic';\nimport { Authentication } from '../authentication/handshake';\nimport { SessionPersistenceStrategy } from '../utils/session-persistence';\n\n/**\n * WeakClient config object.\n * @typedef {Object} WeakClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} deploymentId - Authentication deployment id, default value is 'weak_0'\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.WeakClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n * @example\n * // Explicit deploymentId\n * // WeakClient provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`\n * // deploymentId default value is weak_0\n * const client = new ZetaPush.WeakClient({\n *   deploymentId: 'weak_0',\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class WeakClient extends Client {\n  /**\n   * Create a new ZetaPush WeakClient\n   * @param {WeakClientConfig} config\n   */\n  constructor({\n    apiUrl,\n    sandboxId,\n    deploymentId,\n    forceHttps,\n    resource,\n    transports,\n  }) {\n    const authentication = () => {\n      const token = this.getToken();\n      const handshake = Authentication.weak({\n        deploymentId,\n        token,\n      });\n      return handshake;\n    };\n    /**\n     * Call Client constructor with specific parameters\n     */\n    super({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      authentication,\n      resource,\n      transports,\n    });\n    // Handle successful handshake\n    const onSuccessfulHandshake = ({ publicToken, userId, token }) => {\n      if (token) {\n        this.strategy.set({ publicToken, userId, token });\n      }\n    };\n    this.addConnectionStatusListener({ onSuccessfulHandshake });\n    /**\n     * @access private\n     * @type {SessionPersistenceStrategy}\n     */\n    this.strategy = new SessionPersistenceStrategy({ sandboxId });\n  }\n  /**\n   * @return {string} The stored token\n   */\n  getToken() {\n    const { token } = this.strategy.get();\n    return token;\n  }\n}\n","import { Client } from './basic';\nimport { Authentication } from '../authentication/handshake';\nimport { uuid } from '../utils';\nimport { Queue } from '../mapping/services';\n\nexport class ServerClient extends Client {\n  constructor({ apiUrl, sandboxId, forceHttps, transports, login, password }) {\n    const authentication = () =>\n      Authentication.developer({\n        login,\n        password,\n      });\n    const resource = uuid();\n    /**\n     * Call Client constructor with specific parameters\n     */\n    super({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      authentication,\n      resource,\n      transports,\n    });\n  }\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      const handlers = [];\n      if (this.isConnected()) {\n        const onConnectionClosed = () => {\n          // Remove connection status listener\n          handlers.forEach((handler) => {\n            this.removeConnectionStatusListener(handler);\n          });\n          // Resolve disconnection\n          resolve();\n        };\n        handlers.push(this.onConnectionClosed(onConnectionClosed));\n        // Disconnect client\n        super.disconnect();\n      } else {\n        // Resolve disconnection\n        resolve();\n      }\n    });\n  }\n  connect() {\n    return new Promise((resolve, reject) => {\n      const handlers = [];\n      this.disconnect().then(() => {\n        const onFailedHandshake = (error) => {\n          // Remove connection status listener\n          handlers.forEach((handler) => {\n            this.removeConnectionStatusListener(handler);\n          });\n          // Reconnect client via weak auth\n          super.connect();\n          // Reject connection\n          reject(error);\n        };\n        const onConnectionEstablished = () => {\n          // Remove connection status listener\n          handlers.forEach((handler) => {\n            this.removeConnectionStatusListener(handler);\n          });\n          // Resolve connection success\n          resolve();\n        };\n        // Handle connection success and fail\n        handlers.push(this.onConnectionEstablished(onConnectionEstablished));\n        handlers.push(this.onFailedHandshake(onFailedHandshake));\n        // Connect client to ZetaPush backend\n        super.connect();\n      });\n    });\n  }\n  subscribeTaskServer(Worker, deploymentId = Queue.DEFAULT_DEPLOYMENT_ID) {\n    console.log('subscribeTaskServer', Worker, deploymentId);\n    const queue = this.createService({\n      deploymentId,\n      listener: {\n        async dispatch({ data: { request, taskId } }) {\n          console.log('dispatch', { request, taskId });\n          const { data, requestId } = request;\n          const { name, namespace, parameters } = data;\n          console.log('Queue::dispatch', {\n            name,\n            namespace,\n            parameters,\n            requestId,\n            taskId,\n          });\n          try {\n            const result = await Worker[name](parameters);\n            console.log('result', result);\n            queue.done({\n              result,\n              taskId,\n              requestId,\n              success: true,\n            });\n          } catch (error) {\n            console.log('error', error);\n            queue.done({\n              result: { code: '', message: '' },\n              taskId,\n              requestId,\n              success: false,\n            });\n          }\n        },\n      },\n      Type: Queue,\n    });\n    queue.register({\n      capacity: 100,\n    });\n  }\n}\n","export { Authentication } from './authentication/handshake';\nexport { ConnectionStatusListener } from './connection/connection-status';\n\nexport { Client } from './client/basic';\nexport { SmartClient } from './client/smart';\nexport { WeakClient } from './client/weak';\nexport { ServerClient } from './client/server';\n\nexport { services } from './mapping';\n\n/**\n * SDK Version\n * @type {string}\n */\nexport const VERSION = '3.4.0-alpha.2';\n"],"names":["Service","$publish","Delegating","Simple","Weak","this","publicToken","fullRights","DeployableNames","AbstractHandshake","authType","sandboxId","deploymentId","client","authentication","authData","getSandboxId","authVersion","getResource","resource","TokenHandshake","token","CredentialsHandshake","login","password","Authentication","create","DEFAULT_DEPLOYMENT_ID","ConnectionStatusListener","failure","value","undefined","String","Array","element","array","i","length","cometd","funktion","delay","setTimeout","_debug","x","timeoutHandle","clearTimeout","_type","_cometd","_url","registered","type","unregistered","apply","arguments","_mixin","getConfiguration","getAdvice","Utils","handle","convertToMessages","response","isString","JSON","parse","isArray","Object","accept","version","crossDomain","url","getType","getURL","setURL","send","envelope","metaConnect","reset","init","abort","toString","baseObject","F","prototype","_super","Transport","_self","derive","_requestIds","_metaConnectRequest","_requests","_envelopes","_transportSend","request","transportSend","expired","sync","maxDelay","maxNetworkDelay","timeout","self","errorMessage","id","reason","xhr","httpCode","xhrStatus","abortXHR","complete","onFailure","messages","_queueSend","requestId","maxConnections","push","call","_complete","success","index","inArray","splice","envelopeAndRequest","shift","nextEnvelope","nextRequest","autoBatch","newEnvelope","newRequest","concat","transportSuccess","responses","onSuccess","transportFailure","state","readyState","XMLHttpRequest","UNSENT","status","RequestTransport","_supportsCrossDomain","xhrSend","packet","sameStack","transport","headers","requestHeaders","body","stringify","received","exception","onError","FetchLongPollingTransport","LongPollingTransport","that","fetch","method","assign","Content-Type","then","json","catch","WebSocketTransport","_webSocketSupported","_webSocketConnected","_stickyReconnect","_context","_connecting","_connected","_successCallback","_forceClose","context","event","webSocketClose","code","onClose","_sameContext","_storeEnvelope","messageIds","message","envelopes","join","_webSocketSend","webSocket","timeouts","_send","replace","protocol","WebSocket","stickyReconnect","connectTimeout","connectTimer","onclose","onopen","onOpen","_warn","onerror","onmessage","wsMessage","onMessage","_notifySuccess","fn","_notifyFailure","key","hasOwnProperty","close","data","test","channel","removed","j","ids","split","websocketCode","websocketEnabled","window","WEBSOCKET_TRANSPORT","TRANSPORT_TYPES","LONG_POLLING_TRANSPORT","name","_transport","_handshakeProps","_handshakeCallback","_handleMessages","_handleFailure","_name","_crossDomain","_transports","_types","getTransportTypes","slice","findTransportTypes","result","negotiateTransport","types","add","existing","find","remove","clear","_status","_messageId","_clientId","_batch","_messageQueue","_internalBatch","_listeners","_backoff","_scheduledSend","_extensions","_advice","_callbacks","_remoteCalls","_reestablish","_handshakeMessages","_config","backoffIncrement","maxBackoff","logLevel","reverseIncomingExtensions","appendMessageTypeToURL","urls","maxURILength","advice","interval","reconnect","maxInterval","_fieldValue","object","_isString","_isFunction","_zeroPad","Math","pow","_log","level","args","console","logger","now","Date","getHours","getMinutes","getSeconds","getMilliseconds","_removeListener","subscription","subscriptions","listener","_removeSubscription","_clearSubscriptions","_setStatus","newStatus","_isDisconnected","_nextMessageId","_applyExtension","scope","callback","outgoing","handler","onExtensionException","xx","_info","_applyOutgoingExtensions","extension","_notify","onListenerException","_notifyListeners","channelParts","last","channelPart","_cancelDelayedSend","_delayedSend","operation","time","extraPath","messageId","clientId","match","rcvdMessages","conduit","getTransport","connectionType","_resetBackoff","_increaseBackoff","_flushBatch","_delayedConnect","bayeuxMessage","_connect","_updateAdvice","newAdvice","_disconnect","_notifyTransportFailure","oldTransport","newTransport","onTransportException","_handshake","handshakeProps","handshakeCallback","transportTypes","minimumVersion","supportedConnectionTypes","_putCallback","_delayedHandshake","_notifyCallback","onCallbackException","_handleCallback","_getCallback","_handleRemoteCall","_failHandshake","_handshakeFailure","_failConnect","action","_connectFailure","_failDisconnect","_disconnectFailure","_failSubscribe","_subscribeFailure","_failUnsubscribe","_unsubscribeFailure","_failMessage","_messageFailure","_receive","incoming","_applyIncomingExtensions","successful","reestablish","_handshakeResponse","_connectResponse","_disconnectResponse","_subscribeResponse","_unsubscribeResponse","_messageResponse","_hasSubscriptions","_resolveScopedCallback","delegate","_addListener","isListener","deep","target","objects","propName","prop","targ","_isCrossDomain","hostAndPort","host","location","receive","failureMessage","registerTransport","unregisterTransport","unregisterTransports","findTransport","getTransportRegistry","configure","configuration","urlParts","exec","_splitURL","uri","afterURI","uriSegments","lastSegmentIndex","indexOf","_configure","handshake","disconnect","disconnectProps","disconnectCallback","startBatch","endBatch","_endBatch","batch","addListener","removeListener","clearListeners","subscribe","subscribeProps","subscribeCallback","unsubscribe","unsubscribeProps","unsubscribeCallback","resubscribe","clearSubscriptions","publish","content","publishProps","publishCallback","remoteCall","error","getStatus","isDisconnected","setBackoffIncrement","period","getBackoffIncrement","getBackoffPeriod","increaseBackoffPeriod","resetBackoffPeriod","setLogLevel","registerExtension","unregisterExtension","ext","getExtension","getName","getClientId","Aggreg","items","owner","Stack","stack","page","guids","listeners","guid","Echo","parameter","Game","role","gameId","userId","userName","options","GameEngine","msgId","payload","callerId","maxGames","gameInfo","Gda","table","key2","column","columns","rows","start","stop","Remoting","fromResource","cmd","from","askingResource","capabilities","answeringResource","user","available","uid","GroupManagement","group","users","groupName","hardFail","actions","Httpclient","MacroDebug","breakpoint","enabled","path","exp","frame","parameters","breakpoints","debug","Macro","Sendmail","Messaging","Queue","description","originBusinessId","originDeploymentId","taskId","capacity","Notif","Rdbms","Sms_ovh","Cron","Search","indices","query","sort","Template","languageTag","Trigger","Zpfs_s3","oldPath","folder","parents","tags","metadata","contentType","flatten","metadataFiles","Zpfs_hdfs","Zpfs_s3compat","Userdir","userKeys","HTTP_PATTERN","API_URL","FORCE_HTTPS","shuffle","list","floor","random","getSecureUrl","forceHttps","HTTPS_PROTOCOL","getServers","transports","normalizedSecuresApiUrl","apiUrl","charAt","normalizeApiUrl","servers","map","server","uuid","dictionary","reduce","previous","Message","ClientHelper","Transports","userInfo","uniqId","connectionToServerFail","connectionListeners","connected","wasConnected","serverUrl","sessionId","subscribeQueue","CometD","ALL","forEach","updateServerUrl","initialized","handshakeFailure","RECONNECT_NONE_VALUE","authenticationFailed","RECONNECT_HANDSHAKE_VALUE","negotiationFailed","_this","connectionWillClose","prefix","connectionEstablished","connectionBroken","connectionClosed","filter","onFailedHandshake","_this2","getHandshakeFields","noServerUrlAvailable","onConnectionBroken","onConnectionClosed","onConnectionEstablished","onConnectionToServerFail","onConnectionWillClose","Type","getAsyncMacroPublisher","createServiceByPublisher","getAsyncTaskPublisher","isMacroType","Derived","Parent","getPrototypeOf","is","isDerivedOf","getMacroPublisher","getServicePublisher","service","$subscriptions","uniqRequestId","_this3","getUniqRequestId","Promise","resolve","reject","errors","namespace","_this4","_this5","findIndex","_this6","onSuccessfulHandshake","onMessageLost","onNegotiationFailed","onNoServerUrlAvailable","getQueuedSubscription","queued","_this7","Client","helper","addConnectionStatusListener","isConnected","removeConnectionStatusListener","connect","createAsyncMacroService","createAsyncTaskService","createService","getUserId","getUserInfo","setAuthentication","setResource","TypeError","getOwnPropertyNames","MemoryStorage","_map","Map","get","delete","n","keys","size","platformStorage","localStorage","ZETAPUSH_SESSION_KEY","SessionPersistenceStrategy","storage","getItem","session","e","setItem","SmartClient","deployment","persistence","hasCredentials","getCredentials","setCredentials","simple","isStronglyAuthenticated","weak","credentials","lifeCycleConnectionHandler","set","isWeaklyAuthenticated","WeakClient","getToken","strategy","ServerClient","developer","handlers","Worker","log","queue","done","register"],"mappings":"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"}