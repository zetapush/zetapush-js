(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.ZetaPush = {})));
}(this, (function (exports) { 'use strict';

var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * @access protected
 */
var Service = function Service(_ref) {
  var $publish = _ref.$publish;
  classCallCheck(this, Service);

  this.$publish = $publish;
};

/**
 * Delegating authentication
 *
 * This authentication delegates authentication to an external auth provider
 * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL
 * <br>The response must be in JSON format
 *  Each key of the response will be considered a user information field name
 * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)
 * */
/**
 * End-user API for the delegating authentication
 *
 * Provisionning verbs.
 * @access public
 * */
var Delegating = function (_Service) {
  inherits(Delegating, _Service);

  function Delegating() {
    classCallCheck(this, Delegating);
    return possibleConstructorReturn(this, (Delegating.__proto__ || Object.getPrototypeOf(Delegating)).apply(this, arguments));
  }

  createClass(Delegating, null, [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Delegating service
     * @return {string}
     */
    get: function get$$1() {
      return 'delegating_0';
    }
  }]);
  return Delegating;
}(Service);
/**
 * Local authentication
 *
 * Zetapush local authentication
 *  The configurer can choose the primary key and mandatory user fields for account creation
 *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)
 * */
/**
 * End-user API for the simple local authentication
 *
 * These API verbs allow end-users to manage their account.
 * @access public
 * */
var Simple = function (_Service2) {
  inherits(Simple, _Service2);

  function Simple() {
    classCallCheck(this, Simple);
    return possibleConstructorReturn(this, (Simple.__proto__ || Object.getPrototypeOf(Simple)).apply(this, arguments));
  }

  createClass(Simple, null, [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Simple service
     * @return {string}
     */
    get: function get$$1() {
      return 'simple_0';
    }
  }]);
  return Simple;
}(Service);
/**
 * Weak authentication
 *
 * The weak authentication allows for anonymous authentication of devices
 *  Such devices can display a qrcode to allow regular users to take control of them
 * */
/**
 * User API for weak devices control
 *
 * User API for control and release of weakly authenticated user sessions.
 * @access public
 * */
var Weak = function (_Service3) {
  inherits(Weak, _Service3);

  function Weak() {
    classCallCheck(this, Weak);
    return possibleConstructorReturn(this, (Weak.__proto__ || Object.getPrototypeOf(Weak)).apply(this, arguments));
  }

  createClass(Weak, [{
    key: 'control',

    /**
     * Controls a session
     *
     * Takes control of a weak user session, identified by the given public token.
     * The public token has been previously made available by the controlled device, for example by displaying a QRCode.
     * Upon control notification, the client SDK of the controlled session is expected to re-handshake.
     * */
    value: function control(_ref) {
      var publicToken = _ref.publicToken,
          fullRights = _ref.fullRights;

      return this.$publish('control', { publicToken: publicToken, fullRights: fullRights });
    }
    /**
     * Returns the current token
     *
     * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.
     * The token can be used to log in as the same weak user another time.
     * */

  }, {
    key: 'getToken',
    value: function getToken() {
      return this.$publish('getToken', {});
    }
    /**
     * Releases a session
     *
     * Releases control of a weak user session, identified by the given public token.
     * The weak user session must have been previously controlled by a call to 'control'.
     * */

  }, {
    key: 'release',
    value: function release(_ref2) {
      var publicToken = _ref2.publicToken,
          fullRights = _ref2.fullRights;

      return this.$publish('release', { publicToken: publicToken, fullRights: fullRights });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Weak service
     * @return {string}
     */
    get: function get$$1() {
      return 'weak_0';
    }
  }]);
  return Weak;
}(Service);

/**
 * ZetaPush deployables names
 */
var DeployableNames = {
  AUTH_SIMPLE: 'simple',
  AUTH_WEAK: 'weak',
  AUTH_DELEGATING: 'delegating',
  AUTH_DEVELOPER: 'developer'
};

/**
 * Provide abstraction over CometD handshake data structure
 * @access protected
 */

var AbstractHandshake = function () {
  /**
   * Create a new handshake manager
   * @param {{authType: string, sandboxId: string, deploymentId: string}} parameters
   */
  function AbstractHandshake(_ref) {
    var authType = _ref.authType,
        sandboxId = _ref.sandboxId,
        deploymentId = _ref.deploymentId;
    classCallCheck(this, AbstractHandshake);

    /**
     * @access protected
     * @type {string}
     */
    this.authType = authType;
    /**
     * @access protected
     * @type {string}
     */
    this.sandboxId = sandboxId;
    /**
     * @access protected
     * @type {string}
     */
    this.deploymentId = deploymentId;
  }
  /**
   * @param {ClientHelper} client
   * @return {Object}
   */


  createClass(AbstractHandshake, [{
    key: 'getHandshakeFields',
    value: function getHandshakeFields(client) {
      var authentication = {
        data: this.authData,
        type: client.getSandboxId() + '.' + this.deploymentId + '.' + this.authType,
        version: this.authVersion
      };
      if (client.getResource()) {
        authentication.resource = client.getResource();
      }
      return {
        ext: {
          authentication: authentication
        }
      };
    }
    /**
     * Get auth version
     * @return {string}
     */

  }, {
    key: 'authVersion',
    get: function get$$1() {
      return 'none';
    }
  }]);
  return AbstractHandshake;
}();

/**
 * Provide abstraction over CometD token base handshake data structure
 * @access protected
 * @extends {AbstractHandshake}
 */


var TokenHandshake = function (_AbstractHandshake) {
  inherits(TokenHandshake, _AbstractHandshake);

  /**
   * @param {{authType: string, deploymentId: string, token: string}} parameters
   */
  function TokenHandshake(_ref2) {
    var authType = _ref2.authType,
        deploymentId = _ref2.deploymentId,
        token = _ref2.token;
    classCallCheck(this, TokenHandshake);

    /**
     * @access private
     * @type {string}
     */
    var _this = possibleConstructorReturn(this, (TokenHandshake.__proto__ || Object.getPrototypeOf(TokenHandshake)).call(this, {
      deploymentId: deploymentId,
      authType: authType
    }));

    _this.token = token;
    return _this;
  }
  /**
   * @return {token: string}
   */


  createClass(TokenHandshake, [{
    key: 'authData',
    get: function get$$1() {
      var token = this.token;

      return {
        token: token
      };
    }
  }]);
  return TokenHandshake;
}(AbstractHandshake);

/**
 * Provide abstraction over CometD credentials based handshake data structure
 * @access protected
 * @extends {AbstractHandshake}
 */


var CredentialsHandshake = function (_AbstractHandshake2) {
  inherits(CredentialsHandshake, _AbstractHandshake2);

  /**
   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters
   */
  function CredentialsHandshake(_ref3) {
    var authType = _ref3.authType,
        deploymentId = _ref3.deploymentId,
        login = _ref3.login,
        password = _ref3.password;
    classCallCheck(this, CredentialsHandshake);

    /**
     * @access private
     * @type {string}
     */
    var _this2 = possibleConstructorReturn(this, (CredentialsHandshake.__proto__ || Object.getPrototypeOf(CredentialsHandshake)).call(this, {
      authType: authType,
      deploymentId: deploymentId
    }));

    _this2.login = login;
    /**
     * @access private
     * @type {string}
     */
    _this2.password = password;
    return _this2;
  }
  /**
   * Get auth data
   * @return {login: string, password: string}
   */


  createClass(CredentialsHandshake, [{
    key: 'authData',
    get: function get$$1() {
      var login = this.login,
          password = this.password;

      return {
        login: login,
        password: password
      };
    }
  }]);
  return CredentialsHandshake;
}(AbstractHandshake);

/**
 * Factory to create handshake
 * @access public
 */


var Authentication = function () {
  function Authentication() {
    classCallCheck(this, Authentication);
  }

  createClass(Authentication, null, [{
    key: 'simple',

    /**
     * @param {{deploymentId: string, login: string, password: string}} parameters
     * @return {CredentialsHandshake}
     * @example
     * // Explicit deploymentId
     * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`
     * Authentication.delegating({
     *   deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',
     *   login: <USER-LOGIN>,
     *   password: '<USER-PASSWORD>'
     * })
     */
    value: function simple(_ref4) {
      var _ref4$deploymentId = _ref4.deploymentId,
          deploymentId = _ref4$deploymentId === undefined ? Simple.DEFAULT_DEPLOYMENT_ID : _ref4$deploymentId,
          login = _ref4.login,
          password = _ref4.password;

      return Authentication.create({
        authType: DeployableNames.AUTH_SIMPLE,
        deploymentId: deploymentId,
        login: login,
        password: password
      });
    }
    /**
     * @param {{deploymentId: string, token: string}} parameters
     * @return {TokenHandshake}
     * @example
     * // Explicit deploymentId
     * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`
     * Authentication.delegating({
     *   deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',
     *   token: null
     * })
     */

  }, {
    key: 'weak',
    value: function weak(_ref5) {
      var _ref5$deploymentId = _ref5.deploymentId,
          deploymentId = _ref5$deploymentId === undefined ? Weak.DEFAULT_DEPLOYMENT_ID : _ref5$deploymentId,
          token = _ref5.token;

      return Authentication.create({
        authType: DeployableNames.AUTH_WEAK,
        deploymentId: deploymentId,
        login: token,
        password: null
      });
    }
    /**
     * @param {{deploymentId: string, token: string}} parameters
     * @return {TokenHandshake}
     * @example
     * // Explicit deploymentId
     * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`
     * Authentication.delegating({
     *   deploymentId: '<YOUR-DELEGATING-AUTHENTICATION-DEPLOYMENT-ID>',
     *   token: null
     * })
     */

  }, {
    key: 'delegating',
    value: function delegating(_ref6) {
      var _ref6$deploymentId = _ref6.deploymentId,
          deploymentId = _ref6$deploymentId === undefined ? Delegating.DEFAULT_DEPLOYMENT_ID : _ref6$deploymentId,
          token = _ref6.token;

      return Authentication.create({
        authType: DeployableNames.AUTH_DELEGATING,
        deploymentId: deploymentId,
        login: token,
        password: null
      });
    }
  }, {
    key: 'developer',
    value: function developer(_ref7) {
      var login = _ref7.login,
          password = _ref7.password;

      return Authentication.create({
        authType: DeployableNames.AUTH_DEVELOPER,
        deploymentId: DeployableNames.AUTH_DEVELOPER,
        login: login,
        password: password
      });
    }
    /**
     * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters
     * @return {TokenHandshake|CredentialsHandshake}
     */

  }, {
    key: 'create',
    value: function create(_ref8) {
      var authType = _ref8.authType,
          deploymentId = _ref8.deploymentId,
          login = _ref8.login,
          password = _ref8.password;

      if (password === null) {
        return new TokenHandshake({
          authType: authType,
          deploymentId: deploymentId,
          token: login
        });
      }
      return new CredentialsHandshake({
        authType: authType,
        deploymentId: deploymentId,
        login: login,
        password: password
      });
    }
  }]);
  return Authentication;
}();

/**
 * Define life cycle connection methods
 * @access public
 */
var ConnectionStatusListener = function () {
  function ConnectionStatusListener() {
    classCallCheck(this, ConnectionStatusListener);
  }

  createClass(ConnectionStatusListener, [{
    key: "onConnectionBroken",

    /**
     * Callback fired when connection is broken
     */
    value: function onConnectionBroken() {}
    /**
     * Callback fired when connection is closed
     */

  }, {
    key: "onConnectionClosed",
    value: function onConnectionClosed() {}
    /**
     * Callback fired when connection is established
     */

  }, {
    key: "onConnectionEstablished",
    value: function onConnectionEstablished() {}
    /**
     * Callback fired when an error occurs in connection to server step
     * @param {Object} failure
     */

  }, {
    key: "onConnectionToServerFail",
    value: function onConnectionToServerFail(failure) {}
    /**
     * Callback fired when negociation with server failed
     * @param {Object} failure
     */

  }, {
    key: "onNegotiationFailed",
    value: function onNegotiationFailed(failure) {}
    /**
     * Callback no server url avaibale
     */

  }, {
    key: "onNoServerUrlAvailable",
    value: function onNoServerUrlAvailable() {}
    /**
     * Callback fired when connection will close
     */

  }, {
    key: "onConnectionWillClose",
    value: function onConnectionWillClose() {}
    /**
     * Callback fired when an error occurs in handshake step
     * @param {Object} failure
     */

  }, {
    key: "onFailedHandshake",
    value: function onFailedHandshake(failure) {}
    /**
     * Callback fired when a message is lost
     */

  }, {
    key: "onMessageLost",
    value: function onMessageLost() {}
    /**
     * Callback fired when handshake step succeed
     * @param {Object} authentication
     */

  }, {
    key: "onSuccessfulHandshake",
    value: function onSuccessfulHandshake(authentication) {}
  }]);
  return ConnectionStatusListener;
}();

/**
 * A registry for transports used by the CometD object.
 */
var TransportRegistry = function TransportRegistry() {
    var _types = [];
    var _transports = {};

    this.getTransportTypes = function() {
        return _types.slice(0);
    };

    this.findTransportTypes = function(version, crossDomain, url) {
        var result = [];
        for (var i = 0; i < _types.length; ++i) {
            var type = _types[i];
            if (_transports[type].accept(version, crossDomain, url) === true) {
                result.push(type);
            }
        }
        return result;
    };

    this.negotiateTransport = function(types, version, crossDomain, url) {
        for (var i = 0; i < _types.length; ++i) {
            var type = _types[i];
            for (var j = 0; j < types.length; ++j) {
                if (type === types[j]) {
                    var transport = _transports[type];
                    if (transport.accept(version, crossDomain, url) === true) {
                        return transport;
                    }
                }
            }
        }
        return null;
    };

    this.add = function(type, transport, index) {
        var existing = false;
        for (var i = 0; i < _types.length; ++i) {
            if (_types[i] === type) {
                existing = true;
                break;
            }
        }

        if (!existing) {
            if (typeof index !== 'number') {
                _types.push(type);
            } else {
                _types.splice(index, 0, type);
            }
            _transports[type] = transport;
        }

        return !existing;
    };

    this.find = function(type) {
        for (var i = 0; i < _types.length; ++i) {
            if (_types[i] === type) {
                return _transports[type];
            }
        }
        return null;
    };

    this.remove = function(type) {
        for (var i = 0; i < _types.length; ++i) {
            if (_types[i] === type) {
                _types.splice(i, 1);
                var transport = _transports[type];
                delete _transports[type];
                return transport;
            }
        }
        return null;
    };

    this.clear = function() {
        _types = [];
        _transports = {};
    };

    this.reset = function(init) {
        for (var i = 0; i < _types.length; ++i) {
            _transports[_types[i]].reset(init);
        }
    };
};

var isString = function (value) {
    if (value === undefined || value === null) {
        return false;
    }
    return typeof value === 'string' || value instanceof String;
};

var isArray = function (value) {
    if (value === undefined || value === null) {
        return false;
    }
    return value instanceof Array;
};

/**
 * Returns whether the given element is contained into the given array.
 * @param element the element to check presence for
 * @param array the array to check for the element presence
 * @return the index of the element, if present, or a negative index if the element is not present
 */
var inArray = function (element, array) {
    for (var i = 0; i < array.length; ++i) {
        if (element === array[i]) {
            return i;
        }
    }
    return -1;
};

var setTimeout_1 = function (cometd, funktion, delay) {
    return setTimeout(function() {
        try {
            cometd._debug('Invoking timed function', funktion);
            funktion();
        } catch (x) {
            cometd._debug('Exception invoking timed function', funktion, x);
        }
    }, delay);
};

var clearTimeout_1 = function (timeoutHandle) {
    clearTimeout(timeoutHandle);
};

var Utils = {
	isString: isString,
	isArray: isArray,
	inArray: inArray,
	setTimeout: setTimeout_1,
	clearTimeout: clearTimeout_1
};

/**
 * The constructor for a CometD object, identified by an optional name.
 * The default name is the string 'default'.
 * In the rare case a page needs more than one Bayeux conversation,
 * a new instance can be created via:
 * <pre>
 * var bayeuxUrl2 = ...;
 *
 * // Dojo style
 * var cometd2 = new dojox.CometD('another_optional_name');
 *
 * // jQuery style
 * var cometd2 = new $.CometD('another_optional_name');
 *
 * cometd2.init({url: bayeuxUrl2});
 * </pre>
 * @param name the optional name of this cometd object
 */
var CometD = function CometD(name) {
    var _cometd = this;
    var _name = name || 'default';
    var _crossDomain = false;
    var _transports = new TransportRegistry();
    var _transport;
    var _status = 'disconnected';
    var _messageId = 0;
    var _clientId = null;
    var _batch = 0;
    var _messageQueue = [];
    var _internalBatch = false;
    var _listeners = {};
    var _backoff = 0;
    var _scheduledSend = null;
    var _extensions = [];
    var _advice = {};
    var _handshakeProps;
    var _handshakeCallback;
    var _callbacks = {};
    var _remoteCalls = {};
    var _reestablish = false;
    var _connected = false;
    var _handshakeMessages = 0;
    var _config = {
        protocol: null,
        stickyReconnect: true,
        connectTimeout: 0,
        maxConnections: 2,
        backoffIncrement: 1000,
        maxBackoff: 60000,
        logLevel: 'info',
        reverseIncomingExtensions: true,
        maxNetworkDelay: 10000,
        requestHeaders: {},
        appendMessageTypeToURL: true,
        autoBatch: false,
        urls: {},
        maxURILength: 2000,
        advice: {
            timeout: 60000,
            interval: 0,
            reconnect: 'retry',
            maxInterval: 0
        }
    };

    function _fieldValue(object, name) {
        try {
            return object[name];
        } catch (x) {
            return undefined;
        }
    }

    /**
     * Mixes in the given objects into the target object by copying the properties.
     * @param deep if the copy must be deep
     * @param target the target object
     * @param objects the objects whose properties are copied into the target
     */
    this._mixin = function(deep, target, objects) {
        var result = target || {};

        // Skip first 2 parameters (deep and target), and loop over the others
        for (var i = 2; i < arguments.length; ++i) {
            var object = arguments[i];

            if (object === undefined || object === null) {
                continue;
            }

            for (var propName in object) {
                if (object.hasOwnProperty(propName)) {
                    var prop = _fieldValue(object, propName);
                    var targ = _fieldValue(result, propName);

                    // Avoid infinite loops
                    if (prop === target) {
                        continue;
                    }
                    // Do not mixin undefined values
                    if (prop === undefined) {
                        continue;
                    }

                    if (deep && typeof prop === 'object' && prop !== null) {
                        if (prop instanceof Array) {
                            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
                        } else {
                            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
                            result[propName] = this._mixin(deep, source, prop);
                        }
                    } else {
                        result[propName] = prop;
                    }
                }
            }
        }

        return result;
    };

    function _isString(value) {
        return Utils.isString(value);
    }

    function _isFunction(value) {
        if (value === undefined || value === null) {
            return false;
        }
        return typeof value === 'function';
    }

    function _zeroPad(value, length) {
        var result = '';
        while (--length > 0) {
            if (value >= Math.pow(10, length)) {
                break;
            }
            result += '0';
        }
        result += value;
        return result;
    }

    function _log(level, args) {
        if ('undefined' !== typeof console) {
            var logger = console[level];
            if (_isFunction(logger)) {
                var now = new Date();
                [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +
                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));
                logger.apply(console, args);
            }
        }
    }

    this._warn = function() {
        _log('warn', arguments);
    };

    this._info = function() {
        if (_config.logLevel !== 'warn') {
            _log('info', arguments);
        }
    };

    this._debug = function() {
        if (_config.logLevel === 'debug') {
            _log('debug', arguments);
        }
    };

    function _splitURL(url) {
        // [1] = protocol://,
        // [2] = host:port,
        // [3] = host,
        // [4] = IPv6_host,
        // [5] = IPv4_host,
        // [6] = :port,
        // [7] = port,
        // [8] = uri,
        // [9] = rest (query / fragment)
        return /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
    }

    /**
     * Returns whether the given hostAndPort is cross domain.
     * The default implementation checks against window.location.host
     * but this function can be overridden to make it work in non-browser
     * environments.
     *
     * @param hostAndPort the host and port in format host:port
     * @return whether the given hostAndPort is cross domain
     */
    this._isCrossDomain = function(hostAndPort) {
        var host = typeof location === 'undefined' ? hostAndPort : location.host;
        return hostAndPort && hostAndPort !== host;
    };

    function _configure(configuration) {
        _cometd._debug('Configuring cometd object with', configuration);
        // Support old style param, where only the Bayeux server URL was passed
        if (_isString(configuration)) {
            configuration = { url: configuration };
        }
        if (!configuration) {
            configuration = {};
        }

        _config = _cometd._mixin(false, _config, configuration);

        var url = _cometd.getURL();
        if (!url) {
            throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
        }

        // Check if we're cross domain.
        var urlParts = _splitURL(url);
        var hostAndPort = urlParts[2];
        var uri = urlParts[8];
        var afterURI = urlParts[9];
        _crossDomain = _cometd._isCrossDomain(hostAndPort);

        // Check if appending extra path is supported
        if (_config.appendMessageTypeToURL) {
            if (afterURI !== undefined && afterURI.length > 0) {
                _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
                _config.appendMessageTypeToURL = false;
            } else {
                var uriSegments = uri.split('/');
                var lastSegmentIndex = uriSegments.length - 1;
                if (uri.match(/\/$/)) {
                    lastSegmentIndex -= 1;
                }
                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd
                    // It will be difficult to add the extra path in this case
                    _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
                    _config.appendMessageTypeToURL = false;
                }
            }
        }
    }

    function _removeListener(subscription) {
        if (subscription) {
            var subscriptions = _listeners[subscription.channel];
            if (subscriptions && subscriptions[subscription.id]) {
                delete subscriptions[subscription.id];
                _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
            }
        }
    }

    function _removeSubscription(subscription) {
        if (subscription && !subscription.listener) {
            _removeListener(subscription);
        }
    }

    function _clearSubscriptions() {
        for (var channel in _listeners) {
            if (_listeners.hasOwnProperty(channel)) {
                var subscriptions = _listeners[channel];
                if (subscriptions) {
                    for (var i = 0; i < subscriptions.length; ++i) {
                        _removeSubscription(subscriptions[i]);
                    }
                }
            }
        }
    }

    function _setStatus(newStatus) {
        if (_status !== newStatus) {
            _cometd._debug('Status', _status, '->', newStatus);
            _status = newStatus;
        }
    }

    function _isDisconnected() {
        return _status === 'disconnecting' || _status === 'disconnected';
    }

    function _nextMessageId() {
        var result = ++_messageId;
        return '' + result;
    }

    function _applyExtension(scope, callback, name, message, outgoing) {
        try {
            return callback.call(scope, message);
        } catch (x) {
            var handler = _cometd.onExtensionException;
            if (_isFunction(handler)) {
                _cometd._debug('Invoking extension exception handler', name, x);
                try {
                    handler.call(_cometd, x, name, outgoing, message);
                } catch (xx) {
                    _cometd._info('Exception during execution of extension exception handler', name, xx);
                }
            } else {
                _cometd._info('Exception during execution of extension', name, x);
            }
            return message;
        }
    }

    function _applyIncomingExtensions(message) {
        for (var i = 0; i < _extensions.length; ++i) {
            if (message === undefined || message === null) {
                break;
            }

            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
            var extension = _extensions[index];
            var callback = extension.extension.incoming;
            if (_isFunction(callback)) {
                var result = _applyExtension(extension.extension, callback, extension.name, message, false);
                message = result === undefined ? message : result;
            }
        }
        return message;
    }

    function _applyOutgoingExtensions(message) {
        for (var i = 0; i < _extensions.length; ++i) {
            if (message === undefined || message === null) {
                break;
            }

            var extension = _extensions[i];
            var callback = extension.extension.outgoing;
            if (_isFunction(callback)) {
                var result = _applyExtension(extension.extension, callback, extension.name, message, true);
                message = result === undefined ? message : result;
            }
        }
        return message;
    }

    function _notify(channel, message) {
        var subscriptions = _listeners[channel];
        if (subscriptions && subscriptions.length > 0) {
            for (var i = 0; i < subscriptions.length; ++i) {
                var subscription = subscriptions[i];
                // Subscriptions may come and go, so the array may have 'holes'
                if (subscription) {
                    try {
                        subscription.callback.call(subscription.scope, message);
                    } catch (x) {
                        var handler = _cometd.onListenerException;
                        if (_isFunction(handler)) {
                            _cometd._debug('Invoking listener exception handler', subscription, x);
                            try {
                                handler.call(_cometd, x, subscription, subscription.listener, message);
                            } catch (xx) {
                                _cometd._info('Exception during execution of listener exception handler', subscription, xx);
                            }
                        } else {
                            _cometd._info('Exception during execution of listener', subscription, message, x);
                        }
                    }
                }
            }
        }
    }

    function _notifyListeners(channel, message) {
        // Notify direct listeners
        _notify(channel, message);

        // Notify the globbing listeners
        var channelParts = channel.split('/');
        var last = channelParts.length - 1;
        for (var i = last; i > 0; --i) {
            var channelPart = channelParts.slice(0, i).join('/') + '/*';
            // We don't want to notify /foo/* if the channel is /foo/bar/baz,
            // so we stop at the first non recursive globbing
            if (i === last) {
                _notify(channelPart, message);
            }
            // Add the recursive globber and notify
            channelPart += '*';
            _notify(channelPart, message);
        }
    }

    function _cancelDelayedSend() {
        if (_scheduledSend !== null) {
            Utils.clearTimeout(_scheduledSend);
        }
        _scheduledSend = null;
    }

    function _delayedSend(operation, delay) {
        if ('undefined' === typeof delay) {
          delay = _backoff;
        }
        _cancelDelayedSend();
        var time = _advice.interval + delay;
        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
        _scheduledSend = Utils.setTimeout(_cometd, operation, time);
    }

    // Needed to break cyclic dependencies between function definitions
    var _handleMessages;
    var _handleFailure;

    /**
     * Delivers the messages to the CometD server
     * @param sync whether the send is synchronous
     * @param messages the array of messages to send
     * @param metaConnect true if this send is on /meta/connect
     * @param extraPath an extra path to append to the Bayeux server URL
     */
    function _send(sync, messages, metaConnect, extraPath) {
        // We must be sure that the messages have a clientId.
        // This is not guaranteed since the handshake may take time to return
        // (and hence the clientId is not known yet) and the application
        // may create other messages.
        for (var i = 0; i < messages.length; ++i) {
            var message = messages[i];
            var messageId = message.id;

            if (_clientId) {
                message.clientId = _clientId;
            }

            message = _applyOutgoingExtensions(message);
            if (message !== undefined && message !== null) {
                // Extensions may have modified the message id, but we need to own it.
                message.id = messageId;
                messages[i] = message;
            } else {
                delete _callbacks[messageId];
                messages.splice(i--, 1);
            }
        }

        if (messages.length === 0) {
            return;
        }

        var url = _cometd.getURL();
        if (_config.appendMessageTypeToURL) {
            // If url does not end with '/', then append it
            if (!url.match(/\/$/)) {
                url = url + '/';
            }
            if (extraPath) {
                url = url + extraPath;
            }
        }

        var envelope = {
            url: url,
            sync: sync,
            messages: messages,
            onSuccess: function(rcvdMessages) {
                try {
                    _handleMessages.call(_cometd, rcvdMessages);
                } catch (x) {
                    _cometd._info('Exception during handling of messages', x);
                }
            },
            onFailure: function(conduit, messages, failure) {
                try {
                    var transport = _cometd.getTransport();
                    failure.connectionType = transport ? transport.getType() : "unknown";
                    _handleFailure.call(_cometd, conduit, messages, failure);
                } catch (x) {
                    _cometd._info('Exception during handling of failure', x);
                }
            }
        };
        _cometd._debug('Send', envelope);
        _transport.send(envelope, metaConnect);
    }

    function _queueSend(message) {
        if (_batch > 0 || _internalBatch === true) {
            _messageQueue.push(message);
        } else {
            _send(false, [message], false);
        }
    }

    /**
     * Sends a complete bayeux message.
     * This method is exposed as a public so that extensions may use it
     * to send bayeux message directly, for example in case of re-sending
     * messages that have already been sent but that for some reason must
     * be resent.
     */
    this.send = _queueSend;

    function _resetBackoff() {
        _backoff = 0;
    }

    function _increaseBackoff() {
        if (_backoff < _config.maxBackoff) {
            _backoff += _config.backoffIncrement;
        }
        return _backoff;
    }

    /**
     * Starts a the batch of messages to be sent in a single request.
     * @see #_endBatch(sendMessages)
     */
    function _startBatch() {
        ++_batch;
        _cometd._debug('Starting batch, depth', _batch);
    }

    function _flushBatch() {
        var messages = _messageQueue;
        _messageQueue = [];
        if (messages.length > 0) {
            _send(false, messages, false);
        }
    }

    /**
     * Ends the batch of messages to be sent in a single request,
     * optionally sending messages present in the message queue depending
     * on the given argument.
     * @see #_startBatch()
     */
    function _endBatch() {
        --_batch;
        _cometd._debug('Ending batch, depth', _batch);
        if (_batch < 0) {
            throw 'Calls to startBatch() and endBatch() are not paired';
        }

        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
            _flushBatch();
        }
    }

    /**
     * Sends the connect message
     */
    function _connect() {
        if (!_isDisconnected()) {
            var bayeuxMessage = {
                id: _nextMessageId(),
                channel: '/meta/connect',
                connectionType: _transport.getType()
            };

            // In case of reload or temporary loss of connection
            // we want the next successful connect to return immediately
            // instead of being held by the server, so that connect listeners
            // can be notified that the connection has been re-established
            if (!_connected) {
                bayeuxMessage.advice = { timeout: 0 };
            }

            _setStatus('connecting');
            _cometd._debug('Connect sent', bayeuxMessage);
            _send(false, [bayeuxMessage], true, 'connect');
            _setStatus('connected');
        }
    }

    function _delayedConnect(delay) {
        _setStatus('connecting');
        _delayedSend(function() {
            _connect();
        }, delay);
    }

    function _updateAdvice(newAdvice) {
        if (newAdvice) {
            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
            _cometd._debug('New advice', _advice);
        }
    }

    function _disconnect(abort) {
        _cancelDelayedSend();
        if (abort && _transport) {
            _transport.abort();
        }
        _clientId = null;
        _setStatus('disconnected');
        _batch = 0;
        _resetBackoff();
        _transport = null;

        // Fail any existing queued message
        if (_messageQueue.length > 0) {
            var messages = _messageQueue;
            _messageQueue = [];
            _handleFailure.call(_cometd, undefined, messages, {
                reason: 'Disconnected'
            });
        }
    }

    function _notifyTransportFailure(oldTransport, newTransport, failure) {
        var handler = _cometd.onTransportException;
        if (_isFunction(handler)) {
            _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);
            try {
                handler.call(_cometd, failure, oldTransport, newTransport);
            } catch (x) {
                _cometd._info('Exception during execution of transport exception handler', x);
            }
        }
    }

    /**
     * Sends the initial handshake message
     */
    function _handshake(handshakeProps, handshakeCallback) {
        if (_isFunction(handshakeProps)) {
            handshakeCallback = handshakeProps;
            handshakeProps = undefined;
        }

        _clientId = null;

        _clearSubscriptions();

        // Reset the transports if we're not retrying the handshake
        if (_isDisconnected()) {
            _transports.reset(true);
            _updateAdvice(_config.advice);
        } else {
            // We are retrying the handshake, either because another handshake failed
            // and we're backing off, or because the server timed us out and asks us to
            // re-handshake: in both cases, make sure that if the handshake succeeds
            // the next action is a connect.
            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));
        }

        _batch = 0;

        // Mark the start of an internal batch.
        // This is needed because handshake and connect are async.
        // It may happen that the application calls init() then subscribe()
        // and the subscribe message is sent before the connect message, if
        // the subscribe message is not held until the connect message is sent.
        // So here we start a batch to hold temporarily any message until
        // the connection is fully established.
        _internalBatch = true;

        // Save the properties provided by the user, so that
        // we can reuse them during automatic re-handshake
        _handshakeProps = handshakeProps;
        _handshakeCallback = handshakeCallback;

        var version = '1.0';

        // Figure out the transports to send to the server
        var url = _cometd.getURL();
        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);

        var bayeuxMessage = {
            id: _nextMessageId(),
            version: version,
            minimumVersion: version,
            channel: '/meta/handshake',
            supportedConnectionTypes: transportTypes,
            advice: {
                timeout: _advice.timeout,
                interval: _advice.interval
            }
        };
        // Do not allow the user to override important fields.
        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);

        // Save the callback.
        _cometd._putCallback(message.id, handshakeCallback);

        // Pick up the first available transport as initial transport
        // since we don't know if the server supports it
        if (!_transport) {
            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
            if (!_transport) {
                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
                _cometd._warn(failure);
                throw failure;
            }
        }

        _cometd._debug('Initial transport is', _transport.getType());

        // We started a batch to hold the application messages,
        // so here we must bypass it and send immediately.
        _setStatus('handshaking');
        _cometd._debug('Handshake sent', message);
        _send(false, [message], false, 'handshake');
    }

    function _delayedHandshake(delay) {
        _setStatus('handshaking');

        // We will call _handshake() which will reset _clientId, but we want to avoid
        // that between the end of this method and the call to _handshake() someone may
        // call publish() (or other methods that call _queueSend()).
        _internalBatch = true;

        _delayedSend(function() {
            _handshake(_handshakeProps, _handshakeCallback);
        }, delay);
    }

    function _notifyCallback(callback, message) {
        try {
            callback.call(_cometd, message);
        } catch (x) {
            var handler = _cometd.onCallbackException;
            if (_isFunction(handler)) {
                _cometd._debug('Invoking callback exception handler', x);
                try {
                    handler.call(_cometd, x, message);
                } catch (xx) {
                    _cometd._info('Exception during execution of callback exception handler', xx);
                }
            } else {
                _cometd._info('Exception during execution of message callback', x);
            }
        }
    }

    this._getCallback = function(messageId) {
        return _callbacks[messageId];
    };

    this._putCallback = function(messageId, callback) {
        var result = this._getCallback(messageId);
        if (_isFunction(callback)) {
            _callbacks[messageId] = callback;
        }
        return result;
    };

    function _handleCallback(message) {
        var callback = _cometd._getCallback([message.id]);
        if (_isFunction(callback)) {
            delete _callbacks[message.id];
            _notifyCallback(callback, message);
        }
    }

    function _handleRemoteCall(message) {
        var context = _remoteCalls[message.id];
        delete _remoteCalls[message.id];
        _cometd._debug('Handling remote call response for', message, 'with context', context);
        if (context) {
            // Clear the timeout, if present.
            var timeout = context.timeout;
            if (timeout) {
                Utils.clearTimeout(timeout);
            }

            var callback = context.callback;
            if (_isFunction(callback)) {
                _notifyCallback(callback, message);
                return true;
            }
        }
        return false;
    }

    function _failHandshake(message) {
        _handleCallback(message);
        _notifyListeners('/meta/handshake', message);
        _notifyListeners('/meta/unsuccessful', message);

        // Only try again if we haven't been disconnected and
        // the advice permits us to retry the handshake
        var retry = !_isDisconnected() && _advice.reconnect !== 'none';
        if (retry) {
            _increaseBackoff();
            _delayedHandshake();
        } else {
            _disconnect(true);
        }
    }

    function _handshakeResponse(message) {
        if (message.successful) {
            // Save clientId, figure out transport, then follow the advice to connect
            _clientId = message.clientId;

            var url = _cometd.getURL();
            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
            if (newTransport === null) {
                var failure = 'Could not negotiate transport with server; client=[' +
                    _transports.findTransportTypes(message.version, _crossDomain, url) +
                    '], server=[' + message.supportedConnectionTypes + ']';
                var oldTransport = _cometd.getTransport();
                _notifyTransportFailure(oldTransport.getType(), null, {
                    reason: failure,
                    connectionType: oldTransport.getType(),
                    transport: oldTransport
                });
                _cometd._warn(failure);
                _disconnect(true);
                return;
            } else if (_transport !== newTransport) {
                _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
                _transport = newTransport;
            }

            // End the internal batch and allow held messages from the application
            // to go to the server (see _handshake() where we start the internal batch).
            _internalBatch = false;
            _flushBatch();

            // Here the new transport is in place, as well as the clientId, so
            // the listeners can perform a publish() if they want.
            // Notify the listeners before the connect below.
            message.reestablish = _reestablish;
            _reestablish = true;

            _handleCallback(message);
            _notifyListeners('/meta/handshake', message);

            var action = _isDisconnected() ? 'none' : _advice.reconnect;
            switch (action) {
                case 'retry':
                    _resetBackoff();
                    _delayedConnect();
                    break;
                case 'none':
                    _disconnect(true);
                    break;
                default:
                    throw 'Unrecognized advice action ' + action;
            }
        } else {
            _failHandshake(message);
        }
    }

    function _handshakeFailure(message) {
        var version = '1.0';
        var url = _cometd.getURL();
        var oldTransport = _cometd.getTransport();
        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
        var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
        if (!newTransport) {
            _notifyTransportFailure(oldTransport.getType(), null, message.failure);
            _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
            _disconnect(true);
            _failHandshake(message);
        } else {
            _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());
            _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
            _failHandshake(message);
            _transport = newTransport;
        }
    }

    function _failConnect(message) {
        // Notify the listeners after the status change but before the next action
        _notifyListeners('/meta/connect', message);
        _notifyListeners('/meta/unsuccessful', message);

        // This may happen when the server crashed, the current clientId
        // will be invalid, and the server will ask to handshake again
        // Listeners can call disconnect(), so check the state after they run
        var action = _isDisconnected() ? 'none' : _advice.reconnect;
        switch (action) {
            case 'retry':
                _delayedConnect();
                _increaseBackoff();
                break;
            case 'handshake':
                // The current transport may be failed (e.g. network disconnection)
                // Reset the transports so the new handshake picks up the right one
                _transports.reset(true);
                _resetBackoff();
                _delayedHandshake();
                break;
            case 'none':
                _disconnect(true);
                break;
            default:
                throw 'Unrecognized advice action' + action;
        }
    }

    function _connectResponse(message) {
        _connected = message.successful;

        if (_connected) {
            _notifyListeners('/meta/connect', message);

            // Normally, the advice will say "reconnect: 'retry', interval: 0"
            // and the server will hold the request, so when a response returns
            // we immediately call the server again (long polling)
            // Listeners can call disconnect(), so check the state after they run
            var action = _isDisconnected() ? 'none' : _advice.reconnect;
            switch (action) {
                case 'retry':
                    _resetBackoff();
                    _delayedConnect();
                    break;
                case 'none':
                    // Wait for the /meta/disconnect to arrive.
                    _disconnect(false);
                    break;
                default:
                    throw 'Unrecognized advice action ' + action;
            }
        } else {
            _failConnect(message);
        }
    }

    function _connectFailure(message) {
        _connected = false;
        _failConnect(message);
    }

    function _failDisconnect(message) {
        _disconnect(true);
        _handleCallback(message);
        _notifyListeners('/meta/disconnect', message);
        _notifyListeners('/meta/unsuccessful', message);
    }

    function _disconnectResponse(message) {
        if (message.successful) {
            // Wait for the /meta/connect to arrive.
            _disconnect(false);
            _handleCallback(message);
            _notifyListeners('/meta/disconnect', message);
        } else {
            _failDisconnect(message);
        }
    }

    function _disconnectFailure(message) {
        _failDisconnect(message);
    }

    function _failSubscribe(message) {
        var subscriptions = _listeners[message.subscription];
        if (subscriptions) {
            for (var i = subscriptions.length - 1; i >= 0; --i) {
                var subscription = subscriptions[i];
                if (subscription && !subscription.listener) {
                    delete subscriptions[i];
                    _cometd._debug('Removed failed subscription', subscription);
                    break;
                }
            }
        }
        _handleCallback(message);
        _notifyListeners('/meta/subscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
    }

    function _subscribeResponse(message) {
        if (message.successful) {
            _handleCallback(message);
            _notifyListeners('/meta/subscribe', message);
        } else {
            _failSubscribe(message);
        }
    }

    function _subscribeFailure(message) {
        _failSubscribe(message);
    }

    function _failUnsubscribe(message) {
        _handleCallback(message);
        _notifyListeners('/meta/unsubscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
    }

    function _unsubscribeResponse(message) {
        if (message.successful) {
            _handleCallback(message);
            _notifyListeners('/meta/unsubscribe', message);
        } else {
            _failUnsubscribe(message);
        }
    }

    function _unsubscribeFailure(message) {
        _failUnsubscribe(message);
    }

    function _failMessage(message) {
        if (!_handleRemoteCall(message)) {
            _handleCallback(message);
            _notifyListeners('/meta/publish', message);
            _notifyListeners('/meta/unsuccessful', message);
        }
    }

    function _messageResponse(message) {
        if (message.data !== undefined) {
            if (!_handleRemoteCall(message)) {
                _notifyListeners(message.channel, message);
                if (_handshakeMessages > 0) {
                    --_handshakeMessages;
                    if (_handshakeMessages === 0) {
                        _cometd._debug('Processed last handshake-delivered message');
                        _delayedConnect(0);
                    }
                }
            }
        } else {
            if (message.successful === undefined) {
                _cometd._warn('Unknown Bayeux Message', message);
            } else {
                if (message.successful) {
                    _handleCallback(message);
                    _notifyListeners('/meta/publish', message);
                } else {
                    _failMessage(message);
                }
            }
        }
    }

    function _messageFailure(failure) {
        _failMessage(failure);
    }

    function _receive(message) {
        message = _applyIncomingExtensions(message);
        if (message === undefined || message === null) {
            return;
        }

        _updateAdvice(message.advice);

        var channel = message.channel;
        switch (channel) {
            case '/meta/handshake':
                _handshakeResponse(message);
                break;
            case '/meta/connect':
                _connectResponse(message);
                break;
            case '/meta/disconnect':
                _disconnectResponse(message);
                break;
            case '/meta/subscribe':
                _subscribeResponse(message);
                break;
            case '/meta/unsubscribe':
                _unsubscribeResponse(message);
                break;
            default:
                _messageResponse(message);
                break;
        }
    }

    /**
     * Receives a message.
     * This method is exposed as a public so that extensions may inject
     * messages simulating that they had been received.
     */
    this.receive = _receive;

    _handleMessages = function(rcvdMessages) {
        _cometd._debug('Received', rcvdMessages);

        for (var i = 0; i < rcvdMessages.length; ++i) {
            var message = rcvdMessages[i];
            _receive(message);
        }
    };

    _handleFailure = function(conduit, messages, failure) {
        _cometd._debug('handleFailure', conduit, messages, failure);

        failure.transport = conduit;
        for (var i = 0; i < messages.length; ++i) {
            var message = messages[i];
            var failureMessage = {
                id: message.id,
                successful: false,
                channel: message.channel,
                failure: failure
            };
            failure.message = message;
            switch (message.channel) {
                case '/meta/handshake':
                    _handshakeFailure(failureMessage);
                    break;
                case '/meta/connect':
                    _connectFailure(failureMessage);
                    break;
                case '/meta/disconnect':
                    _disconnectFailure(failureMessage);
                    break;
                case '/meta/subscribe':
                    failureMessage.subscription = message.subscription;
                    _subscribeFailure(failureMessage);
                    break;
                case '/meta/unsubscribe':
                    failureMessage.subscription = message.subscription;
                    _unsubscribeFailure(failureMessage);
                    break;
                default:
                    _messageFailure(failureMessage);
                    break;
            }
        }
    };

    function _hasSubscriptions(channel) {
        var subscriptions = _listeners[channel];
        if (subscriptions) {
            for (var i = 0; i < subscriptions.length; ++i) {
                if (subscriptions[i]) {
                    return true;
                }
            }
        }
        return false;
    }

    function _resolveScopedCallback(scope, callback) {
        var delegate = {
            scope: scope,
            method: callback
        };
        if (_isFunction(scope)) {
            delegate.scope = undefined;
            delegate.method = scope;
        } else {
            if (_isString(callback)) {
                if (!scope) {
                    throw 'Invalid scope ' + scope;
                }
                delegate.method = scope[callback];
                if (!_isFunction(delegate.method)) {
                    throw 'Invalid callback ' + callback + ' for scope ' + scope;
                }
            } else if (!_isFunction(callback)) {
                throw 'Invalid callback ' + callback;
            }
        }
        return delegate;
    }

    function _addListener(channel, scope, callback, isListener) {
        // The data structure is a map<channel, subscription[]>, where each subscription
        // holds the callback to be called and its scope.

        var delegate = _resolveScopedCallback(scope, callback);
        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);

        var subscription = {
            channel: channel,
            scope: delegate.scope,
            callback: delegate.method,
            listener: isListener
        };

        var subscriptions = _listeners[channel];
        if (!subscriptions) {
            subscriptions = [];
            _listeners[channel] = subscriptions;
        }

        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.
        // Note that if:
        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');
        // then:
        // hc==3, a.join()=='a',,'c', a.length==3
        subscription.id = subscriptions.push(subscription) - 1;

        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);

        // For backward compatibility: we used to return [channel, subscription.id]
        subscription[0] = channel;
        subscription[1] = subscription.id;

        return subscription;
    }

    //
    // PUBLIC API
    //

    /**
     * Registers the given transport under the given transport type.
     * The optional index parameter specifies the "priority" at which the
     * transport is registered (where 0 is the max priority).
     * If a transport with the same type is already registered, this function
     * does nothing and returns false.
     * @param type the transport type
     * @param transport the transport object
     * @param index the index at which this transport is to be registered
     * @return true if the transport has been registered, false otherwise
     * @see #unregisterTransport(type)
     */
    this.registerTransport = function(type, transport, index) {
        var result = _transports.add(type, transport, index);
        if (result) {
            this._debug('Registered transport', type);

            if (_isFunction(transport.registered)) {
                transport.registered(type, this);
            }
        }
        return result;
    };

    /**
     * Unregisters the transport with the given transport type.
     * @param type the transport type to unregister
     * @return the transport that has been unregistered,
     * or null if no transport was previously registered under the given transport type
     */
    this.unregisterTransport = function(type) {
        var transport = _transports.remove(type);
        if (transport !== null) {
            this._debug('Unregistered transport', type);

            if (_isFunction(transport.unregistered)) {
                transport.unregistered();
            }
        }
        return transport;
    };

    this.unregisterTransports = function() {
        _transports.clear();
    };

    /**
     * @return an array of all registered transport types
     */
    this.getTransportTypes = function() {
        return _transports.getTransportTypes();
    };

    this.findTransport = function(name) {
        return _transports.find(name);
    };

    /**
     * @returns the TransportRegistry object
     */
    this.getTransportRegistry = function() {
        return _transports;
    };

    /**
     * Configures the initial Bayeux communication with the Bayeux server.
     * Configuration is passed via an object that must contain a mandatory field <code>url</code>
     * of type string containing the URL of the Bayeux server.
     * @param configuration the configuration object
     */
    this.configure = function(configuration) {
        _configure.call(this, configuration);
    };

    /**
     * Configures and establishes the Bayeux communication with the Bayeux server
     * via a handshake and a subsequent connect.
     * @param configuration the configuration object
     * @param handshakeProps an object to be merged with the handshake message
     * @see #configure(configuration)
     * @see #handshake(handshakeProps)
     */
    this.init = function(configuration, handshakeProps) {
        this.configure(configuration);
        this.handshake(handshakeProps);
    };

    /**
     * Establishes the Bayeux communication with the Bayeux server
     * via a handshake and a subsequent connect.
     * @param handshakeProps an object to be merged with the handshake message
     * @param handshakeCallback a function to be invoked when the handshake is acknowledged
     */
    this.handshake = function(handshakeProps, handshakeCallback) {
        _setStatus('disconnected');
        _reestablish = false;
        _handshake(handshakeProps, handshakeCallback);
    };

    /**
     * Disconnects from the Bayeux server.
     * It is possible to suggest to attempt a synchronous disconnect, but this feature
     * may only be available in certain transports (for example, long-polling may support
     * it, callback-polling certainly does not).
     * @param sync whether attempt to perform a synchronous disconnect
     * @param disconnectProps an object to be merged with the disconnect message
     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged
     */
    this.disconnect = function(sync, disconnectProps, disconnectCallback) {
        if (_isDisconnected()) {
            return;
        }

        if (typeof sync !== 'boolean') {
            disconnectCallback = disconnectProps;
            disconnectProps = sync;
            sync = false;
        }
        if (_isFunction(disconnectProps)) {
            disconnectCallback = disconnectProps;
            disconnectProps = undefined;
        }

        var bayeuxMessage = {
            id: _nextMessageId(),
            channel: '/meta/disconnect'
        };
        // Do not allow the user to override important fields.
        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);

        // Save the callback.
        _cometd._putCallback(message.id, disconnectCallback);

        _setStatus('disconnecting');
        _send(sync === true, [message], false, 'disconnect');
    };

    /**
     * Marks the start of a batch of application messages to be sent to the server
     * in a single request, obtaining a single response containing (possibly) many
     * application reply messages.
     * Messages are held in a queue and not sent until {@link #endBatch()} is called.
     * If startBatch() is called multiple times, then an equal number of endBatch()
     * calls must be made to close and send the batch of messages.
     * @see #endBatch()
     */
    this.startBatch = function() {
        _startBatch();
    };

    /**
     * Marks the end of a batch of application messages to be sent to the server
     * in a single request.
     * @see #startBatch()
     */
    this.endBatch = function() {
        _endBatch();
    };

    /**
     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}
     * and {@link #endBatch()} calls.
     * @param scope the scope of the callback, may be omitted
     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls
     */
    this.batch = function(scope, callback) {
        var delegate = _resolveScopedCallback(scope, callback);
        this.startBatch();
        try {
            delegate.method.call(delegate.scope);
            this.endBatch();
        } catch (x) {
            this._info('Exception during execution of batch', x);
            this.endBatch();
            throw x;
        }
    };

    /**
     * Adds a listener for bayeux messages, performing the given callback in the given scope
     * when a message for the given channel arrives.
     * @param channel the channel the listener is interested to
     * @param scope the scope of the callback, may be omitted
     * @param callback the callback to call when a message is sent to the channel
     * @returns the subscription handle to be passed to {@link #removeListener(object)}
     * @see #removeListener(subscription)
     */
    this.addListener = function(channel, scope, callback) {
        if (arguments.length < 2) {
            throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel)) {
            throw 'Illegal argument type: channel must be a string';
        }

        return _addListener(channel, scope, callback, true);
    };

    /**
     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.
     * @param subscription the subscription to unsubscribe.
     * @see #addListener(channel, scope, callback)
     */
    this.removeListener = function(subscription) {
        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id
        if (!subscription || !subscription.channel || !("id" in subscription)) {
            throw 'Invalid argument: expected subscription, not ' + subscription;
        }

        _removeListener(subscription);
    };

    /**
     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or
     * {@link #subscribe(channel, scope, callback)}.
     */
    this.clearListeners = function() {
        _listeners = {};
    };

    /**
     * Subscribes to the given channel, performing the given callback in the given scope
     * when a message for the channel arrives.
     * @param channel the channel to subscribe to
     * @param scope the scope of the callback, may be omitted
     * @param callback the callback to call when a message is sent to the channel
     * @param subscribeProps an object to be merged with the subscribe message
     * @param subscribeCallback a function to be invoked when the subscription is acknowledged
     * @return the subscription handle to be passed to {@link #unsubscribe(object)}
     */
    this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
        if (arguments.length < 2) {
            throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel)) {
            throw 'Illegal argument type: channel must be a string';
        }
        if (_isDisconnected()) {
            throw 'Illegal state: already disconnected';
        }

        // Normalize arguments
        if (_isFunction(scope)) {
            subscribeCallback = subscribeProps;
            subscribeProps = callback;
            callback = scope;
            scope = undefined;
        }
        if (_isFunction(subscribeProps)) {
            subscribeCallback = subscribeProps;
            subscribeProps = undefined;
        }

        // Only send the message to the server if this client has not yet subscribed to the channel
        var send = !_hasSubscriptions(channel);

        var subscription = _addListener(channel, scope, callback, false);

        if (send) {
            // Send the subscription message after the subscription registration to avoid
            // races where the server would send a message to the subscribers, but here
            // on the client the subscription has not been added yet to the data structures
            var bayeuxMessage = {
                id: _nextMessageId(),
                channel: '/meta/subscribe',
                subscription: channel
            };
            // Do not allow the user to override important fields.
            var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);

            // Save the callback.
            _cometd._putCallback(message.id, subscribeCallback);

            _queueSend(message);
        }

        return subscription;
    };

    /**
     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.
     * @param subscription the subscription to unsubscribe.
     * @param unsubscribeProps an object to be merged with the unsubscribe message
     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged
     */
    this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
        if (arguments.length < 1) {
            throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (_isDisconnected()) {
            throw 'Illegal state: already disconnected';
        }

        if (_isFunction(unsubscribeProps)) {
            unsubscribeCallback = unsubscribeProps;
            unsubscribeProps = undefined;
        }

        // Remove the local listener before sending the message
        // This ensures that if the server fails, this client does not get notifications
        this.removeListener(subscription);

        var channel = subscription.channel;
        // Only send the message to the server if this client unsubscribes the last subscription
        if (!_hasSubscriptions(channel)) {
            var bayeuxMessage = {
                id: _nextMessageId(),
                channel: '/meta/unsubscribe',
                subscription: channel
            };
            // Do not allow the user to override important fields.
            var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);

            // Save the callback.
            _cometd._putCallback(message.id, unsubscribeCallback);

            _queueSend(message);
        }
    };

    this.resubscribe = function(subscription, subscribeProps) {
        _removeSubscription(subscription);
        if (subscription) {
            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
        }
        return undefined;
    };

    /**
     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},
     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.
     */
    this.clearSubscriptions = function() {
        _clearSubscriptions();
    };

    /**
     * Publishes a message on the given channel, containing the given content.
     * @param channel the channel to publish the message to
     * @param content the content of the message
     * @param publishProps an object to be merged with the publish message
     * @param publishCallback a function to be invoked when the publish is acknowledged by the server
     */
    this.publish = function(channel, content, publishProps, publishCallback) {
        if (arguments.length < 1) {
            throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (!_isString(channel)) {
            throw 'Illegal argument type: channel must be a string';
        }
        if (/^\/meta\//.test(channel)) {
            throw 'Illegal argument: cannot publish to meta channels';
        }
        if (_isDisconnected()) {
            throw 'Illegal state: already disconnected';
        }

        if (_isFunction(content)) {
            publishCallback = content;
            content = publishProps = {};
        } else if (_isFunction(publishProps)) {
            publishCallback = publishProps;
            publishProps = {};
        }

        var bayeuxMessage = {
            id: _nextMessageId(),
            channel: channel,
            data: content
        };
        // Do not allow the user to override important fields.
        var message = this._mixin(false, {}, publishProps, bayeuxMessage);

        // Save the callback.
        _cometd._putCallback(message.id, publishCallback);

        _queueSend(message);
    };

    this.remoteCall = function(target, content, timeout, callback) {
        if (arguments.length < 1) {
            throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (!_isString(target)) {
            throw 'Illegal argument type: target must be a string';
        }
        if (_isDisconnected()) {
            throw 'Illegal state: already disconnected';
        }

        if (_isFunction(content)) {
            callback = content;
            content = {};
            timeout = _config.maxNetworkDelay;
        } else if (_isFunction(timeout)) {
            callback = timeout;
            timeout = _config.maxNetworkDelay;
        }

        if (typeof timeout !== 'number') {
            throw 'Illegal argument type: timeout must be a number';
        }

        if (!target.match(/^\//)) {
            target = '/' + target;
        }
        var channel = '/service' + target;

        var bayeuxMessage = {
            id: _nextMessageId(),
            channel: channel,
            data: content
        };

        var context = {
            callback: callback
        };
        if (timeout > 0) {
            context.timeout = Utils.setTimeout(_cometd, function() {
                _cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');
                _failMessage({
                    id: bayeuxMessage.id,
                    error: '406::timeout',
                    successful: false,
                    failure: {
                        message : bayeuxMessage,
                        reason: 'Remote Call Timeout'
                    }
                });
            }, timeout);
            _cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');
        }
        _remoteCalls[bayeuxMessage.id] = context;

        _queueSend(bayeuxMessage);
    };

    /**
     * Returns a string representing the status of the bayeux communication with the Bayeux server.
     */
    this.getStatus = function() {
        return _status;
    };

    /**
     * Returns whether this instance has been disconnected.
     */
    this.isDisconnected = _isDisconnected;

    /**
     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
     * Default value is 1 second, which means if there is a persistent failure the retries will happen
     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of
     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).
     * @param period the backoff period to set
     * @see #getBackoffIncrement()
     */
    this.setBackoffIncrement = function(period) {
        _config.backoffIncrement = period;
    };

    /**
     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
     * @see #setBackoffIncrement(period)
     */
    this.getBackoffIncrement = function() {
        return _config.backoffIncrement;
    };

    /**
     * Returns the backoff period to wait before retrying an unsuccessful or failed message.
     */
    this.getBackoffPeriod = function() {
        return _backoff;
    };

    /**
     * Increases the backoff period up to the maximum value configured.
     * @returns the backoff period after increment
     * @see getBackoffIncrement
     */
    this.increaseBackoffPeriod = function() {
        return _increaseBackoff();
    };

    /**
     * Resets the backoff period to zero.
     */
    this.resetBackoffPeriod = function() {
        _resetBackoff();
    };

    /**
     * Sets the log level for console logging.
     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
     * less verbose to more verbose.
     * @param level the log level string
     */
    this.setLogLevel = function(level) {
        _config.logLevel = level;
    };

    /**
     * Registers an extension whose callbacks are called for every incoming message
     * (that comes from the server to this client implementation) and for every
     * outgoing message (that originates from this client implementation for the
     * server).
     * The format of the extension object is the following:
     * <pre>
     * {
     *     incoming: function(message) { ... },
     *     outgoing: function(message) { ... }
     * }
     * </pre>
     * Both properties are optional, but if they are present they will be called
     * respectively for each incoming message and for each outgoing message.
     * @param name the name of the extension
     * @param extension the extension to register
     * @return true if the extension was registered, false otherwise
     * @see #unregisterExtension(name)
     */
    this.registerExtension = function(name, extension) {
        if (arguments.length < 2) {
            throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(name)) {
            throw 'Illegal argument type: extension name must be a string';
        }

        var existing = false;
        for (var i = 0; i < _extensions.length; ++i) {
            var existingExtension = _extensions[i];
            if (existingExtension.name === name) {
                existing = true;
                break;
            }
        }
        if (!existing) {
            _extensions.push({
                name: name,
                extension: extension
            });
            this._debug('Registered extension', name);

            // Callback for extensions
            if (_isFunction(extension.registered)) {
                extension.registered(name, this);
            }

            return true;
        } else {
            this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
            return false;
        }
    };

    /**
     * Unregister an extension previously registered with
     * {@link #registerExtension(name, extension)}.
     * @param name the name of the extension to unregister.
     * @return true if the extension was unregistered, false otherwise
     */
    this.unregisterExtension = function(name) {
        if (!_isString(name)) {
            throw 'Illegal argument type: extension name must be a string';
        }

        var unregistered = false;
        for (var i = 0; i < _extensions.length; ++i) {
            var extension = _extensions[i];
            if (extension.name === name) {
                _extensions.splice(i, 1);
                unregistered = true;
                this._debug('Unregistered extension', name);

                // Callback for extensions
                var ext = extension.extension;
                if (_isFunction(ext.unregistered)) {
                    ext.unregistered();
                }

                break;
            }
        }
        return unregistered;
    };

    /**
     * Find the extension registered with the given name.
     * @param name the name of the extension to find
     * @return the extension found or null if no extension with the given name has been registered
     */
    this.getExtension = function(name) {
        for (var i = 0; i < _extensions.length; ++i) {
            var extension = _extensions[i];
            if (extension.name === name) {
                return extension.extension;
            }
        }
        return null;
    };

    /**
     * Returns the name assigned to this CometD object, or the string 'default'
     * if no name has been explicitly passed as parameter to the constructor.
     */
    this.getName = function() {
        return _name;
    };

    /**
     * Returns the clientId assigned by the Bayeux server during handshake.
     */
    this.getClientId = function() {
        return _clientId;
    };

    /**
     * Returns the URL of the Bayeux server.
     */
    this.getURL = function() {
        if (_transport) {
            var url = _transport.getURL();
            if (url) {
                return url;
            }
            url = _config.urls[_transport.getType()];
            if (url) {
                return url;
            }
        }
        return _config.url;
    };

    this.getTransport = function() {
        return _transport;
    };

    this.getConfiguration = function() {
        return this._mixin(true, {}, _config);
    };

    this.getAdvice = function() {
        return this._mixin(true, {}, _advice);
    };
};

var TransportTypes = {
  LONG_POLLING: 'long-polling',
  WEBSOCKET: 'websocket'
};

/**
 * Base object with the common functionality for transports.
 */
var Transport = function Transport() {
    var _type;
    var _cometd;
    var _url;

    /**
     * Function invoked just after a transport has been successfully registered.
     * @param type the type of transport (for example 'long-polling')
     * @param cometd the cometd object this transport has been registered to
     * @see #unregistered()
     */
    this.registered = function(type, cometd) {
        _type = type;
        _cometd = cometd;
    };

    /**
     * Function invoked just after a transport has been successfully unregistered.
     * @see #registered(type, cometd)
     */
    this.unregistered = function() {
        _type = null;
        _cometd = null;
    };

    this._debug = function() {
        _cometd._debug.apply(_cometd, arguments);
    };

    this._mixin = function() {
        return _cometd._mixin.apply(_cometd, arguments);
    };

    this.getConfiguration = function() {
        return _cometd.getConfiguration();
    };

    this.getAdvice = function() {
        return _cometd.getAdvice();
    };

    this.setTimeout = function(funktion, delay) {
        return Utils.setTimeout(_cometd, funktion, delay);
    };

    this.clearTimeout = function(handle) {
        Utils.clearTimeout(handle);
    };

    /**
     * Converts the given response into an array of bayeux messages
     * @param response the response to convert
     * @return an array of bayeux messages obtained by converting the response
     */
    this.convertToMessages = function(response) {
        if (Utils.isString(response)) {
            try {
                return JSON.parse(response);
            } catch (x) {
                this._debug('Could not convert to JSON the following string', '"' + response + '"');
                throw x;
            }
        }
        if (Utils.isArray(response)) {
            return response;
        }
        if (response === undefined || response === null) {
            return [];
        }
        if (response instanceof Object) {
            return [response];
        }
        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
    };

    /**
     * Returns whether this transport can work for the given version and cross domain communication case.
     * @param version a string indicating the transport version
     * @param crossDomain a boolean indicating whether the communication is cross domain
     * @param url the URL to connect to
     * @return true if this transport can work for the given version and cross domain communication case,
     * false otherwise
     */
    this.accept = function(version, crossDomain, url) {
        throw 'Abstract';
    };

    /**
     * Returns the type of this transport.
     * @see #registered(type, cometd)
     */
    this.getType = function() {
        return _type;
    };

    this.getURL = function() {
        return _url;
    };

    this.setURL = function(url) {
        _url = url;
    };

    this.send = function(envelope, metaConnect) {
        throw 'Abstract';
    };

    this.reset = function(init) {
        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');
    };

    this.abort = function() {
        this._debug('Transport', _type, 'aborted');
    };

    this.toString = function() {
        return this.getType();
    };
};

var derive = function(baseObject) {
    function F() {
    }

    F.prototype = baseObject;
    return new F();
};

Transport.derive = derive;

/**
 * Base object with the common functionality for transports based on requests.
 * The key responsibility is to allow at most 2 outstanding requests to the server,
 * to avoid that requests are sent behind a long poll.
 * To achieve this, we have one reserved request for the long poll, and all other
 * requests are serialized one after the other.
 */
var RequestTransport = function RequestTransport() {
    var _super = new Transport();
    var _self = Transport.derive(_super);
    var _requestIds = 0;
    var _metaConnectRequest = null;
    var _requests = [];
    var _envelopes = [];

    function _coalesceEnvelopes(envelope) {
        while (_envelopes.length > 0) {
            var envelopeAndRequest = _envelopes[0];
            var newEnvelope = envelopeAndRequest[0];
            var newRequest = envelopeAndRequest[1];
            if (newEnvelope.url === envelope.url &&
                newEnvelope.sync === envelope.sync) {
                _envelopes.shift();
                envelope.messages = envelope.messages.concat(newEnvelope.messages);
                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
                continue;
            }
            break;
        }
    }

    function _transportSend(envelope, request) {
        this.transportSend(envelope, request);
        request.expired = false;

        if (!envelope.sync) {
            var maxDelay = this.getConfiguration().maxNetworkDelay;
            var delay = maxDelay;
            if (request.metaConnect === true) {
                delay += this.getAdvice().timeout;
            }

            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);

            var self = this;
            request.timeout = self.setTimeout(function() {
                request.expired = true;
                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
                var failure = {
                    reason: errorMessage
                };
                var xhr = request.xhr;
                failure.httpCode = self.xhrStatus(xhr);
                self.abortXHR(xhr);
                self._debug(errorMessage);
                self.complete(request, false, request.metaConnect);
                envelope.onFailure(xhr, envelope.messages, failure);
            }, delay);
        }
    }

    function _queueSend(envelope) {
        var requestId = ++_requestIds;
        var request = {
            id: requestId,
            metaConnect: false,
            envelope: envelope
        };

        // Consider the metaConnect requests which should always be present
        if (_requests.length < this.getConfiguration().maxConnections - 1) {
            _requests.push(request);
            _transportSend.call(this, envelope, request);
        } else {
            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
            _envelopes.push([envelope, request]);
        }
    }

    function _metaConnectComplete(request) {
        var requestId = request.id;
        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
            throw 'Longpoll request mismatch, completing request ' + requestId;
        }

        // Reset metaConnect request
        _metaConnectRequest = null;
    }

    function _complete(request, success) {
        var index = Utils.inArray(request, _requests);
        // The index can be negative if the request has been aborted
        if (index >= 0) {
            _requests.splice(index, 1);
        }

        if (_envelopes.length > 0) {
            var envelopeAndRequest = _envelopes.shift();
            var nextEnvelope = envelopeAndRequest[0];
            var nextRequest = envelopeAndRequest[1];
            this._debug('Transport dequeued request', nextRequest.id);
            if (success) {
                if (this.getConfiguration().autoBatch) {
                    _coalesceEnvelopes.call(this, nextEnvelope);
                }
                _queueSend.call(this, nextEnvelope);
                this._debug('Transport completed request', request.id, nextEnvelope);
            } else {
                // Keep the semantic of calling response callbacks asynchronously after the request
                var self = this;
                self.setTimeout(function() {
                    self.complete(nextRequest, false, nextRequest.metaConnect);
                    var failure = {
                        reason: 'Previous request failed'
                    };
                    var xhr = nextRequest.xhr;
                    failure.httpCode = self.xhrStatus(xhr);
                    nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
                }, 0);
            }
        }
    }

    _self.complete = function(request, success, metaConnect) {
        if (metaConnect) {
            _metaConnectComplete.call(this, request);
        } else {
            _complete.call(this, request, success);
        }
    };

    /**
     * Performs the actual send depending on the transport type details.
     * @param envelope the envelope to send
     * @param request the request information
     */
    _self.transportSend = function(envelope, request) {
        throw 'Abstract';
    };

    _self.transportSuccess = function(envelope, request, responses) {
        if (!request.expired) {
            this.clearTimeout(request.timeout);
            this.complete(request, true, request.metaConnect);
            if (responses && responses.length > 0) {
                envelope.onSuccess(responses);
            } else {
                envelope.onFailure(request.xhr, envelope.messages, {
                    httpCode: 204
                });
            }
        }
    };

    _self.transportFailure = function(envelope, request, failure) {
        if (!request.expired) {
            this.clearTimeout(request.timeout);
            this.complete(request, false, request.metaConnect);
            envelope.onFailure(request.xhr, envelope.messages, failure);
        }
    };

    function _metaConnectSend(envelope) {
        if (_metaConnectRequest !== null) {
            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
        }

        var requestId = ++_requestIds;
        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
        var request = {
            id: requestId,
            metaConnect: true,
            envelope: envelope
        };
        _transportSend.call(this, envelope, request);
        _metaConnectRequest = request;
    }

    _self.send = function(envelope, metaConnect) {
        if (metaConnect) {
            _metaConnectSend.call(this, envelope);
        } else {
            _queueSend.call(this, envelope);
        }
    };

    _self.abort = function() {
        _super.abort();
        for (var i = 0; i < _requests.length; ++i) {
            var request = _requests[i];
            if (request) {
                this._debug('Aborting request', request);
                if (!this.abortXHR(request.xhr)) {
                    this.transportFailure(request.envelope, request, {reason: 'abort'});
                }
            }
        }
        if (_metaConnectRequest) {
            this._debug('Aborting metaConnect request', _metaConnectRequest);
            if (!this.abortXHR(_metaConnectRequest.xhr)) {
                this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});
            }
        }
        this.reset(true);
    };

    _self.reset = function(init) {
        _super.reset(init);
        _metaConnectRequest = null;
        _requests = [];
        _envelopes = [];
    };

    _self.abortXHR = function(xhr) {
        if (xhr) {
            try {
                var state = xhr.readyState;
                xhr.abort();
                return state !== XMLHttpRequest.UNSENT;
            } catch (x) {
                this._debug(x);
            }
        }
        return false;
    };

    _self.xhrStatus = function(xhr) {
        if (xhr) {
            try {
                return xhr.status;
            } catch (x) {
                this._debug(x);
            }
        }
        return -1;
    };

    return _self;
};

var LongPollingTransport = function LongPollingTransport() {
    var _super = new RequestTransport();
    var _self = Transport.derive(_super);
    // By default, support cross domain
    var _supportsCrossDomain = true;

    _self.accept = function(version, crossDomain, url) {
        return _supportsCrossDomain || !crossDomain;
    };

    _self.xhrSend = function(packet) {
        throw 'Abstract';
    };

    _self.transportSend = function(envelope, request) {
        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);

        var self = this;
        try {
            var sameStack = true;
            request.xhr = this.xhrSend({
                transport: this,
                url: envelope.url,
                sync: envelope.sync,
                headers: this.getConfiguration().requestHeaders,
                body: JSON.stringify(envelope.messages),
                onSuccess: function(response) {
                    self._debug('Transport', self.getType(), 'received response', response);
                    var success = false;
                    try {
                        var received = self.convertToMessages(response);
                        if (received.length === 0) {
                            _supportsCrossDomain = false;
                            self.transportFailure(envelope, request, {
                                httpCode: 204
                            });
                        } else {
                            success = true;
                            self.transportSuccess(envelope, request, received);
                        }
                    } catch (x) {
                        self._debug(x);
                        if (!success) {
                            _supportsCrossDomain = false;
                            var failure = {
                                exception: x
                            };
                            failure.httpCode = self.xhrStatus(request.xhr);
                            self.transportFailure(envelope, request, failure);
                        }
                    }
                },
                onError: function(reason, exception) {
                    self._debug('Transport', self.getType(), 'received error', reason, exception);
                    _supportsCrossDomain = false;
                    var failure = {
                        reason: reason,
                        exception: exception
                    };
                    failure.httpCode = self.xhrStatus(request.xhr);
                    if (sameStack) {
                        // Keep the semantic of calling response callbacks asynchronously after the request
                        self.setTimeout(function() {
                            self.transportFailure(envelope, request, failure);
                        }, 0);
                    } else {
                        self.transportFailure(envelope, request, failure);
                    }
                }
            });
            sameStack = false;
        } catch (x) {
            _supportsCrossDomain = false;
            // Keep the semantic of calling response callbacks asynchronously after the request
            self.setTimeout(function() {
                self.transportFailure(envelope, request, {
                    exception: x
                });
            }, 0);
        }
    };

    _self.reset = function(init) {
        _super.reset(init);
        _supportsCrossDomain = true;
    };

    return _self;
};

/**
 * Implements LongPollingTransport using borwser fetch() API
 * @access private
 * @return {FetchLongPollingTransport}
 */
function FetchLongPollingTransport() {
  var _super = new LongPollingTransport();
  var that = Transport.derive(_super);

  /**
   * Implements transport via fetch() API
   * @param {Object} packet
   */
  that.xhrSend = function (packet) {
    FetchLongPollingTransport.fetch(packet.url, {
      method: 'post',
      body: packet.body,
      headers: Object.assign(packet.headers, {
        'Content-Type': 'application/json;charset=UTF-8'
      })
    })
    .then(function (response) {
      return response.json()
    })
    .then(packet.onSuccess)
    .catch(packet.onError);
  };

  return that
}

// Reference global WebSocket 
FetchLongPollingTransport.fetch = 'Abstract';

// Export FetchLongPollingTransport
var FetchLongPollingTransport_1 = FetchLongPollingTransport;

function WebSocketTransport() {
    var _super = new Transport();
    var _self = Transport.derive(_super);
    var _cometd;
    // By default WebSocket is supported
    var _webSocketSupported = true;
    // Whether we were able to establish a WebSocket connection
    var _webSocketConnected = false;
    var _stickyReconnect = true;
    // The context contains the envelopes that have been sent
    // and the timeouts for the messages that have been sent.
    var _context = null;
    var _connecting = null;
    var _connected = false;
    var _successCallback = null;

    _self.reset = function(init) {
        _super.reset(init);
        _webSocketSupported = true;
        if (init) {
            _webSocketConnected = false;
        }
        _stickyReconnect = true;
        _context = null;
        _connecting = null;
        _connected = false;
    };

    function _forceClose(context, event) {
        if (context) {
            this.webSocketClose(context, event.code, event.reason);
            // Force immediate failure of pending messages to trigger reconnect.
            // This is needed because the server may not reply to our close()
            // and therefore the onclose function is never called.
            this.onClose(context, event);
        }
    }

    function _sameContext(context) {
        return context === _connecting || context === _context;
    }

    function _storeEnvelope(context, envelope, metaConnect) {
        var messageIds = [];
        for (var i = 0; i < envelope.messages.length; ++i) {
            var message = envelope.messages[i];
            if (message.id) {
                messageIds.push(message.id);
            }
        }
        context.envelopes[messageIds.join(',')] = [envelope, metaConnect];
        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);
    }

    function _websocketConnect(context) {
        // We may have multiple attempts to open a WebSocket
        // connection, for example a /meta/connect request that
        // may take time, along with a user-triggered publish.
        // Early return if we are already connecting.
        if (_connecting) {
            return;
        }

        // Mangle the URL, changing the scheme from 'http' to 'ws'.
        var url = _cometd.getURL().replace(/^http/, 'ws');
        this._debug('Transport', this.getType(), 'connecting to URL', url);

        try {
            var protocol = _cometd.getConfiguration().protocol;
            var WebSocket = WebSocketTransport.WebSocket;
            context.webSocket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);
            _connecting = context;
        } catch (x) {
            _webSocketSupported = false;
            this._debug('Exception while creating WebSocket object', x);
            throw x;
        }

        // By default use sticky reconnects.
        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;

        var self = this;
        var connectTimeout = _cometd.getConfiguration().connectTimeout;
        if (connectTimeout > 0) {
            context.connectTimer = self.setTimeout(function() {
                _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
                // The connection was not opened, close anyway.
                _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});
            }, connectTimeout);
        }

        var onopen = function() {
            _cometd._debug('WebSocket onopen', context);
            if (context.connectTimer) {
                self.clearTimeout(context.connectTimer);
            }

            if (_sameContext(context)) {
                _connecting = null;
                _context = context;
                _webSocketConnected = true;
                self.onOpen(context);
            } else {
                // We have a valid connection already, close this one.
                _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);
                _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});
            }
        };

        // This callback is invoked when the server sends the close frame.
        // The close frame for a connection may arrive *after* another
        // connection has been opened, so we must make sure that actions
        // are performed only if it's the same connection.
        var onclose = function(event) {
            event = event || {code: 1000};
            _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);

            if (context.connectTimer) {
                self.clearTimeout(context.connectTimer);
            }

            self.onClose(context, event);
        };

        var onmessage = function(wsMessage) {
            _cometd._debug('WebSocket onmessage', wsMessage, context);
            self.onMessage(context, wsMessage);
        };

        context.webSocket.onopen = onopen;
        context.webSocket.onclose = onclose;
        context.webSocket.onerror = function() {
            // Clients should call onclose(), but if they do not we do it here for safety.
            onclose({code: 1000, reason: 'Error'});
        };
        context.webSocket.onmessage = onmessage;

        this._debug('Transport', this.getType(), 'configured callbacks on', context);
    }

    function _webSocketSend(context, envelope, metaConnect) {
        var json = JSON.stringify(envelope.messages);
        context.webSocket.send(json);
        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);

        // Manage the timeout waiting for the response.
        var maxDelay = this.getConfiguration().maxNetworkDelay;
        var delay = maxDelay;
        if (metaConnect) {
            delay += this.getAdvice().timeout;
            _connected = true;
        }

        var self = this;
        var messageIds = [];
        for (var i = 0; i < envelope.messages.length; ++i) {
            (function() {
                var message = envelope.messages[i];
                if (message.id) {
                    messageIds.push(message.id);
                    context.timeouts[message.id] = self.setTimeout(function() {
                        _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);
                        _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});
                    }, delay);
                }
            })();
        }

        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);
    }

    _self._notifySuccess = function(fn, messages) {
        fn.call(this, messages);
    };

    _self._notifyFailure = function(fn, context, messages, failure) {
        fn.call(this, context, messages, failure);
    };

    function _send(context, envelope, metaConnect) {
        try {
            if (context === null) {
                context = _connecting || {
                        envelopes: {},
                        timeouts: {}
                    };
                _storeEnvelope.call(this, context, envelope, metaConnect);
                _websocketConnect.call(this, context);
            } else {
                _storeEnvelope.call(this, context, envelope, metaConnect);
                _webSocketSend.call(this, context, envelope, metaConnect);
            }
        } catch (x) {
            // Keep the semantic of calling response callbacks asynchronously after the request.
            var self = this;
            self.setTimeout(function() {
                _forceClose.call(self, context, {
                    code: 1000,
                    reason: 'Exception',
                    exception: x
                });
            }, 0);
        }
    }

    _self.onOpen = function(context) {
        var envelopes = context.envelopes;
        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);
        for (var key in envelopes) {
            if (envelopes.hasOwnProperty(key)) {
                var element = envelopes[key];
                var envelope = element[0];
                var metaConnect = element[1];
                // Store the success callback, which is independent from the envelope,
                // so that it can be used to notify arrival of messages.
                _successCallback = envelope.onSuccess;
                _webSocketSend.call(this, context, envelope, metaConnect);
            }
        }
    };

    _self.onMessage = function(context, wsMessage) {
        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);

        var close = false;
        var messages = this.convertToMessages(wsMessage.data);
        var messageIds = [];
        for (var i = 0; i < messages.length; ++i) {
            var message = messages[i];

            // Detect if the message is a response to a request we made.
            // If it's a meta message, for sure it's a response; otherwise it's
            // a publish message and publish responses don't have the data field.
            if (/^\/meta\//.test(message.channel) || message.data === undefined) {
                if (message.id) {
                    messageIds.push(message.id);

                    var timeout = context.timeouts[message.id];
                    if (timeout) {
                        this.clearTimeout(timeout);
                        delete context.timeouts[message.id];
                        this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);
                    }
                }
            }

            if ('/meta/connect' === message.channel) {
                _connected = false;
            }
            if ('/meta/disconnect' === message.channel && !_connected) {
                close = true;
            }
        }

        // Remove the envelope corresponding to the messages.
        var removed = false;
        var envelopes = context.envelopes;
        for (var j = 0; j < messageIds.length; ++j) {
            var id = messageIds[j];
            for (var key in envelopes) {
                if (envelopes.hasOwnProperty(key)) {
                    var ids = key.split(',');
                    var index = Utils.inArray(id, ids);
                    if (index >= 0) {
                        removed = true;
                        ids.splice(index, 1);
                        var envelope = envelopes[key][0];
                        var metaConnect = envelopes[key][1];
                        delete envelopes[key];
                        if (ids.length > 0) {
                            envelopes[ids.join(',')] = [envelope, metaConnect];
                        }
                        break;
                    }
                }
            }
        }
        if (removed) {
            this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);
        }

        this._notifySuccess(_successCallback, messages);

        if (close) {
            this.webSocketClose(context, 1000, 'Disconnect');
        }
    };

    _self.onClose = function(context, event) {
        this._debug('Transport', this.getType(), 'closed', context, event);

        if (_sameContext(context)) {
            // Remember if we were able to connect.
            // This close event could be due to server shutdown,
            // and if it restarts we want to try websocket again.
            _webSocketSupported = _stickyReconnect && _webSocketConnected;
            _connecting = null;
            _context = null;
        }

        var timeouts = context.timeouts;
        context.timeouts = {};
        for (var id in timeouts) {
            if (timeouts.hasOwnProperty(id)) {
                this.clearTimeout(timeouts[id]);
            }
        }

        var envelopes = context.envelopes;
        context.envelopes = {};
        for (var key in envelopes) {
            if (envelopes.hasOwnProperty(key)) {
                var envelope = envelopes[key][0];
                var metaConnect = envelopes[key][1];
                if (metaConnect) {
                    _connected = false;
                }
                var failure = {
                    websocketCode: event.code,
                    reason: event.reason
                };
                if (event.exception) {
                    failure.exception = event.exception;
                }
                this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);
            }
        }
    };

    _self.registered = function(type, cometd) {
        _super.registered(type, cometd);
        _cometd = cometd;
    };

    _self.accept = function(version, crossDomain, url) {
        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);
        // Using !! to return a boolean (and not the WebSocket object).
        return _webSocketSupported && !('string' === typeof WebSocketTransport.WebSocket) && _cometd.websocketEnabled !== false;
    };

    _self.send = function(envelope, metaConnect) {
        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
        _send.call(this, _context, envelope, metaConnect);
    };

    _self.webSocketClose = function(context, code, reason) {
        try {
            if (context.webSocket) {
                context.webSocket.close(code, reason);
            }
        } catch (x) {
            this._debug(x);
        }
    };

    _self.abort = function() {
        _super.abort();
        _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});
        this.reset(true);
    };

    return _self;
}

// Reference global WebSocket 
WebSocketTransport.WebSocket = 'Abstract';

// Export WebSocketTransport
var WebSocketTransport_1 = WebSocketTransport;

// Use node-fetch implementation
var fetch_1 = FetchLongPollingTransport_1.fetch = function() {
  return fetch.apply(window, arguments);
};

// Use node-websocket implementation
var WebSocket_1 = WebSocketTransport_1.WebSocket = typeof WebSocket === 'undefined' ? null : WebSocket;

/**
 * Long polling transport layer
 */
var WEBSOCKET_TRANSPORT = {
  type: TransportTypes.WEBSOCKET,
  Transport: WebSocketTransport_1
};
var WEBSOCKET_TRANSPORT_1 = WEBSOCKET_TRANSPORT;

/**
 * Long polling transport layer
 */
var LONG_POLLING_TRANSPORT = {
  type: TransportTypes.LONG_POLLING,
  Transport: FetchLongPollingTransport_1
};
var LONG_POLLING_TRANSPORT_1 = LONG_POLLING_TRANSPORT;

/**
 * CometD Transports Layers map
 */
var ALL = [
  WEBSOCKET_TRANSPORT,
  LONG_POLLING_TRANSPORT
];
var ALL_1 = ALL;

var Transports = {
	fetch: fetch_1,
	WebSocket: WebSocket_1,
	WEBSOCKET_TRANSPORT: WEBSOCKET_TRANSPORT_1,
	LONG_POLLING_TRANSPORT: LONG_POLLING_TRANSPORT_1,
	ALL: ALL_1
};

var CometD$2 = CometD;
var Transports$2 = Transports;

/**
 * Data aggregation
 *
 * Provides data aggregation over time and across different items
 *  User devices push items data on developer-defined categories
 *  This service automatically aggregates the data
 * Raw data is not available for reading, only the generated aggregation result
 *
 * */
/**
 * User API for item aggregation
 *
 * Users can push data and be notified of aggregated data.
 * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.
 * @access public
 * */
var Aggreg = function (_Service) {
  inherits(Aggreg, _Service);

  function Aggreg() {
    classCallCheck(this, Aggreg);
    return possibleConstructorReturn(this, (Aggreg.__proto__ || Object.getPrototypeOf(Aggreg)).apply(this, arguments));
  }

  createClass(Aggreg, [{
    key: 'push',

    /**
     * Pushes some data
     *
     * Pushes the given data.
     * All the items are processed according to the defined rules.
     * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.
     * */
    value: function push(_ref) {
      var items = _ref.items,
          owner = _ref.owner;

      return this.$publish('push', { items: items, owner: owner });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Aggreg service
     * @return {string}
     */
    get: function get$$1() {
      return 'aggreg_0';
    }
  }]);
  return Aggreg;
}(Service);
/**
 * Data stacks
 *
 * Stacks are a per-user named persistent queue of data
 *  An administrator creates a stack service
 *  End-users can push data on an arbitrary number of their own arbitrary named stacks
 * */
/**
 * Data stack user API
 *
 * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.
 * Stack names are arbitrary and do not need to be explicitly initialized.
 * @access public
 * */
var Stack = function (_Service2) {
  inherits(Stack, _Service2);

  function Stack() {
    classCallCheck(this, Stack);
    return possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).apply(this, arguments));
  }

  createClass(Stack, [{
    key: 'getListeners',

    /**
     * Lists the listeners
     *
     * Returns the whole list of listeners for the given stack.
     * */
    value: function getListeners(_ref2) {
      var stack = _ref2.stack,
          owner = _ref2.owner;

      return this.$publish('getListeners', { stack: stack, owner: owner });
    }
    /**
     * Lists content
     *
     * Returns a paginated list of contents for the given stack.
     * Content is sorted according to the statically configured order.
     * */

  }, {
    key: 'list',
    value: function list(_ref3) {
      var stack = _ref3.stack,
          owner = _ref3.owner,
          page = _ref3.page;

      return this.$publish('list', { stack: stack, owner: owner, page: page });
    }
    /**
     * Empties a stack
     *
     * Removes all items from the given stack.
     * */

  }, {
    key: 'purge',
    value: function purge(_ref4) {
      var stack = _ref4.stack,
          owner = _ref4.owner;

      return this.$publish('purge', { stack: stack, owner: owner });
    }
    /**
     * Pushes an item
     *
     * Pushes an item onto the given stack.
     * The stack does not need to be created.
     * */

  }, {
    key: 'push',
    value: function push(_ref5) {
      var stack = _ref5.stack,
          data = _ref5.data,
          owner = _ref5.owner;

      return this.$publish('push', { stack: stack, data: data, owner: owner });
    }
    /**
     * Removes items
     *
     * Removes the item with the given guid from the given stack.
     * */

  }, {
    key: 'remove',
    value: function remove(_ref6) {
      var guids = _ref6.guids,
          stack = _ref6.stack,
          owner = _ref6.owner;

      return this.$publish('remove', { guids: guids, stack: stack, owner: owner });
    }
    /**
     * Sets the listeners
     *
     * Sets the listeners for the given stack.
     * */

  }, {
    key: 'setListeners',
    value: function setListeners(_ref7) {
      var listeners = _ref7.listeners,
          stack = _ref7.stack,
          owner = _ref7.owner;

      return this.$publish('setListeners', { listeners: listeners, stack: stack, owner: owner });
    }
    /**
     * Updates an item
     *
     * Updates an existing item of the given stack.
     * The item MUST exist prior to the call.
     * */

  }, {
    key: 'update',
    value: function update(_ref8) {
      var guid = _ref8.guid,
          stack = _ref8.stack,
          data = _ref8.data,
          owner = _ref8.owner;

      return this.$publish('update', { guid: guid, stack: stack, data: data, owner: owner });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Stack service
     * @return {string}
     */
    get: function get$$1() {
      return 'stack_0';
    }
  }]);
  return Stack;
}(Service);
/**
 * Echo
 *
 * Echo
 * */
/**
 * Echo service
 *
 * Simple echo service, for development purposes.
 * @access public
 * */
var Echo = function (_Service3) {
  inherits(Echo, _Service3);

  function Echo() {
    classCallCheck(this, Echo);
    return possibleConstructorReturn(this, (Echo.__proto__ || Object.getPrototypeOf(Echo)).apply(this, arguments));
  }

  createClass(Echo, [{
    key: 'echo',

    /**
     * Echoes an object
     *
     * Echoes an object: the server will echo that object on channel 'echo' for the current user.
     * */
    value: function echo(parameter) {
      return this.$publish('echo', parameter);
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Echo service
     * @return {string}
     */
    get: function get$$1() {
      return 'echo_0';
    }
  }]);
  return Echo;
}(Service);
/**
 * Game engine
 *
 * Abstract Game Engine
 *  Concrete game engines are remote cometd clients or internal macros
 * */
/**
 * User API for games
 *
 * Users can list, start, join games, and play.
 * @access public
 * */
var Game = function (_Service4) {
  inherits(Game, _Service4);

  function Game() {
    classCallCheck(this, Game);
    return possibleConstructorReturn(this, (Game.__proto__ || Object.getPrototypeOf(Game)).apply(this, arguments));
  }

  createClass(Game, [{
    key: 'available',

    /**
     * Lists game types
     *
     * Returns the list of game types supported by the server and the currently registered game engines.
     * */
    value: function available() {
      return this.$publish('available', {});
    }
    /**A user joins a game*/

  }, {
    key: 'join',
    value: function join(_ref9) {
      var role = _ref9.role,
          gameId = _ref9.gameId,
          userId = _ref9.userId,
          userName = _ref9.userName;

      return this.$publish('join', { role: role, gameId: gameId, userId: userId, userName: userName });
    }
    /**Organizes a game*/

  }, {
    key: 'organize',
    value: function organize(_ref10) {
      var type = _ref10.type,
          owner = _ref10.owner,
          options = _ref10.options;

      return this.$publish('organize', { type: type, owner: owner, options: options });
    }
    /**Gives some command to the game engine*/

  }, {
    key: 'play',
    value: function play(_ref11) {
      var gameId = _ref11.gameId,
          userId = _ref11.userId,
          data = _ref11.data;

      return this.$publish('play', { gameId: gameId, userId: userId, data: data });
    }
    /**Starts a game*/

  }, {
    key: 'start',
    value: function start(_ref12) {
      var gameId = _ref12.gameId;

      return this.$publish('start', { gameId: gameId });
    }
    /**A user cancels joining a game*/

  }, {
    key: 'unjoin',
    value: function unjoin(_ref13) {
      var role = _ref13.role,
          gameId = _ref13.gameId,
          userId = _ref13.userId,
          userName = _ref13.userName;

      return this.$publish('unjoin', { role: role, gameId: gameId, userId: userId, userName: userName });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Game service
     * @return {string}
     */
    get: function get$$1() {
      return 'game_0';
    }
  }]);
  return Game;
}(Service);
/**
 * Game Engine API
 *
 * The Game Engine API is for game engine clients, not end-users.
 * @access public
 * */
var GameEngine = function (_Service5) {
  inherits(GameEngine, _Service5);

  function GameEngine() {
    classCallCheck(this, GameEngine);
    return possibleConstructorReturn(this, (GameEngine.__proto__ || Object.getPrototypeOf(GameEngine)).apply(this, arguments));
  }

  createClass(GameEngine, [{
    key: 'join_result',

    /**
     * Notify the result for a join request
     *
     * A Game Engine notifies the STR of the result of a join request that it received on join_callback
     * */
    value: function join_result(_ref14) {
      var msgId = _ref14.msgId,
          payload = _ref14.payload,
          error = _ref14.error,
          callerId = _ref14.callerId;

      return this.$publish('join_result', { msgId: msgId, payload: payload, error: error, callerId: callerId });
    }
    /**
     * Notify the result for an organization request
     *
     * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback
     * */

  }, {
    key: 'organize_result',
    value: function organize_result(_ref15) {
      var msgId = _ref15.msgId,
          payload = _ref15.payload,
          error = _ref15.error,
          callerId = _ref15.callerId;

      return this.$publish('organize_result', {
        msgId: msgId,
        payload: payload,
        error: error,
        callerId: callerId
      });
    }
    /**
     * Registers a game engine
     *
     * A client registers itself to the STR as a Game Engine.
     * The STR may, from now on, dispatch game of the given game type to said client.
     * Unregistration is done automatically on logoff.
     * */

  }, {
    key: 'register',
    value: function register(_ref16) {
      var maxGames = _ref16.maxGames,
          gameInfo = _ref16.gameInfo,
          location = _ref16.location;

      return this.$publish('register', { maxGames: maxGames, gameInfo: gameInfo, location: location });
    }
    /**
     * Notify the result for a start request
     *
     * A Game Engine notifies the STR of the result of a start request that it received on start_callback
     * */

  }, {
    key: 'start_result',
    value: function start_result(_ref17) {
      var gameId = _ref17.gameId;

      return this.$publish('start_result', { gameId: gameId });
    }
    /**
     * Notify a game event
     *
     * A Game Engine notifies the STR of some arbitrary game event.
     * */

  }, {
    key: 'state',
    value: function state(_ref18) {
      var status = _ref18.status,
          gameId = _ref18.gameId,
          data = _ref18.data;

      return this.$publish('state', { status: status, gameId: gameId, data: data });
    }
    /**
     * Notify the result for an unjoin request
     *
     * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback
     * */

  }, {
    key: 'unjoin_result',
    value: function unjoin_result(_ref19) {
      var msgId = _ref19.msgId,
          payload = _ref19.payload,
          error = _ref19.error,
          callerId = _ref19.callerId;

      return this.$publish('unjoin_result', { msgId: msgId, payload: payload, error: error, callerId: callerId });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to GameEngine service
     * @return {string}
     */
    get: function get$$1() {
      return 'game_0';
    }
  }]);
  return GameEngine;
}(Service);
/**
 * Generic Data Access
 *
 * Generic Data Access Service : NoSQL storage
 * */
/**
 * GDA User API
 *
 * User API for Generic Data Access.
 * The data are stored on a per-user basis.
 * Users can put, get, list their data.
 * @access public
 * */
var Gda = function (_Service6) {
  inherits(Gda, _Service6);

  function Gda() {
    classCallCheck(this, Gda);
    return possibleConstructorReturn(this, (Gda.__proto__ || Object.getPrototypeOf(Gda)).apply(this, arguments));
  }

  createClass(Gda, [{
    key: 'get',

    /**
     * Asks for a data row
     *
     * Returns a full data row.
     * */
    value: function get$$1(_ref20) {
      var table = _ref20.table,
          key = _ref20.key,
          owner = _ref20.owner;

      return this.$publish('get', { table: table, key: key, owner: owner });
    }
    /**
     * Asks for a data cell
     *
     * Returns a precise list of cells from a column in a data row.
     * */

  }, {
    key: 'getCells',
    value: function getCells(_ref21) {
      var table = _ref21.table,
          key = _ref21.key,
          key2 = _ref21.key2,
          owner = _ref21.owner,
          column = _ref21.column;

      return this.$publish('getCells', { table: table, key: key, key2: key2, owner: owner, column: column });
    }
    /**
     * Increments an integer value
     *
     * Increments a cell 64-bit signed integer value and returns the result in the data field.
     * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.
     * */

  }, {
    key: 'inc',
    value: function inc(_ref22) {
      var table = _ref22.table,
          data = _ref22.data,
          key = _ref22.key,
          key2 = _ref22.key2,
          owner = _ref22.owner,
          column = _ref22.column;

      return this.$publish('inc', { table: table, data: data, key: key, key2: key2, owner: owner, column: column });
    }
    /**
     * Asks for a list of rows
     *
     * Returns a paginated list of rows from the given table.
     * */

  }, {
    key: 'list',
    value: function list(_ref23) {
      var columns = _ref23.columns,
          table = _ref23.table,
          owner = _ref23.owner,
          page = _ref23.page;

      return this.$publish('list', { columns: columns, table: table, owner: owner, page: page });
    }
    /**
     * Puts some data into a cell
     *
     * Creates or replaces the contents of a particular cell.
     * */

  }, {
    key: 'put',
    value: function put(_ref24) {
      var table = _ref24.table,
          data = _ref24.data,
          key = _ref24.key,
          key2 = _ref24.key2,
          owner = _ref24.owner,
          column = _ref24.column;

      return this.$publish('put', { table: table, data: data, key: key, key2: key2, owner: owner, column: column });
    }
    /**
     * Puts several rows
     *
     * Creates or replaces the (maybe partial) contents of a collection of rows.
     * This method only creates or replaces cells for non-null input values.
     * */

  }, {
    key: 'puts',
    value: function puts(_ref25) {
      var rows = _ref25.rows,
          table = _ref25.table,
          owner = _ref25.owner;

      return this.$publish('puts', { rows: rows, table: table, owner: owner });
    }
    /**
     * Asks for a range of rows
     *
     * Returns a paginated range of rows from the given table.
     * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).
     * You can specify partial keys for the start and stop fields.
     * */

  }, {
    key: 'range',
    value: function range(_ref26) {
      var columns = _ref26.columns,
          start = _ref26.start,
          table = _ref26.table,
          stop = _ref26.stop,
          owner = _ref26.owner,
          page = _ref26.page;

      return this.$publish('range', { columns: columns, start: start, table: table, stop: stop, owner: owner, page: page });
    }
    /**
     * Removes one cell inside a column of a row
     *
     * Removes only one cell of the given column of the given row from the given table.
     * */

  }, {
    key: 'removeCell',
    value: function removeCell(_ref27) {
      var table = _ref27.table,
          key = _ref27.key,
          key2 = _ref27.key2,
          owner = _ref27.owner,
          column = _ref27.column;

      return this.$publish('removeCell', { table: table, key: key, key2: key2, owner: owner, column: column });
    }
    /**
     * Removes one full column of a row
     *
     * Removes all cells of the given column of the given row from the given table.
     * */

  }, {
    key: 'removeColumn',
    value: function removeColumn(_ref28) {
      var table = _ref28.table,
          key = _ref28.key,
          owner = _ref28.owner,
          column = _ref28.column;

      return this.$publish('removeColumn', { table: table, key: key, owner: owner, column: column });
    }
    /**
     * Removes a range of rows
     *
     * Removes the specified columns of the given range of rows from the given table.
     * */

  }, {
    key: 'removeRange',
    value: function removeRange(_ref29) {
      var columns = _ref29.columns,
          start = _ref29.start,
          table = _ref29.table,
          stop = _ref29.stop,
          owner = _ref29.owner;

      return this.$publish('removeRange', { columns: columns, start: start, table: table, stop: stop, owner: owner });
    }
    /**
     * Removes one full row
     *
     * Removes all columns of the given row from the given table.
     * */

  }, {
    key: 'removeRow',
    value: function removeRow(_ref30) {
      var table = _ref30.table,
          key = _ref30.key,
          owner = _ref30.owner;

      return this.$publish('removeRow', { table: table, key: key, owner: owner });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Gda service
     * @return {string}
     */
    get: function get$$1() {
      return 'gda_0';
    }
  }]);
  return Gda;
}(Service);
/**
 * Groups Management
 *
 * Groups management for users, grants on resources, remote commands on devices
 *  This is where you can configure rights for any resource
 *
 * */
/**
 * User API for remote control
 *
 * @access public
 * */

var Remoting = function (_Service7) {
  inherits(Remoting, _Service7);

  function Remoting() {
    classCallCheck(this, Remoting);
    return possibleConstructorReturn(this, (Remoting.__proto__ || Object.getPrototypeOf(Remoting)).apply(this, arguments));
  }

  createClass(Remoting, [{
    key: 'addListener',

    /**
     * Adds a listener
     *
     * A user requests notifications from a device owned by anyone who granted him the right authorizations.
     * Whenever the device calls 'notify', notifications will be sent to the caller of this verb.
     * */
    value: function addListener(_ref31) {
      var resource = _ref31.resource,
          fromResource = _ref31.fromResource,
          cmd = _ref31.cmd,
          from = _ref31.from,
          data = _ref31.data,
          owner = _ref31.owner;

      return this.$publish('addListener', {
        resource: resource,
        fromResource: fromResource,
        cmd: cmd,
        from: from,
        data: data,
        owner: owner
      });
    }
    /**Response to 'getCapabilities'*/

  }, {
    key: 'capabilities',
    value: function capabilities(_ref32) {
      var askingResource = _ref32.askingResource,
          _capabilities = _ref32.capabilities,
          answeringResource = _ref32.answeringResource;

      return this.$publish('capabilities', {
        askingResource: askingResource,
        capabilities: _capabilities,
        answeringResource: answeringResource
      });
    }
    /**
     * Executes a command
     *
     * A user executes a command on a device owned by anyone who granted him the right authorizations.
     * The command is issued on channel 'command'
     * */

  }, {
    key: 'execute',
    value: function execute(_ref33) {
      var resource = _ref33.resource,
          cmd = _ref33.cmd,
          data = _ref33.data,
          owner = _ref33.owner;

      return this.$publish('execute', { resource: resource, cmd: cmd, data: data, owner: owner });
    }
    /**
     * Requests capabilities
     *
     * A user requests all his devices for the whole list of their capabilities.
     * Devices are expected to answer on channel 'capabilities'
     * */

  }, {
    key: 'getCapabilities',
    value: function getCapabilities() {
      return this.$publish('getCapabilities', {});
    }
    /**
     * Notifies of some event
     *
     * A device notifies the registered users/devices on this channel.
     * The server forwards the notification to said users.
     * */

  }, {
    key: 'notify',
    value: function notify(_ref34) {
      var resource = _ref34.resource,
          fromResource = _ref34.fromResource,
          cmd = _ref34.cmd,
          from = _ref34.from,
          data = _ref34.data,
          owner = _ref34.owner;

      return this.$publish('notify', {
        resource: resource,
        fromResource: fromResource,
        cmd: cmd,
        from: from,
        data: data,
        owner: owner
      });
    }
    /**
     * Pings devices
     *
     * A user requests all devices (of all owners) on which he has authorizations to respond on channel 'pong'
     * */

  }, {
    key: 'ping',
    value: function ping(_ref35) {
      var action = _ref35.action;

      return this.$publish('ping', { action: action });
    }
    /**Response to ping*/

  }, {
    key: 'pong',
    value: function pong(_ref36) {
      var user = _ref36.user,
          resource = _ref36.resource,
          available = _ref36.available,
          uid = _ref36.uid,
          owner = _ref36.owner,
          action = _ref36.action;

      return this.$publish('pong', {
        user: user,
        resource: resource,
        available: available,
        uid: uid,
        owner: owner,
        action: action
      });
    }
    /**
     * Removes a listener
     *
     * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations
     * */

  }, {
    key: 'removeListener',
    value: function removeListener(_ref37) {
      var resource = _ref37.resource,
          fromResource = _ref37.fromResource,
          cmd = _ref37.cmd,
          from = _ref37.from,
          data = _ref37.data,
          owner = _ref37.owner;

      return this.$publish('removeListener', {
        resource: resource,
        fromResource: fromResource,
        cmd: cmd,
        from: from,
        data: data,
        owner: owner
      });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Remoting service
     * @return {string}
     */
    get: function get$$1() {
      return 'groups_0';
    }
  }]);
  return Remoting;
}(Service);
var GroupManagement = function (_Service8) {
  inherits(GroupManagement, _Service8);

  function GroupManagement() {
    classCallCheck(this, GroupManagement);
    return possibleConstructorReturn(this, (GroupManagement.__proto__ || Object.getPrototypeOf(GroupManagement)).apply(this, arguments));
  }

  createClass(GroupManagement, [{
    key: 'addMe',

    /**
     * Adds me to a group
     *
     * Adds me (the caller) to a group.
     * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.
     * The 'user' field is implicitly set to the current user's key.
     * */
    value: function addMe(_ref38) {
      var group = _ref38.group,
          owner = _ref38.owner;

      return this.$publish('addMe', { group: group, owner: owner });
    }
    /**
     * Adds a user to a group
     *
     * Adds the given user to the given group.
     * Addition may fail if the given group does not already exist.
     * */

  }, {
    key: 'addUser',
    value: function addUser(_ref39) {
      var user = _ref39.user,
          group = _ref39.group,
          owner = _ref39.owner;

      return this.$publish('addUser', { user: user, group: group, owner: owner });
    }
    /**Adds users to a group*/

  }, {
    key: 'addUsers',
    value: function addUsers(_ref40) {
      var users = _ref40.users,
          group = _ref40.group,
          owner = _ref40.owner;

      return this.$publish('addUsers', { users: users, group: group, owner: owner });
    }
    /**
     * Lists my owned groups, with details
     *
     * Returns the whole list of groups owned by the current user, with their members
     * */

  }, {
    key: 'allGroups',
    value: function allGroups(_ref41) {
      var owner = _ref41.owner;

      return this.$publish('allGroups', { owner: owner });
    }
    /**
     * Creates a group
     *
     * Creates a group owned by the current user.
     * Group creation may fail if the group already exists.
     * */

  }, {
    key: 'createGroup',
    value: function createGroup(_ref42) {
      var group = _ref42.group,
          groupName = _ref42.groupName,
          owner = _ref42.owner;

      return this.$publish('createGroup', { group: group, groupName: groupName, owner: owner });
    }
    /**
     * Removes a group
     *
     * Removes the given group owned by the current user or the given owner.
     * Also removes all grants to that group.
     * */

  }, {
    key: 'delGroup',
    value: function delGroup(_ref43) {
      var group = _ref43.group,
          owner = _ref43.owner;

      return this.$publish('delGroup', { group: group, owner: owner });
    }
    /**Removes a user from a group*/

  }, {
    key: 'delUser',
    value: function delUser(_ref44) {
      var user = _ref44.user,
          group = _ref44.group,
          owner = _ref44.owner;

      return this.$publish('delUser', { user: user, group: group, owner: owner });
    }
    /**Removes users from a group*/

  }, {
    key: 'delUsers',
    value: function delUsers(_ref45) {
      var users = _ref45.users,
          group = _ref45.group,
          groupName = _ref45.groupName,
          owner = _ref45.owner;

      return this.$publish('delUsers', { users: users, group: group, groupName: groupName, owner: owner });
    }
    /**
     * Tests for a group's existence
     *
     * Returns whether a group exists or not.
     * */

  }, {
    key: 'exists',
    value: function exists(_ref46) {
      var group = _ref46.group,
          owner = _ref46.owner;

      return this.$publish('exists', { group: group, owner: owner });
    }
    /**
     * Grants a right to a group
     *
     * The granting API does not do any check when storing permissions.
     * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.
     * */

  }, {
    key: 'grant',
    value: function grant(_ref47) {
      var resource = _ref47.resource,
          group = _ref47.group,
          owner = _ref47.owner,
          action = _ref47.action;

      return this.$publish('grant', { resource: resource, group: group, owner: owner, action: action });
    }
    /**
     * Lists the group users
     *
     * Returns the whole list of users configured inside the given group.
     * */

  }, {
    key: 'groupUsers',
    value: function groupUsers(_ref48) {
      var group = _ref48.group,
          owner = _ref48.owner;

      return this.$publish('groupUsers', { group: group, owner: owner });
    }
    /**
     * Lists my owned groups
     *
     * Returns the whole list of groups owned by the current user
     * */

  }, {
    key: 'groups',
    value: function groups(_ref49) {
      var owner = _ref49.owner;

      return this.$publish('groups', { owner: owner });
    }
    /**
     * Lists rights for a group
     *
     * This API lists explicitly configured rights.
     * Effective rights include configured rights, implicit rights and inherited rights.
     * */

  }, {
    key: 'listGrants',
    value: function listGrants(_ref50) {
      var group = _ref50.group,
          owner = _ref50.owner;

      return this.$publish('listGrants', { group: group, owner: owner });
    }
    /**
     * Lists presences for a group
     *
     * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.
     * The current implementation does not include information about the particular devices users are connected with.
     * If a user is connected twice with two different devices, two identical entries will be returned.
     * */

  }, {
    key: 'listPresences',
    value: function listPresences(_ref51) {
      var group = _ref51.group,
          owner = _ref51.owner;

      return this.$publish('listPresences', { group: group, owner: owner });
    }
    /**
     * Tests membership
     *
     * Tests whether I (the caller) am a member of the given group.
     * This verb exists so that users can determine if they are part of a group without being granted particular rights.
     * The 'user' field is implicitly set to the current user's key.
     * */

  }, {
    key: 'memberOf',
    value: function memberOf(_ref52) {
      var hardFail = _ref52.hardFail,
          group = _ref52.group,
          owner = _ref52.owner;

      return this.$publish('memberOf', { hardFail: hardFail, group: group, owner: owner });
    }
    /**
     * Grants rights to a group
     *
     * Grant several rights at once.
     * */

  }, {
    key: 'mgrant',
    value: function mgrant(_ref53) {
      var resource = _ref53.resource,
          actions = _ref53.actions,
          group = _ref53.group,
          owner = _ref53.owner;

      return this.$publish('mgrant', { resource: resource, actions: actions, group: group, owner: owner });
    }
    /**Revokes rights for a group*/

  }, {
    key: 'mrevoke',
    value: function mrevoke(_ref54) {
      var resource = _ref54.resource,
          actions = _ref54.actions,
          group = _ref54.group,
          owner = _ref54.owner;

      return this.$publish('mrevoke', { resource: resource, actions: actions, group: group, owner: owner });
    }
    /**
     * Lists the groups I am part of
     *
     * Returns the whole list of groups the current user is part of.
     * Groups may be owned by anyone, including the current user.
     * */

  }, {
    key: 'myGroups',
    value: function myGroups(_ref55) {
      var owner = _ref55.owner;

      return this.$publish('myGroups', { owner: owner });
    }
    /**Revokes a right for a group*/

  }, {
    key: 'revoke',
    value: function revoke(_ref56) {
      var resource = _ref56.resource,
          group = _ref56.group,
          owner = _ref56.owner,
          action = _ref56.action;

      return this.$publish('revoke', { resource: resource, group: group, owner: owner, action: action });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to GroupManagement service
     * @return {string}
     */
    get: function get$$1() {
      return 'groups_0';
    }
  }]);
  return GroupManagement;
}(Service);
/**
 * HTTP client
 *
 * Web-service client
 *  An admin records URL templates that can be called by users
 *  Calls are not configurable by end-users
 *  However an admin may leverage the macro service to achieve URL, headers and body configurability
 * */
/**
 * User API for http requests
 *
 * @access public
 * */
var Httpclient = function (_Service9) {
  inherits(Httpclient, _Service9);

  function Httpclient() {
    classCallCheck(this, Httpclient);
    return possibleConstructorReturn(this, (Httpclient.__proto__ || Object.getPrototypeOf(Httpclient)).apply(this, arguments));
  }

  createClass(Httpclient, [{
    key: 'call',

    /**
     * Makes a predefined request
     *
     * Lookups a predefined request by name, and executes it.
     * */
    value: function call(_ref57) {
      var name = _ref57.name,
          requestId = _ref57.requestId;

      return this.$publish('call', { name: name, requestId: requestId });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Httpclient service
     * @return {string}
     */
    get: function get$$1() {
      return 'httpclient_0';
    }
  }]);
  return Httpclient;
}(Service);
/**
 * Macros
 *
 * Macro-command service
 *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc
 *
 *
 *  End-users play them, with contextual parameters
 * */
/**
 * User API for macro debugging
 *
 * Debugger API for macro.
 * These API verbs are not intended for use by most developers.
 * @access public
 * */

var MacroDebug = function (_Service10) {
  inherits(MacroDebug, _Service10);

  function MacroDebug() {
    classCallCheck(this, MacroDebug);
    return possibleConstructorReturn(this, (MacroDebug.__proto__ || Object.getPrototypeOf(MacroDebug)).apply(this, arguments));
  }

  createClass(MacroDebug, [{
    key: 'breakpoint',

    /**Enables or disables a breakpoint*/
    value: function breakpoint(_ref58) {
      var _breakpoint = _ref58.breakpoint,
          token = _ref58.token,
          enabled = _ref58.enabled;

      return this.$publish('breakpoint', { breakpoint: _breakpoint, token: token, enabled: enabled });
    }
    /**Requests some information*/

  }, {
    key: 'info',
    value: function info(_ref59) {
      var token = _ref59.token,
          path = _ref59.path,
          exp = _ref59.exp,
          requestId = _ref59.requestId,
          frame = _ref59.frame;

      return this.$publish('info', { token: token, path: path, exp: exp, requestId: requestId, frame: frame });
    }
    /**
     * Debugs a previously recorded macro
     *
     * The given breakpoints will be honored, causing a suspension of the execution, resumable via 'resume'.
     * Only one debug session can be active at any given time.
     * */

  }, {
    key: 'livedebug',
    value: function livedebug(_ref60) {
      var parameters = _ref60.parameters,
          token = _ref60.token,
          breakpoints = _ref60.breakpoints,
          hardFail = _ref60.hardFail,
          name = _ref60.name,
          requestId = _ref60.requestId,
          debug = _ref60.debug;

      return this.$publish('livedebug', {
        parameters: parameters,
        token: token,
        breakpoints: breakpoints,
        hardFail: hardFail,
        name: name,
        requestId: requestId,
        debug: debug
      });
    }
    /**Resumes a paused macro*/

  }, {
    key: 'resume',
    value: function resume(_ref61) {
      var token = _ref61.token,
          type = _ref61.type;

      return this.$publish('resume', { token: token, type: type });
    }
    /**Sets a variable value*/

  }, {
    key: 'variable',
    value: function variable(_ref62) {
      var token = _ref62.token,
          name = _ref62.name,
          frame = _ref62.frame,
          data = _ref62.data;

      return this.$publish('variable', { token: token, name: name, frame: frame, data: data });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to MacroDebug service
     * @return {string}
     */
    get: function get$$1() {
      return 'macro_0';
    }
  }]);
  return MacroDebug;
}(Service);
var Macro = function (_Service11) {
  inherits(Macro, _Service11);

  function Macro() {
    classCallCheck(this, Macro);
    return possibleConstructorReturn(this, (Macro.__proto__ || Object.getPrototypeOf(Macro)).apply(this, arguments));
  }

  createClass(Macro, [{
    key: 'call',

    /**
     * Plays a previously recorded macro
     *
     * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.
     * You can override the default notification channel when defining the macro.
     * */
    value: function call(_ref63) {
      var parameters = _ref63.parameters,
          hardFail = _ref63.hardFail,
          name = _ref63.name,
          requestId = _ref63.requestId,
          debug = _ref63.debug;

      return this.$publish('call', {
        parameters: parameters,
        hardFail: hardFail,
        name: name,
        requestId: requestId,
        debug: debug
      });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Macro service
     * @return {string}
     */
    get: function get$$1() {
      return 'macro_0';
    }
  }]);
  return Macro;
}(Service);
/**
 * Mail sender
 *
 * Sends email through SMTP
 * */
/**
 * Mail service user API
 *
 * This service is statically configured with an outgoing SMTP server.
 * Users call the API here to actually send emails.
 * @access public
 * */
var Sendmail = function (_Service12) {
  inherits(Sendmail, _Service12);

  function Sendmail() {
    classCallCheck(this, Sendmail);
    return possibleConstructorReturn(this, (Sendmail.__proto__ || Object.getPrototypeOf(Sendmail)).apply(this, arguments));
  }

  createClass(Sendmail, null, [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Sendmail service
     * @return {string}
     */
    get: function get$$1() {
      return 'sendmail_0';
    }
  }]);
  return Sendmail;
}(Service);
/**
 * Messaging service
 *
 * Messaging service
 * */
/**
 * Messaging service
 *
 * Simple and flexible user-to-user or user-to-group messaging service.
 * @access public
 * */
var Messaging = function (_Service13) {
  inherits(Messaging, _Service13);

  function Messaging() {
    classCallCheck(this, Messaging);
    return possibleConstructorReturn(this, (Messaging.__proto__ || Object.getPrototypeOf(Messaging)).apply(this, arguments));
  }

  createClass(Messaging, [{
    key: 'send',

    /**
     * Sends a message to a target
     *
     * Sends the given message to the specified target on the given (optional) channel.
     * The administratively given default channel name is used when none is provided in the message itself.
     * */
    value: function send(_ref64) {
      var target = _ref64.target,
          channel = _ref64.channel,
          data = _ref64.data;

      return this.$publish('send', { target: target, channel: channel, data: data });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Messaging service
     * @return {string}
     */
    get: function get$$1() {
      return 'messaging_0';
    }
  }]);
  return Messaging;
}(Service);
/**
 * Producer consumer
 *
 * Producer consumer service
 *  Users can submit tasks and other users consume them
 * */
/**
 * Producer / consumer real-time API
 *
 * Task producers submits their tasks.
 * The server dispatches the tasks.
 * Consumers process them and report completion back to the server.
 * Tasks are global to the service (i.e. NOT per user).
 * @access public
 * */
var Queue = function (_Service14) {
  inherits(Queue, _Service14);

  function Queue() {
    classCallCheck(this, Queue);
    return possibleConstructorReturn(this, (Queue.__proto__ || Object.getPrototypeOf(Queue)).apply(this, arguments));
  }

  createClass(Queue, [{
    key: 'call',

    /**
     * Submits a task
     *
     * Producer API.
     * A task producer submits the given task to the server.
     * The server will find a tasker with processing capacity and dispatch the task.
     * The task result will be returned to the caller.
     * When called from inside a macro, the comsumer generated result is available for further use.
     * */
    value: function call(_ref65) {
      var description = _ref65.description,
          originBusinessId = _ref65.originBusinessId,
          originDeploymentId = _ref65.originDeploymentId,
          data = _ref65.data,
          owner = _ref65.owner;

      return this.$publish('call', {
        description: description,
        originBusinessId: originBusinessId,
        originDeploymentId: originDeploymentId,
        data: data,
        owner: owner
      });
    }
    /**
     * Notifies completion of a task
     *
     * Consumer API.
     * The tasker notifies completion of the given task to the server.
     * The tasker can optionally include a result or an error code.
     * */

  }, {
    key: 'done',
    value: function done(_ref66) {
      var target = _ref66.target,
          result = _ref66.result,
          taskId = _ref66.taskId,
          requestId = _ref66.requestId,
          success = _ref66.success;

      return this.$publish('done', {
        target: target,
        result: result,
        taskId: taskId,
        requestId: requestId,
        success: success
      });
    }
    /**
     * Registers a consumer
     *
     * Consumer API.
     * Registers the current user resource as an available task consumer.
     * Tasks will be then dispatched to that consumer.
     * */

  }, {
    key: 'register',
    value: function register(_ref67) {
      var capacity = _ref67.capacity;

      return this.$publish('register', { capacity: capacity });
    }
    /**
     * Submits a task
     *
     * Producer API.
     * A task producer submits the given task to the server.
     * The server will find a tasker with processing capacity and dispatch the task.
     * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).
     * This verb will return immediately : you can use this API to asynchronously submit a task.
     * */

  }, {
    key: 'submit',
    value: function submit(_ref68) {
      var description = _ref68.description,
          originBusinessId = _ref68.originBusinessId,
          originDeploymentId = _ref68.originDeploymentId,
          data = _ref68.data,
          owner = _ref68.owner;

      return this.$publish('submit', {
        description: description,
        originBusinessId: originBusinessId,
        originDeploymentId: originDeploymentId,
        data: data,
        owner: owner
      });
    }
    /**
     * Unregisters a consumer
     *
     * Consumer API.
     * Unregisters the current user resource as an available task consumer.
     * All non finished tasks are returned to the server.
     * */

  }, {
    key: 'unregister',
    value: function unregister() {
      return this.$publish('unregister', {});
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Queue service
     * @return {string}
     */
    get: function get$$1() {
      return 'queue_0';
    }
  }]);
  return Queue;
}(Service);
/**
 * Push Notifications
 *
 * Native Push Notifications for Android, iOS
 *
 *
 *
 * */
/**
 * Notification User API
 *
 * User API for notifications.
 * For notifications to work properly, it is imperative that the resource name of a device remain constant over time.
 * @access public
 * */
var Notif = function (_Service15) {
  inherits(Notif, _Service15);

  function Notif() {
    classCallCheck(this, Notif);
    return possibleConstructorReturn(this, (Notif.__proto__ || Object.getPrototypeOf(Notif)).apply(this, arguments));
  }

  createClass(Notif, null, [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Notif service
     * @return {string}
     */
    get: function get$$1() {
      return 'notif_0';
    }
  }]);
  return Notif;
}(Service);
/**
 * RDBMS
 *
 * Relational Database : SQL storage
 * */
/**
 * RDBMS User API
 *
 * User API for SQL queries.
 * Contrary to GDA or Stacks, the data are not stored on a per-user basis.
 * Users can store, get, list their data.
 * @access public
 * */
var Rdbms = function (_Service16) {
  inherits(Rdbms, _Service16);

  function Rdbms() {
    classCallCheck(this, Rdbms);
    return possibleConstructorReturn(this, (Rdbms.__proto__ || Object.getPrototypeOf(Rdbms)).apply(this, arguments));
  }

  createClass(Rdbms, null, [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Rdbms service
     * @return {string}
     */
    get: function get$$1() {
      return 'rdbms_0';
    }
  }]);
  return Rdbms;
}(Service);
/**
 * SMS via OVH
 *
 * SMS sender, to send text messages to mobile phones
 * This SMS sending service uses the OVH API
 *
 * */
/**
 * SMS service
 *
 * User API for SMS.
 * @access public
 * */
var Sms_ovh = function (_Service17) {
  inherits(Sms_ovh, _Service17);

  function Sms_ovh() {
    classCallCheck(this, Sms_ovh);
    return possibleConstructorReturn(this, (Sms_ovh.__proto__ || Object.getPrototypeOf(Sms_ovh)).apply(this, arguments));
  }

  createClass(Sms_ovh, null, [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Sms_ovh service
     * @return {string}
     */
    get: function get$$1() {
      return 'sms_ovh_0';
    }
  }]);
  return Sms_ovh;
}(Service);
/**
 * Scheduler
 *
 * Scheduler service
 *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)
 * */
/**
 * User API for the Scheduler
 *
 * User endpoints for scheduling : users can schedule, list and delete tasks.
 * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.
 * Tasks are run on the server and thus can call api verbs marked as server-only.
 * @access public
 * */
var Cron = function (_Service18) {
  inherits(Cron, _Service18);

  function Cron() {
    classCallCheck(this, Cron);
    return possibleConstructorReturn(this, (Cron.__proto__ || Object.getPrototypeOf(Cron)).apply(this, arguments));
  }

  createClass(Cron, [{
    key: 'list',

    /**
     * List the configured tasks
     *
     * Returns a paginated list of the asking user's tasks.
     * */
    value: function list(_ref69) {
      var start = _ref69.start,
          stop = _ref69.stop,
          owner = _ref69.owner,
          page = _ref69.page;

      return this.$publish('list', { start: start, stop: stop, owner: owner, page: page });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Cron service
     * @return {string}
     */
    get: function get$$1() {
      return 'cron_0';
    }
  }]);
  return Cron;
}(Service);
/**
 * Search engine
 *
 * ElasticSearch engine, to index and search data
 *  An admin creates indices
 *  Users index and search documents
 *
 * */
/**
 * ElasticSearch Service
 *
 * This API is a very thin wrapper around ElasticSearch's API.
 * @access public
 * */

var Search = function (_Service19) {
  inherits(Search, _Service19);

  function Search() {
    classCallCheck(this, Search);
    return possibleConstructorReturn(this, (Search.__proto__ || Object.getPrototypeOf(Search)).apply(this, arguments));
  }

  createClass(Search, [{
    key: 'delete',

    /**
     * Deletes data
     *
     * Deletes a document from the elasticsearch engine by id.
     * */
    value: function _delete(_ref70) {
      var type = _ref70.type,
          id = _ref70.id,
          index = _ref70.index;

      return this.$publish('delete', { type: type, id: id, index: index });
    }
    /**
     * Gets data
     *
     * Retrieves a document from the elasticsearch engine by id.
     * */

  }, {
    key: 'get',
    value: function get$$1(_ref71) {
      var type = _ref71.type,
          id = _ref71.id,
          index = _ref71.index;

      return this.$publish('get', { type: type, id: id, index: index });
    }
    /**
     * Indexes data
     *
     * Inserts or updates a document into the elasticsearch engine.
     * */

  }, {
    key: 'index',
    value: function index(_ref72) {
      var type = _ref72.type,
          id = _ref72.id,
          _index = _ref72.index,
          data = _ref72.data;

      return this.$publish('index', { type: type, id: id, index: _index, data: data });
    }
    /**Searches for data*/

  }, {
    key: 'search',
    value: function search(_ref73) {
      var indices = _ref73.indices,
          query = _ref73.query,
          sort = _ref73.sort,
          page = _ref73.page,
          types = _ref73.types;

      return this.$publish('search', { indices: indices, query: query, sort: sort, page: page, types: types });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Search service
     * @return {string}
     */
    get: function get$$1() {
      return 'search_0';
    }
  }]);
  return Search;
}(Service);
var Template = function (_Service20) {
  inherits(Template, _Service20);

  function Template() {
    classCallCheck(this, Template);
    return possibleConstructorReturn(this, (Template.__proto__ || Object.getPrototypeOf(Template)).apply(this, arguments));
  }

  createClass(Template, [{
    key: 'evaluate',

    /**
     * Evaluates a template
     *
     * Evaluates the given template and returns the result as a string.
     * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.
     * */
    value: function evaluate(_ref74) {
      var languageTag = _ref74.languageTag,
          name = _ref74.name,
          requestId = _ref74.requestId,
          data = _ref74.data;

      return this.$publish('evaluate', { languageTag: languageTag, name: name, requestId: requestId, data: data });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Template service
     * @return {string}
     */
    get: function get$$1() {
      return 'template_0';
    }
  }]);
  return Template;
}(Service);
/**
 * Triggers
 *
 * Register callbacks for events and trigger them when needed
 *
 * */
/**
 * Trigger service
 *
 * Register listeners and trigger events.
 * @access public
 * */
var Trigger = function (_Service21) {
  inherits(Trigger, _Service21);

  function Trigger() {
    classCallCheck(this, Trigger);
    return possibleConstructorReturn(this, (Trigger.__proto__ || Object.getPrototypeOf(Trigger)).apply(this, arguments));
  }

  createClass(Trigger, null, [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Trigger service
     * @return {string}
     */
    get: function get$$1() {
      return 'trigger_0';
    }
  }]);
  return Trigger;
}(Service);
/**
 * Upload: S3
 *
 * Upload service with S3 storage
 * */
/**
 * User API for file management
 *
 * User API for virtual file management and http file upload
 * This API contains all the verbs needed to browse, upload and remove files.
 * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.
 * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.
 * @access public
 * */
var Zpfs_s3 = function (_Service22) {
  inherits(Zpfs_s3, _Service22);

  function Zpfs_s3() {
    classCallCheck(this, Zpfs_s3);
    return possibleConstructorReturn(this, (Zpfs_s3.__proto__ || Object.getPrototypeOf(Zpfs_s3)).apply(this, arguments));
  }

  createClass(Zpfs_s3, [{
    key: 'cp',

    /**
     * Copies a file
     *
     * Copies a file or folder (recursively) to a new location.
     * May fail if the target location is not empty.
     * */
    value: function cp(_ref75) {
      var oldPath = _ref75.oldPath,
          path = _ref75.path,
          owner = _ref75.owner;

      return this.$publish('cp', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Returns disk usage
     *
     * Returns an recursively aggregated number of used bytes, starting at the given path.
     * */

  }, {
    key: 'du',
    value: function du(_ref76) {
      var path = _ref76.path,
          owner = _ref76.owner;

      return this.$publish('du', { path: path, owner: owner });
    }
    /**
     * Links a file
     *
     * Links a file or folder to another location.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'link',
    value: function link(_ref77) {
      var oldPath = _ref77.oldPath,
          path = _ref77.path,
          owner = _ref77.owner;

      return this.$publish('link', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Lists a folder content
     *
     * Returns a paginated list of the folder's content.
     * */

  }, {
    key: 'ls',
    value: function ls(_ref78) {
      var folder = _ref78.folder,
          owner = _ref78.owner,
          page = _ref78.page;

      return this.$publish('ls', { folder: folder, owner: owner, page: page });
    }
    /**
     * Creates a folder
     *
     * Creates a new folder.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'mkdir',
    value: function mkdir(_ref79) {
      var parents = _ref79.parents,
          folder = _ref79.folder,
          owner = _ref79.owner;

      return this.$publish('mkdir', { parents: parents, folder: folder, owner: owner });
    }
    /**
     * Moves a file
     *
     * Moves a file or folder (recursively) to a new location.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'mv',
    value: function mv(_ref80) {
      var oldPath = _ref80.oldPath,
          path = _ref80.path,
          owner = _ref80.owner;

      return this.$publish('mv', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Notifies of upload completion
     *
     * The client application calls this verb to notify that it's done uploading to the cloud.
     * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.
     * */

  }, {
    key: 'newFile',
    value: function newFile(_ref81) {
      var tags = _ref81.tags,
          guid = _ref81.guid,
          metadata = _ref81.metadata,
          owner = _ref81.owner;

      return this.$publish('newFile', { tags: tags, guid: guid, metadata: metadata, owner: owner });
    }
    /**
     * Requests an upload URL
     *
     * Requests an HTTP upload URL.
     * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.
     * */

  }, {
    key: 'newUploadUrl',
    value: function newUploadUrl(_ref82) {
      var contentType = _ref82.contentType,
          path = _ref82.path,
          owner = _ref82.owner;

      return this.$publish('newUploadUrl', { contentType: contentType, path: path, owner: owner });
    }
    /**
     * Removes a file
     *
     * Removes a file or folder (recursively).
     * */

  }, {
    key: 'rm',
    value: function rm(_ref83) {
      var path = _ref83.path,
          owner = _ref83.owner;

      return this.$publish('rm', { path: path, owner: owner });
    }
    /**
     * Creates a snapshot in a new folder
     *
     * Creates a new folder and then copies the given files inside
     * */

  }, {
    key: 'snapshot',
    value: function snapshot(_ref84) {
      var parents = _ref84.parents,
          folder = _ref84.folder,
          items = _ref84.items,
          flatten = _ref84.flatten,
          owner = _ref84.owner;

      return this.$publish('snapshot', {
        parents: parents,
        folder: folder,
        items: items,
        flatten: flatten,
        owner: owner
      });
    }
    /**
     * Returns information about a file
     *
     * Returns information about a single file.
     * The entry field will be null if the path does not exist
     * */

  }, {
    key: 'stat',
    value: function stat(_ref85) {
      var path = _ref85.path,
          owner = _ref85.owner;

      return this.$publish('stat', { path: path, owner: owner });
    }
    /**Updates a file's metadata*/

  }, {
    key: 'updateMeta',
    value: function updateMeta(_ref86) {
      var path = _ref86.path,
          metadataFiles = _ref86.metadataFiles,
          metadata = _ref86.metadata,
          owner = _ref86.owner;

      return this.$publish('updateMeta', {
        path: path,
        metadataFiles: metadataFiles,
        metadata: metadata,
        owner: owner
      });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Zpfs_s3 service
     * @return {string}
     */
    get: function get$$1() {
      return 'zpfs_s3_0';
    }
  }]);
  return Zpfs_s3;
}(Service);
/**
 * Upload: local
 *
 * Upload service with local HDFS storage
 * */
/**
 * User API for local file management
 *
 * User API for file content manipulation
 * @access public
 * */
var Zpfs_hdfs = function (_Service23) {
  inherits(Zpfs_hdfs, _Service23);

  function Zpfs_hdfs() {
    classCallCheck(this, Zpfs_hdfs);
    return possibleConstructorReturn(this, (Zpfs_hdfs.__proto__ || Object.getPrototypeOf(Zpfs_hdfs)).apply(this, arguments));
  }

  createClass(Zpfs_hdfs, [{
    key: 'cp',

    /**
     * Copies a file
     *
     * Copies a file or folder (recursively) to a new location.
     * May fail if the target location is not empty.
     * */
    value: function cp(_ref87) {
      var oldPath = _ref87.oldPath,
          path = _ref87.path,
          owner = _ref87.owner;

      return this.$publish('cp', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Returns disk usage
     *
     * Returns an recursively aggregated number of used bytes, starting at the given path.
     * */

  }, {
    key: 'du',
    value: function du(_ref88) {
      var path = _ref88.path,
          owner = _ref88.owner;

      return this.$publish('du', { path: path, owner: owner });
    }
    /**
     * Links a file
     *
     * Links a file or folder to another location.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'link',
    value: function link(_ref89) {
      var oldPath = _ref89.oldPath,
          path = _ref89.path,
          owner = _ref89.owner;

      return this.$publish('link', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Lists a folder content
     *
     * Returns a paginated list of the folder's content.
     * */

  }, {
    key: 'ls',
    value: function ls(_ref90) {
      var folder = _ref90.folder,
          owner = _ref90.owner,
          page = _ref90.page;

      return this.$publish('ls', { folder: folder, owner: owner, page: page });
    }
    /**
     * Creates a folder
     *
     * Creates a new folder.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'mkdir',
    value: function mkdir(_ref91) {
      var parents = _ref91.parents,
          folder = _ref91.folder,
          owner = _ref91.owner;

      return this.$publish('mkdir', { parents: parents, folder: folder, owner: owner });
    }
    /**
     * Moves a file
     *
     * Moves a file or folder (recursively) to a new location.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'mv',
    value: function mv(_ref92) {
      var oldPath = _ref92.oldPath,
          path = _ref92.path,
          owner = _ref92.owner;

      return this.$publish('mv', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Notifies of upload completion
     *
     * The client application calls this verb to notify that it's done uploading to the cloud.
     * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.
     * */

  }, {
    key: 'newFile',
    value: function newFile(_ref93) {
      var tags = _ref93.tags,
          guid = _ref93.guid,
          metadata = _ref93.metadata,
          owner = _ref93.owner;

      return this.$publish('newFile', { tags: tags, guid: guid, metadata: metadata, owner: owner });
    }
    /**
     * Requests an upload URL
     *
     * Requests an HTTP upload URL.
     * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.
     * */

  }, {
    key: 'newUploadUrl',
    value: function newUploadUrl(_ref94) {
      var contentType = _ref94.contentType,
          path = _ref94.path,
          owner = _ref94.owner;

      return this.$publish('newUploadUrl', { contentType: contentType, path: path, owner: owner });
    }
    /**
     * Removes a file
     *
     * Removes a file or folder (recursively).
     * */

  }, {
    key: 'rm',
    value: function rm(_ref95) {
      var path = _ref95.path,
          owner = _ref95.owner;

      return this.$publish('rm', { path: path, owner: owner });
    }
    /**
     * Creates a snapshot in a new folder
     *
     * Creates a new folder and then copies the given files inside
     * */

  }, {
    key: 'snapshot',
    value: function snapshot(_ref96) {
      var parents = _ref96.parents,
          folder = _ref96.folder,
          items = _ref96.items,
          flatten = _ref96.flatten,
          owner = _ref96.owner;

      return this.$publish('snapshot', {
        parents: parents,
        folder: folder,
        items: items,
        flatten: flatten,
        owner: owner
      });
    }
    /**
     * Returns information about a file
     *
     * Returns information about a single file.
     * The entry field will be null if the path does not exist
     * */

  }, {
    key: 'stat',
    value: function stat(_ref97) {
      var path = _ref97.path,
          owner = _ref97.owner;

      return this.$publish('stat', { path: path, owner: owner });
    }
    /**Updates a file's metadata*/

  }, {
    key: 'updateMeta',
    value: function updateMeta(_ref98) {
      var path = _ref98.path,
          metadataFiles = _ref98.metadataFiles,
          metadata = _ref98.metadata,
          owner = _ref98.owner;

      return this.$publish('updateMeta', {
        path: path,
        metadataFiles: metadataFiles,
        metadata: metadata,
        owner: owner
      });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Zpfs_hdfs service
     * @return {string}
     */
    get: function get$$1() {
      return 'zpfs_hdfs_0';
    }
  }]);
  return Zpfs_hdfs;
}(Service);
/**
 * Upload: pseudo-S3
 *
 * Upload service with pseudo-S3compatible storage
 * */
/**
 * User API for file management
 *
 * User API for virtual file management and http file upload
 * This API contains all the verbs needed to browse, upload and remove files.
 * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.
 * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.
 * @access public
 * */
var Zpfs_s3compat = function (_Service24) {
  inherits(Zpfs_s3compat, _Service24);

  function Zpfs_s3compat() {
    classCallCheck(this, Zpfs_s3compat);
    return possibleConstructorReturn(this, (Zpfs_s3compat.__proto__ || Object.getPrototypeOf(Zpfs_s3compat)).apply(this, arguments));
  }

  createClass(Zpfs_s3compat, [{
    key: 'cp',

    /**
     * Copies a file
     *
     * Copies a file or folder (recursively) to a new location.
     * May fail if the target location is not empty.
     * */
    value: function cp(_ref99) {
      var oldPath = _ref99.oldPath,
          path = _ref99.path,
          owner = _ref99.owner;

      return this.$publish('cp', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Returns disk usage
     *
     * Returns an recursively aggregated number of used bytes, starting at the given path.
     * */

  }, {
    key: 'du',
    value: function du(_ref100) {
      var path = _ref100.path,
          owner = _ref100.owner;

      return this.$publish('du', { path: path, owner: owner });
    }
    /**
     * Links a file
     *
     * Links a file or folder to another location.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'link',
    value: function link(_ref101) {
      var oldPath = _ref101.oldPath,
          path = _ref101.path,
          owner = _ref101.owner;

      return this.$publish('link', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Lists a folder content
     *
     * Returns a paginated list of the folder's content.
     * */

  }, {
    key: 'ls',
    value: function ls(_ref102) {
      var folder = _ref102.folder,
          owner = _ref102.owner,
          page = _ref102.page;

      return this.$publish('ls', { folder: folder, owner: owner, page: page });
    }
    /**
     * Creates a folder
     *
     * Creates a new folder.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'mkdir',
    value: function mkdir(_ref103) {
      var parents = _ref103.parents,
          folder = _ref103.folder,
          owner = _ref103.owner;

      return this.$publish('mkdir', { parents: parents, folder: folder, owner: owner });
    }
    /**
     * Moves a file
     *
     * Moves a file or folder (recursively) to a new location.
     * May fail if the target location is not empty.
     * */

  }, {
    key: 'mv',
    value: function mv(_ref104) {
      var oldPath = _ref104.oldPath,
          path = _ref104.path,
          owner = _ref104.owner;

      return this.$publish('mv', { oldPath: oldPath, path: path, owner: owner });
    }
    /**
     * Notifies of upload completion
     *
     * The client application calls this verb to notify that it's done uploading to the cloud.
     * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.
     * */

  }, {
    key: 'newFile',
    value: function newFile(_ref105) {
      var tags = _ref105.tags,
          guid = _ref105.guid,
          metadata = _ref105.metadata,
          owner = _ref105.owner;

      return this.$publish('newFile', { tags: tags, guid: guid, metadata: metadata, owner: owner });
    }
    /**
     * Requests an upload URL
     *
     * Requests an HTTP upload URL.
     * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.
     * */

  }, {
    key: 'newUploadUrl',
    value: function newUploadUrl(_ref106) {
      var contentType = _ref106.contentType,
          path = _ref106.path,
          owner = _ref106.owner;

      return this.$publish('newUploadUrl', { contentType: contentType, path: path, owner: owner });
    }
    /**
     * Removes a file
     *
     * Removes a file or folder (recursively).
     * */

  }, {
    key: 'rm',
    value: function rm(_ref107) {
      var path = _ref107.path,
          owner = _ref107.owner;

      return this.$publish('rm', { path: path, owner: owner });
    }
    /**
     * Creates a snapshot in a new folder
     *
     * Creates a new folder and then copies the given files inside
     * */

  }, {
    key: 'snapshot',
    value: function snapshot(_ref108) {
      var parents = _ref108.parents,
          folder = _ref108.folder,
          items = _ref108.items,
          flatten = _ref108.flatten,
          owner = _ref108.owner;

      return this.$publish('snapshot', {
        parents: parents,
        folder: folder,
        items: items,
        flatten: flatten,
        owner: owner
      });
    }
    /**
     * Returns information about a file
     *
     * Returns information about a single file.
     * The entry field will be null if the path does not exist
     * */

  }, {
    key: 'stat',
    value: function stat(_ref109) {
      var path = _ref109.path,
          owner = _ref109.owner;

      return this.$publish('stat', { path: path, owner: owner });
    }
    /**Updates a file's metadata*/

  }, {
    key: 'updateMeta',
    value: function updateMeta(_ref110) {
      var path = _ref110.path,
          metadataFiles = _ref110.metadataFiles,
          metadata = _ref110.metadata,
          owner = _ref110.owner;

      return this.$publish('updateMeta', {
        path: path,
        metadataFiles: metadataFiles,
        metadata: metadata,
        owner: owner
      });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Zpfs_s3compat service
     * @return {string}
     */
    get: function get$$1() {
      return 'zpfs_s3compat_0';
    }
  }]);
  return Zpfs_s3compat;
}(Service);
/**
 * User directory service
 *
 * User directory service
 * */
/**
 * User API for user information
 *
 * @access public
 * */
var Userdir = function (_Service25) {
  inherits(Userdir, _Service25);

  function Userdir() {
    classCallCheck(this, Userdir);
    return possibleConstructorReturn(this, (Userdir.__proto__ || Object.getPrototypeOf(Userdir)).apply(this, arguments));
  }

  createClass(Userdir, [{
    key: 'search',

    /**Searches for users matching the request*/
    value: function search(_ref111) {
      var requestId = _ref111.requestId,
          query = _ref111.query,
          page = _ref111.page;

      return this.$publish('search', { requestId: requestId, query: query, page: page });
    }
    /**Requests public data for the specified users*/

  }, {
    key: 'userInfo',
    value: function userInfo(_ref112) {
      var userKeys = _ref112.userKeys;

      return this.$publish('userInfo', { userKeys: userKeys });
    }
  }], [{
    key: 'DEFAULT_DEPLOYMENT_ID',

    /**
     * Get default deployment id associated to Userdir service
     * @return {string}
     */
    get: function get$$1() {
      return 'userdir_0';
    }
  }]);
  return Userdir;
}(Service);



var services = Object.freeze({
	Aggreg: Aggreg,
	Stack: Stack,
	Echo: Echo,
	Game: Game,
	GameEngine: GameEngine,
	Gda: Gda,
	Remoting: Remoting,
	GroupManagement: GroupManagement,
	Httpclient: Httpclient,
	MacroDebug: MacroDebug,
	Macro: Macro,
	Sendmail: Sendmail,
	Messaging: Messaging,
	Queue: Queue,
	Notif: Notif,
	Rdbms: Rdbms,
	Sms_ovh: Sms_ovh,
	Cron: Cron,
	Search: Search,
	Template: Template,
	Trigger: Trigger,
	Zpfs_s3: Zpfs_s3,
	Zpfs_hdfs: Zpfs_hdfs,
	Zpfs_s3compat: Zpfs_s3compat,
	Userdir: Userdir
});

/**
 * Match unsecure pattern web
 * @type {RegExp}
 */
var HTTP_PATTERN = /^http:\/\/|^\/\//;

/**
 * Http protocol
 * @type {string}
 */
var HTTP_PROTOCOL = 'http:';

/**
 * Https protocol
 * @type {string}
 */
var HTTPS_PROTOCOL = 'https:';

/**
 * Alpha numeric dictionary
 */
var DICTIONARY = 'abcdefghijklmnopqrstuvwxyz0123456789';

/**
 * Default ZetaPush API URL
 * @access private
 */
var API_URL = 'https://api.zpush.io/';

/**
 * Force ssl based protocol for network echange
 * Cross Env (Browser/Node) test
 * @access private
 * @type boolean
 */
var FORCE_HTTPS = typeof location === 'undefined' ? false : location.protocol === HTTPS_PROTOCOL;

/**
 * @access private
 * @param {string} apiUrl
 * @return {string}
 */
var normalizeApiUrl = function normalizeApiUrl(apiUrl) {
  var last = apiUrl.charAt(apiUrl.length - 1);
  var SLASH = '/';
  return last === SLASH ? apiUrl : apiUrl + SLASH;
};

/**
 * @access private
 * @param {Array<Object>} list
 * @return {Object}
 */
var shuffle = function shuffle(list) {
  var index = Math.floor(Math.random() * list.length);
  return list[index];
};

/**
 * @access private
 * @param {string} url
 * @param {boolean} forceHttps
 * @return {string}
 */
var getSecureUrl = function getSecureUrl(url, forceHttps) {
  return forceHttps ? url.replace(HTTP_PATTERN, HTTPS_PROTOCOL + '//') : url;
};

/**
 * @access private
 * @param {{apiUrl: string, sandboxId: string, forceHttps: boolean, transports: Transports}} parameters
 * @return {Promise}
 */
var getServers = function getServers(_ref) {
  var apiUrl = _ref.apiUrl,
      sandboxId = _ref.sandboxId,
      forceHttps = _ref.forceHttps,
      transports = _ref.transports;

  var normalizedSecuresApiUrl = normalizeApiUrl(getSecureUrl(apiUrl, forceHttps));
  var url = '' + normalizedSecuresApiUrl + sandboxId;
  var options = { protocol: forceHttps ? HTTPS_PROTOCOL : HTTP_PROTOCOL };
  return transports.fetch(url, options).then(function (response) {
    return response.json();
  })
  // TODO: Replace by a server side implementation when available
  .then(function (_ref2) {
    var servers = _ref2.servers;
    return servers.map(function (server) {
      return getSecureUrl(server, forceHttps);
    });
  });
};

/**
 * @access private
 * @param Class Derived
 * @param Class Parent
 * @return {boolean}
 */
var isDerivedOf = function isDerivedOf(Derived, Parent) {
  var prototype = Object.getPrototypeOf(Derived);
  var is = false;
  while (!(is || prototype === null)) {
    is = prototype === Parent;
    prototype = Object.getPrototypeOf(prototype);
  }
  return is;
};

/**
 * Get random id
 * @return {string}
 */
var uuid = function uuid() {
  var entropy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 7;
  var dictionary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DICTIONARY;
  return Array.from(Array(entropy)).reduce(function (previous) {
    var next = dictionary.charAt(Math.floor(Math.random() * dictionary.length));
    return '' + previous + next;
  }, '');
};

/**
 * CometD Messages enumeration
 * @type {Object}
 */
var Message = {
  RECONNECT_HANDSHAKE_VALUE: 'handshake',
  RECONNECT_NONE_VALUE: 'none',
  RECONNECT_RETRY_VALUE: 'retry'
};

/**
 * Delay to update server url
 * @type {integer}
 */
var UPDATE_SERVER_URL_DELAY = 250;

/**
 * Default macro channel
 * @type {string}
 */
var DEFAULT_MACRO_CHANNEL = 'completed';

/**
 * Provide utilities and abstraction on CometD Transport layer
 * @access private
 */
var ClientHelper = function () {
  /**
   * Create a new ZetaPush client helper
   */
  function ClientHelper(_ref) {
    var _this = this;

    var apiUrl = _ref.apiUrl,
        sandboxId = _ref.sandboxId,
        _ref$forceHttps = _ref.forceHttps,
        forceHttps = _ref$forceHttps === undefined ? false : _ref$forceHttps,
        authentication = _ref.authentication,
        _ref$resource = _ref.resource,
        resource = _ref$resource === undefined ? null : _ref$resource,
        _ref$transports = _ref.transports,
        transports = _ref$transports === undefined ? Transports$2 : _ref$transports;
    classCallCheck(this, ClientHelper);

    /**
     * @access private
     * @type {string}
     */
    this.sandboxId = sandboxId;
    /**
     * @access private
     * @type {function():AbstractHandshake}
     */
    this.authentication = authentication;
    /**
     * @access private
     * @type {string}
     */
    this.resource = resource;
    /**
     * @access private
     * @type {number}
     */
    this.requestId = 0;
    /**
     * @access private
     * @type {string}
     */
    this.userId = null;
    /**
     * @access private
     * @type {Object}
     */
    this.userInfo = null;
    /**
     * @access private
     * @type {string}
     */
    this.uniqId = uuid();
    /**
     * @access private
     * @type {Promise}
     */
    this.servers = getServers({
      apiUrl: apiUrl,
      sandboxId: sandboxId,
      forceHttps: forceHttps,
      transports: transports
    }).catch(function (error) {
      // Notify error in connection to server step
      _this.connectionToServerFail(error);
      // Return empty list
      return [];
    });
    /**
     * @access private
     * @type {Array<Object>}
     */
    this.connectionListeners = [];
    /**
     * @access private
     * @type {boolean}
     */
    this.connected = false;
    /**
     * @access private
     * @type {boolean}
     */
    this.wasConnected = false;
    /**
     * @access private
     * @type {string}
     */
    this.serverUrl = null;
    /**
     * @access private
     * @type {string}
     */
    this.sessionId = null;
    /**
     * @access private
     * @type {Array<Object>}
     */
    this.subscribeQueue = [];
    /**
     * @access private
     * @type {CometD}
     */
    this.cometd = new CometD$2();

    // Register transports layers
    transports.ALL.forEach(function (_ref2) {
      var type = _ref2.type,
          Transport = _ref2.Transport;

      _this.cometd.registerTransport(type, new Transport());
    });

    // Handle transport exception
    this.cometd.onTransportException = function (cometd, transport) {
      // Try to find an other available server
      // Remove the current one from the _serverList array
      _this.updateServerUrl();
    };

    this.cometd.addListener('/meta/handshake', function (_ref3) {
      var ext = _ref3.ext,
          successful = _ref3.successful,
          advice = _ref3.advice,
          error = _ref3.error;

      _this.cometd._debug('ClientHelper::/meta/handshake', {
        ext: ext,
        successful: successful,
        advice: advice,
        error: error
      });
      if (successful) {
        var _ext$authentication = ext.authentication,
            _authentication = _ext$authentication === undefined ? null : _ext$authentication;

        _this.initialized(_authentication);
      } else {
        _this.handshakeFailure(error);
      }
    });

    this.cometd.addListener('/meta/handshake', function (_ref4) {
      var advice = _ref4.advice,
          error = _ref4.error,
          ext = _ref4.ext,
          successful = _ref4.successful;

      _this.cometd._debug('ClientHelper::/meta/handshake', {
        ext: ext,
        successful: successful,
        advice: advice,
        error: error
      });
      // AuthNegotiation
      if (!successful) {
        if (typeof advice === 'undefined') {
          return;
        }
        if (Message.RECONNECT_NONE_VALUE === advice.reconnect) {
          _this.authenticationFailed(error);
        } else if (Message.RECONNECT_HANDSHAKE_VALUE === advice.reconnect) {
          _this.negotiationFailed(error);
        }
      }
    });

    this.cometd.addListener('/meta/connect', function (_ref5) {
      var advice = _ref5.advice,
          channel = _ref5.channel,
          successful = _ref5.successful;

      _this.cometd._debug('ClientHelper::/meta/connect', {
        advice: advice,
        channel: channel,
        successful: successful
      });
      // ConnectionListener
      if (_this.cometd.isDisconnected()) {
        _this.connected = false;
        // Notify connection will close
        _this.connectionWillClose();
      } else {
        _this.wasConnected = _this.connected;
        _this.connected = successful;
        if (!_this.wasConnected && _this.connected) {
          _this.cometd.batch(_this, function () {
            // Unqueue subscriptions
            _this.subscribeQueue.forEach(function (_ref6) {
              var prefix = _ref6.prefix,
                  listener = _ref6.listener,
                  subscriptions = _ref6.subscriptions;

              _this.subscribe(prefix, listener, subscriptions);
            });
          });
          // Notify connection is established
          _this.connectionEstablished();
        } else if (_this.wasConnected && !_this.connected) {
          // Notify connection is broken
          _this.connectionBroken();
        }
      }
    });

    this.cometd.addListener('/meta/disconnect', function (_ref7) {
      var channel = _ref7.channel,
          successful = _ref7.successful;

      _this.cometd._debug('ClientHelper::/meta/disconnect', {
        channel: channel,
        successful: successful
      });
      if (_this.cometd.isDisconnected()) {
        _this.connected = false;
        // Notify connection is closed
        _this.connectionClosed();
      }
    });
  }
  /**
   * Add a connection listener to handle life cycle connection events
   * @param {ConnectionStatusListener} listener
   * @return {number} handler
   */


  createClass(ClientHelper, [{
    key: 'addConnectionStatusListener',
    value: function addConnectionStatusListener(listener) {
      this.connectionListeners.push({
        enabled: true,
        listener: Object.assign(new ConnectionStatusListener(), listener)
      });
      return this.connectionListeners.length - 1;
    }
    /**
     * Notify listeners when handshake step succeed
     */

  }, {
    key: 'authenticationFailed',
    value: function authenticationFailed(error) {
      this.userId = null;
      this.userInfo = null;
      this.connectionListeners.filter(function (_ref8) {
        var enabled = _ref8.enabled;
        return enabled;
      }).forEach(function (_ref9) {
        var listener = _ref9.listener;

        listener.onFailedHandshake(error);
      });
    }
    /**
     * Connect client using CometD Transport
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      this.servers.then(function (servers) {
        if (servers.length > 0) {
          // Get a random server url
          _this2.serverUrl = shuffle(servers);
          // Configure CometD
          _this2.cometd.configure({
            url: _this2.serverUrl + '/strd',
            backoffIncrement: 1000,
            maxBackoff: 60000,
            appendMessageTypeToURL: false
          });
          // Send handshake fields
          _this2.cometd.handshake(_this2.getHandshakeFields());
        } else {
          // No servers available
          _this2.noServerUrlAvailable();
        }
      });
    }
    /**
     * Notify listeners when connection is broken
     */

  }, {
    key: 'connectionBroken',
    value: function connectionBroken() {
      this.connectionListeners.filter(function (_ref10) {
        var enabled = _ref10.enabled;
        return enabled;
      }).forEach(function (_ref11) {
        var listener = _ref11.listener;

        listener.onConnectionBroken();
      });
    }
    /**
     * Notify listeners when connection is closed
     */

  }, {
    key: 'connectionClosed',
    value: function connectionClosed() {
      this.userId = null;
      this.userInfo = null;
      this.connectionListeners.filter(function (_ref12) {
        var enabled = _ref12.enabled;
        return enabled;
      }).forEach(function (_ref13) {
        var listener = _ref13.listener;

        listener.onConnectionClosed();
      });
    }
    /**
     * Notify listeners when connection is established
     */

  }, {
    key: 'connectionEstablished',
    value: function connectionEstablished() {
      this.connectionListeners.filter(function (_ref14) {
        var enabled = _ref14.enabled;
        return enabled;
      }).forEach(function (_ref15) {
        var listener = _ref15.listener;

        listener.onConnectionEstablished();
      });
    }
    /**
     * Notify listeners when connection to server fail
     */

  }, {
    key: 'connectionToServerFail',
    value: function connectionToServerFail(failure) {
      this.connectionListeners.filter(function (_ref16) {
        var enabled = _ref16.enabled;
        return enabled;
      }).forEach(function (_ref17) {
        var listener = _ref17.listener;

        listener.onConnectionToServerFail(failure);
      });
    }
    /**
     * Notify listeners when connection will close
     */

  }, {
    key: 'connectionWillClose',
    value: function connectionWillClose() {
      this.connectionListeners.filter(function (_ref18) {
        var enabled = _ref18.enabled;
        return enabled;
      }).forEach(function (_ref19) {
        var listener = _ref19.listener;

        listener.onConnectionWillClose();
      });
    }
    /**
     * Create a promise based macro service
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     */

  }, {
    key: 'createAsyncMacroService',
    value: function createAsyncMacroService(_ref20) {
      var listener = _ref20.listener,
          Type = _ref20.Type,
          _ref20$deploymentId = _ref20.deploymentId,
          deploymentId = _ref20$deploymentId === undefined ? Type.DEFAULT_DEPLOYMENT_ID : _ref20$deploymentId;

      var prefix = '/service/' + this.getSandboxId() + '/' + deploymentId;
      var $publish = this.getAsyncMacroPublisher(prefix);
      // Create service by publisher
      return this.createServiceByPublisher({
        listener: listener,
        prefix: prefix,
        Type: Type,
        $publish: $publish
      });
    }

    /**
     * Create a promise based task service
     * @experimental
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     */

  }, {
    key: 'createAsyncTaskService',
    value: function createAsyncTaskService(_ref21) {
      var Type = _ref21.Type,
          _ref21$deploymentId = _ref21.deploymentId,
          deploymentId = _ref21$deploymentId === undefined ? Type.DEFAULT_DEPLOYMENT_ID : _ref21$deploymentId;

      var prefix = '/service/' + this.getSandboxId() + '/' + deploymentId;
      var $publish = this.getAsyncTaskPublisher(prefix);
      // Create service by publisher
      return this.createServiceByPublisher({
        listener: {},
        prefix: prefix,
        Type: Type,
        $publish: $publish
      });
    }
    /**
     * Create a publish/subscribe service
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     */

  }, {
    key: 'createService',
    value: function createService(_ref22) {
      var listener = _ref22.listener,
          Type = _ref22.Type,
          _ref22$deploymentId = _ref22.deploymentId,
          deploymentId = _ref22$deploymentId === undefined ? Type.DEFAULT_DEPLOYMENT_ID : _ref22$deploymentId;

      var isMacroType = isDerivedOf(Type, Macro);
      var prefix = '/service/' + this.getSandboxId() + '/' + deploymentId;
      var $publish = isMacroType ? this.getMacroPublisher(prefix) : this.getServicePublisher(prefix);
      // Create service by publisher
      return this.createServiceByPublisher({
        listener: listener,
        prefix: prefix,
        Type: Type,
        $publish: $publish
      });
    }
    /**
     * @param {{listener: Object, prefix: string, Type: class, $publish: Function}} parameters
     * @return {Object} service
     */

  }, {
    key: 'createServiceByPublisher',
    value: function createServiceByPublisher(_ref23) {
      var listener = _ref23.listener,
          prefix = _ref23.prefix,
          Type = _ref23.Type,
          $publish = _ref23.$publish;

      var service = new Type({
        $publish: $publish
      });
      // Store subscription in service instance
      service.$subscriptions = this.subscribe(prefix, listener);
      return service;
    }
    /**
     * Disconnect CometD client
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      this.cometd.disconnect(true);
    }
    /**
     * Get a publisher for a macro service that return a promise
     * @param {string} prefix - Channel prefix
     * @return {Function} publisher
     */

  }, {
    key: 'getAsyncMacroPublisher',
    value: function getAsyncMacroPublisher(prefix) {
      var _this3 = this;

      return function (name, parameters) {
        var hardFail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        var channel = prefix + '/call';
        var uniqRequestId = _this3.getUniqRequestId();
        var subscriptions = {};
        return new Promise(function (resolve, reject) {
          var _listener;

          var handler = function handler(_ref24) {
            var _ref24$data = _ref24.data,
                data = _ref24$data === undefined ? {} : _ref24$data;
            var _data$result = data.result,
                result = _data$result === undefined ? {} : _data$result,
                _data$errors = data.errors,
                errors = _data$errors === undefined ? [] : _data$errors,
                requestId = data.requestId;

            if (requestId === uniqRequestId) {
              // Handle errors
              if (errors.length > 0) {
                reject(errors);
              } else {
                resolve(result);
              }
              _this3.unsubscribe(subscriptions);
            }
          };
          // Create dynamic listener method
          var listener = (_listener = {}, defineProperty(_listener, name, handler), defineProperty(_listener, DEFAULT_MACRO_CHANNEL, handler), _listener);
          // Ad-Hoc subscription
          _this3.subscribe(prefix, listener, subscriptions);
          // Publish message on channel
          _this3.publish(channel, {
            debug: debug,
            hardFail: hardFail,
            name: name,
            parameters: parameters,
            requestId: uniqRequestId
          });
        });
      };
    }

    /**
     * Get a publisher for a task service that return a promise
     * @experimental
     * @param {string} prefix - Channel prefix
     * @return {Function} publisher
     */

  }, {
    key: 'getAsyncTaskPublisher',
    value: function getAsyncTaskPublisher(prefix) {
      var _this4 = this;

      var DEFAULT_TASK_CHANNEL = 'call';
      return function (name) {
        var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var channel = prefix + '/' + DEFAULT_TASK_CHANNEL;
        var uniqRequestId = _this4.getUniqRequestId();
        var subscriptions = {};
        return new Promise(function (resolve, reject) {
          var handler = function handler(_ref25) {
            var _ref25$data = _ref25.data,
                data = _ref25$data === undefined ? {} : _ref25$data;
            var _data$result2 = data.result,
                result = _data$result2 === undefined ? {} : _data$result2,
                success = data.success,
                requestId = data.requestId;

            if (requestId === uniqRequestId) {
              // Handle errors
              if (success) {
                resolve(result);
              } else {
                reject(result);
              }
              _this4.unsubscribe(subscriptions);
            }
          };
          // Create dynamic listener method
          var listener = defineProperty({}, DEFAULT_TASK_CHANNEL, handler);
          // Ad-Hoc subscription
          _this4.subscribe(prefix, listener, subscriptions);
          // Publish message on channel
          _this4.publish(channel, {
            data: {
              name: name,
              namespace: namespace,
              parameters: parameters
            },
            requestId: uniqRequestId
          });
        });
      };
    }
    /**
     * Get client id
     * @return {string} clientId
     */

  }, {
    key: 'getClientId',
    value: function getClientId() {
      return this.cometd.getClientId();
    }
    /**
     * Get CometD handshake parameters
     * @return {Object}
     */

  }, {
    key: 'getHandshakeFields',
    value: function getHandshakeFields() {
      var handshake = this.authentication();
      return handshake.getHandshakeFields(this);
    }
    /**
     * Get a publisher for a macro service
     * @param {string} prefix - Channel prefix
     * @return {Function} publisher
     */

  }, {
    key: 'getMacroPublisher',
    value: function getMacroPublisher(prefix) {
      var _this5 = this;

      return function (name, parameters) {
        var hardFail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        var channel = prefix + '/call';
        var requestId = _this5.getUniqRequestId();
        return _this5.publish(channel, {
          debug: debug,
          hardFail: hardFail,
          name: name,
          parameters: parameters,
          requestId: requestId
        });
      };
    }
    /**
     * Get queued subscription index
     * @return {Object} index
     */

  }, {
    key: 'getQueuedSubscription',
    value: function getQueuedSubscription() {
      var subscriptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var index = this.subscribeQueue.findIndex(function (element) {
        return subscriptions === element.subscriptions;
      });
      return {
        index: index,
        queued: index > -1
      };
    }
    /**
     * Get resource
     * @return {string}
     */

  }, {
    key: 'getResource',
    value: function getResource() {
      return this.resource;
    }
    /**
     * Get sandbox id
     * @return {string}
     */

  }, {
    key: 'getSandboxId',
    value: function getSandboxId() {
      return this.sandboxId;
    }
    /**
     * Get server urls list
     * @return {Promise} servers
     */

  }, {
    key: 'getServers',
    value: function getServers$$1() {
      return this.servers;
    }
    /**
     * Get a publisher for a service
     * @param {string} prefix - Channel prefix
     * @return {Function} publisher
     */

  }, {
    key: 'getServicePublisher',
    value: function getServicePublisher(prefix) {
      var _this6 = this;

      return function (method, parameters) {
        var channel = prefix + '/' + method;
        return _this6.publish(channel, parameters);
      };
    }
    /**
     * Get uniq request id
     * @return {string}
     */

  }, {
    key: 'getUniqRequestId',
    value: function getUniqRequestId() {
      return this.getClientId() + ':' + this.uniqId + ':' + ++this.requestId;
    }
    /**
     * Get user id
     * @return {string}
     */

  }, {
    key: 'getUserId',
    value: function getUserId() {
      return this.userId;
    }
    /**
     * Get user info
     * @return {Objet}
     */

  }, {
    key: 'getUserInfo',
    value: function getUserInfo() {
      return this.userInfo;
    }
    /**
     * Manage handshake failure case
     */

  }, {
    key: 'handshakeFailure',
    value: function handshakeFailure() {
      this.userId = null;
      this.userInfo = null;
    }
    /**
     * Notify listeners when connection is established
     */

  }, {
    key: 'initialized',
    value: function initialized(authentication) {
      if (authentication) {
        this.userId = authentication.userId;
        this.userInfo = authentication.userInfo;
      }
      this.connectionListeners.filter(function (_ref26) {
        var enabled = _ref26.enabled;
        return enabled;
      }).forEach(function (_ref27) {
        var listener = _ref27.listener;

        listener.onSuccessfulHandshake(authentication);
      });
    }
    /**
     * Is client connected to ZetaPush
     * @return {boolean}
     */

  }, {
    key: 'isConnected',
    value: function isConnected() {
      return !this.cometd.isDisconnected();
    }
    /**
     * Notify listeners when a message is lost
     */

  }, {
    key: 'messageLost',
    value: function messageLost(channel, data) {
      this.connectionListeners.filter(function (_ref28) {
        var enabled = _ref28.enabled;
        return enabled;
      }).forEach(function (_ref29) {
        var listener = _ref29.listener;

        listener.onMessageLost(channel, data);
      });
    }
    /**
     * Negociate authentication
     * @param {error} error
     */

  }, {
    key: 'negotiationFailed',
    value: function negotiationFailed(error) {
      this.connectionListeners.filter(function (_ref30) {
        var enabled = _ref30.enabled;
        return enabled;
      }).forEach(function (_ref31) {
        var listener = _ref31.listener;

        listener.onNegotiationFailed(error);
      });
    }
    /**
     * Notify listeners when no server url available
     */

  }, {
    key: 'noServerUrlAvailable',
    value: function noServerUrlAvailable() {
      this.connectionListeners.filter(function (_ref32) {
        var enabled = _ref32.enabled;
        return enabled;
      }).forEach(function (_ref33) {
        var listener = _ref33.listener;

        listener.onNoServerUrlAvailable();
      });
    }
    /**
     * Wrap CometdD publish method
     * @param {String} channel
     * @param {Object} parameters
     * @return {Object}
     */

  }, {
    key: 'publish',
    value: function publish(channel) {
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.cometd.publish(channel, parameters);
      return {
        channel: channel,
        parameters: parameters
      };
    }
    /**
     * Remove a connection status listener
     */

  }, {
    key: 'removeConnectionStatusListener',
    value: function removeConnectionStatusListener(handler) {
      var listener = this.connectionListeners[handler];
      if (listener) {
        listener.enabled = false;
      }
    }
    /**
     * Set a new authentication methods
     * @param {function():AbstractHandshake} authentication
     */

  }, {
    key: 'setAuthentication',
    value: function setAuthentication(authentication) {
      this.authentication = authentication;
    }
    /**
     * Set logging level for CometD client
     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
     * less verbose to more verbose.
     * @param {string} level
     */

  }, {
    key: 'setLogLevel',
    value: function setLogLevel(level) {
      this.cometd.setLogLevel(level);
    }
    /**
     * Subsribe all methods defined in the listener for the given prefixed channel
     * @param {string} prefix - Channel prefix
     * @param {Object} listener
     * @param {Object} subscriptions
     * @return {Object} subscriptions
     */

  }, {
    key: 'subscribe',
    value: function subscribe(prefix) {
      var listener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var subscriptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _getQueuedSubscriptio = this.getQueuedSubscription(subscriptions),
          queued = _getQueuedSubscriptio.queued;

      if (!queued) {
        // Store arguments to renew subscriptions on connection
        this.subscribeQueue.push({
          prefix: prefix,
          listener: listener,
          subscriptions: subscriptions
        });
      }
      // Subscribe if user is connected
      if (!this.cometd.isDisconnected()) {
        for (var method in listener) {
          if (listener.hasOwnProperty(method)) {
            if (subscriptions[method] === void 0) {
              var channel = prefix + '/' + method;
              subscriptions[method] = this.cometd.subscribe(channel, listener[method]);
            }
          }
        }
      }
      return subscriptions;
    }
    /**
     * Remove current server url from the server list and shuffle for another one
     */

  }, {
    key: 'updateServerUrl',
    value: function updateServerUrl() {
      var _this7 = this;

      this.servers.then(function (servers) {
        var index = servers.indexOf(_this7.serverUrl);
        if (index > -1) {
          servers.splice(index, 1);
        }
        if (servers.length === 0) {
          // No more server available
          _this7.noServerUrlAvailable();
        } else {
          _this7.serverUrl = shuffle(servers);
          _this7.cometd.configure({
            url: _this7.serverUrl + '/strd'
          });
          setTimeout(function () {
            _this7.cometd.handshake(_this7.getHandshakeFields());
          }, UPDATE_SERVER_URL_DELAY);
        }
      });
    }
    /**
     * Remove all subscriptions
     * @param {Object} subscriptions
     */

  }, {
    key: 'unsubscribe',
    value: function unsubscribe() {
      var subscriptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Unsubscribe
      for (var method in subscriptions) {
        if (subscriptions.hasOwnProperty(method)) {
          var subscription = subscriptions[method];
          this.cometd.unsubscribe(subscription);
        }
      }
      // Remove subscription from queue

      var _getQueuedSubscriptio2 = this.getQueuedSubscription(subscriptions),
          index = _getQueuedSubscriptio2.index,
          queued = _getQueuedSubscriptio2.queued;

      if (queued) {
        this.subscribeQueue.splice(index, 1);
      }
    }
  }]);
  return ClientHelper;
}();

/**
 * Client config object.
 * @typedef {Object} ClientConfig
 * @property {string} apiUrl - Api Url
 * @property {string} sandboxId - Sandbox id
 * @property {boolean} forceHttps - Force end to end HTTPS connection
 * @property {function():AbstractHandshake} authentication - Return authentication properties
 * @property {string} resource - Client resource id
 * @property {Transports} transports - Client transports implementation
 */

/**
 * ZetaPush Client to connect
 * @access public
 * @example
 * // Securized client with token based connection
 * const client = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.weak({
 *       token: null
 *    })
 *   }
 * })
 * @example
 * // Client with authentication based connection
 * const client = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.simple({
 *       login: '<USER-LOGIN>',
 *       password: '<USER-PASSWORD>'
 *    })
 *   }
 * })
 * @example
 * // Explicit deploymentId
 * const clientSimple = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.simple({
 *       deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',
 *       login: '<USER-LOGIN>',
 *       password: '<USER-PASSWORD>'
 *    })
 *   }
 * })
 * const clientWeak = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.weak({
 *       deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',
 *       token: '<SESSION-TOKEN>'
 *    })
 *   }
 * })
 */
var Client = function () {
  /**
   * Create a new ZetaPush Client
   * @param {ClientConfig} config
   */
  function Client(_ref) {
    var _ref$apiUrl = _ref.apiUrl,
        apiUrl = _ref$apiUrl === undefined ? API_URL : _ref$apiUrl,
        sandboxId = _ref.sandboxId,
        _ref$forceHttps = _ref.forceHttps,
        forceHttps = _ref$forceHttps === undefined ? FORCE_HTTPS : _ref$forceHttps,
        authentication = _ref.authentication,
        resource = _ref.resource,
        transports = _ref.transports;
    classCallCheck(this, Client);

    /**
     * @access private
     * @type {ClientHelper}
     */
    this.helper = new ClientHelper({
      apiUrl: apiUrl,
      sandboxId: sandboxId,
      forceHttps: forceHttps,
      authentication: authentication,
      resource: resource,
      transports: transports
    });
  }
  /**
   * Add a connection listener to handle life cycle connection events
   * @param {ConnectionStatusListener} listener
   * @return {number} handler
   */


  createClass(Client, [{
    key: 'addConnectionStatusListener',
    value: function addConnectionStatusListener(listener) {
      return this.helper.addConnectionStatusListener(listener);
    }
    /**
     * Safely connect client to ZetaPush
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this = this;

      if (this.isConnected()) {
        var handler = this.addConnectionStatusListener({
          onConnectionClosed: function onConnectionClosed() {
            _this.removeConnectionStatusListener(handler);
            _this.helper.connect();
          }
        });
        this.disconnect();
      } else {
        this.helper.connect();
      }
    }
    /**
     * Create a promise based macro service instance
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     * @example
     * const api = client.createAsyncMacroService({
     *   Type: WelcomeMacro
     * })
     * api.welcome({
     *   message: Hello'
     * }).then(({ message }) => {
     *   console.log(message)
     * })
     */

  }, {
    key: 'createAsyncMacroService',
    value: function createAsyncMacroService(_ref2) {
      var deploymentId = _ref2.deploymentId,
          listener = _ref2.listener,
          Type = _ref2.Type;

      return this.helper.createAsyncMacroService({
        deploymentId: deploymentId,
        listener: listener,
        Type: Type
      });
    }
    /**
     * Create a promise based task service instance
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     * @example
     * const api = client.createAsyncMacroService({
     *   Type: WelcomeMacro
     * })
     * api.welcome({
     *   message: Hello'
     * }).then(({ message }) => {
     *   console.log(message)
     * })
     */

  }, {
    key: 'createAsyncTaskService',
    value: function createAsyncTaskService(_ref3) {
      var deploymentId = _ref3.deploymentId,
          Type = _ref3.Type;

      return this.helper.createAsyncTaskService({
        deploymentId: deploymentId,
        Type: Type
      });
    }
    /**
     * Create a publish/subscribe for a service type
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     * @example
     * const service = client.createService({
     *   listener: {
     *     list(message) {
     *       console.log('Stack list callback', message)
     *     },
     *     push(message) {
     *       console.log('Stack push callback', message)
     *     }
     *   },
     *   Type: ZetaPush.services.Stack
     * })
     * service.list({
     *   stack: '<STACK-ID>'
     * })
     * @example
     * // Explicit deploymentId
     * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`
     * const service = client.createService({
     *   deploymentId: 'stack_0'
     *   listener: {
     *     list(message) {
     *       console.log('Stack list callback', message)
     *     },
     *     push(message) {
     *       console.log('Stack push callback', message)
     *     }
     *   },
     *   Type: ZetaPush.services.Stack
     * })
     * service.list({
     *   stack: '<STACK-ID>'
     * })
     */

  }, {
    key: 'createService',
    value: function createService(_ref4) {
      var deploymentId = _ref4.deploymentId,
          listener = _ref4.listener,
          Type = _ref4.Type;

      return this.helper.createService({
        deploymentId: deploymentId,
        listener: listener,
        Type: Type
      });
    }
    /**
     * Disonnect client from ZetaPush
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (this.isConnected()) {
        this.helper.disconnect();
      }
    }
    /**
     * Is client connected to ZetaPush
     * @return {boolean}
     */

  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this.helper.isConnected();
    }
    /**
     * Get the client sandbox id
     * @return {string}
     */

  }, {
    key: 'getSandboxId',
    value: function getSandboxId() {
      return this.helper.getSandboxId();
    }
    /**
     * Get the client resource
     * @return {string}
     */

  }, {
    key: 'getResource',
    value: function getResource() {
      return this.helper.getResource();
    }
    /**
     * Get server urls list
     * @return {Promise} servers
     */

  }, {
    key: 'getServers',
    value: function getServers$$1() {
      return this.helper.getServers();
    }
    /**
     * Get the client user id
     * @return {string}
     */

  }, {
    key: 'getUserId',
    value: function getUserId() {
      return this.helper.getUserId();
    }
    /*
     * Get the client user info
     * @return {Object}
     * @example
     * // Create new ZetaPush Client
     * const client = new Client({
     *   sandboxId: '<YOUR-SANDBOX-ID>',
     *   authentication: () => Authentication.simple({
     *     login: '<YOUR-USER-LOGIN>',
     *     password: '<YOUR-USER-PASSWORD>'
     *   })
     * })
     * // Add connection establised listener
     * client.onConnectionEstablished(() => {
     *   console.log('onConnectionEstablished')
     *   const profile = client.getUserInfo()
     *   console.log('Your profile', profile)
     * })
     * client.connect()
     */

  }, {
    key: 'getUserInfo',
    value: function getUserInfo() {
      return this.helper.getUserInfo();
    }
    /**
     * Remove a connection status listener
     * @param {number} handler
     */

  }, {
    key: 'removeConnectionStatusListener',
    value: function removeConnectionStatusListener(handler) {
      return this.helper.removeConnectionStatusListener(handler);
    }
    /**
     * Set a new authentication methods
     * @param {function():AbstractHandshake} authentication
     */

  }, {
    key: 'setAuthentication',
    value: function setAuthentication(authentication) {
      this.helper.setAuthentication(authentication);
    }
    /**
     * Set logging level
     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
     * less verbose to more verbose.
     * @param {string} level
     */

  }, {
    key: 'setLogLevel',
    value: function setLogLevel(level) {
      this.helper.setLogLevel(level);
    }
    /**
     * Set new client resource value
     * @param {string} resource
     */

  }, {
    key: 'setResource',
    value: function setResource(resource) {
      this.helper.setResource(resource);
    }
    /**
     * Remove all subscriptions
     * @param {Object} service
     */

  }, {
    key: 'unsubscribe',
    value: function unsubscribe(service) {
      if (!service.$subscriptions) {
        throw new TypeError('Missing $subscriptions property in service');
      }
      return this.helper.unsubscribe(service.$subscriptions);
    }
  }]);
  return Client;
}();

/**
 * Add shorthand connection status method
 */
Object.getOwnPropertyNames(ConnectionStatusListener.prototype).forEach(function (method) {
  // Only implements unsupported methods
  if (!Client.prototype.hasOwnProperty(method)) {
    Client.prototype[method] = function addListener(listener) {
      return this.addConnectionStatusListener(defineProperty({}, method, listener));
    };
  }
});

/**
 * Provide fallback for DOMStorage
 * @access protected
 */
var MemoryStorage = function () {
  function MemoryStorage() {
    classCallCheck(this, MemoryStorage);

    this._map = new Map();
  }

  createClass(MemoryStorage, [{
    key: 'getItem',
    value: function getItem(key) {
      return this._map.get(key);
    }
  }, {
    key: 'setItem',
    value: function setItem(key, value) {
      return this._map.get(key);
    }
  }, {
    key: 'removeItem',
    value: function removeItem(key) {
      this._map.delete(key);
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._map = new Map();
    }
  }, {
    key: 'key',
    value: function key(n) {
      return Array.from(this._map.keys())[n];
    }
  }, {
    key: 'length',
    get: function get$$1() {
      return this._map.size;
    }
  }]);
  return MemoryStorage;
}();

/**
 * @type {Storage}
 * @access protected
 */


var platformStorage = typeof localStorage === 'undefined' ? new MemoryStorage() : localStorage;

/**
 * @type {string}
 */
var ZETAPUSH_SESSION_KEY = 'zetapush.token';

/**
 * Provide abstraction for token persistence
 * @access protected
 */
var SessionPersistenceStrategy = function () {
  /**
   * @param {{sandboxId: string, storage: DOMStorage}} parameters
   */
  function SessionPersistenceStrategy() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        sandboxId = _ref.sandboxId,
        _ref$storage = _ref.storage,
        storage = _ref$storage === undefined ? platformStorage : _ref$storage;

    classCallCheck(this, SessionPersistenceStrategy);

    /**
     * @access private
     * @type {string}
     */
    this.key = ZETAPUSH_SESSION_KEY + '.' + sandboxId;
    /**
     * @access private
     * @type {DOMStorage}
     */
    this.storage = storage;
  }
  /**
   * @return {string} session The stored session
   */


  createClass(SessionPersistenceStrategy, [{
    key: 'get',
    value: function get$$1() {
      var key = this.key,
          storage = this.storage;

      var json = storage.getItem(key) || '{}';
      var session = {};
      try {
        session = JSON.parse(json);
      } catch (e) {}
      return session;
    }
    /**
     * @param {Object} session The session to store
     */

  }, {
    key: 'set',
    value: function set$$1() {
      var session = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var key = this.key,
          storage = this.storage;

      var json = JSON.stringify(session);
      try {
        storage.setItem(key, json);
      } catch (e) {}
      return session;
    }
  }]);
  return SessionPersistenceStrategy;
}();

/**
 * SmartClient deployment infos.
 * @typedef {Object} SmartClientDeployment
 * @property {string} simple - Simple deployment id
 * @property {string} weak - Weak deployment id
 */

/**
 * SmartClient config object.
 * @typedef {Object} SmartClientConfig
 * @property {string} apiUrl - Api Url
 * @property {SmartClientDeployment} deployment - Deployment infos
 * @property {string} sandboxId - Sandbox id
 * @property {boolean} forceHttps - Force end to end HTTPS connection
 * @property {string} resource - Client resource id
 * @property {Array} transports - Client transports list
 */

/**
 * @access public
 * @extends {Client}
 * @example
 * // Create a new WeakClient
 * const client = new ZetaPush.SmartClient({
 *   sandboxId: '<YOUR-SANDBOX-ID>'
 * })
 */
var SmartClient = function (_Client) {
  inherits(SmartClient, _Client);

  /**
   * Create a new ZetaPush SmartClient
   * @param {SmartClientConfig} config
   */
  function SmartClient(_ref) {
    var apiUrl = _ref.apiUrl,
        deployment = _ref.deployment,
        sandboxId = _ref.sandboxId,
        forceHttps = _ref.forceHttps,
        resource = _ref.resource,
        transports = _ref.transports;
    classCallCheck(this, SmartClient);

    var persistence = new SessionPersistenceStrategy({ sandboxId: sandboxId });

    /**
     * @return {AbstractHandshakeManager}
     */
    var authentication = function authentication() {
      var session = persistence.get();
      var token = session.token;


      if (_this.hasCredentials()) {
        var _this$getCredentials = _this.getCredentials(),
            login = _this$getCredentials.login,
            password = _this$getCredentials.password;

        _this.setCredentials({});
        return Authentication.simple({
          login: login,
          password: password,
          deploymentId: deployment && deployment.simple
        });
      } else {
        if (_this.isStronglyAuthenticated(session)) {
          return Authentication.simple({
            login: token,
            password: null,
            deploymentId: deployment && deployment.simple
          });
        } else {
          return Authentication.weak({
            token: token,
            deploymentId: deployment && deployment.weak
          });
        }
      }
    };
    // Initialize base client

    /**
     * @access protected
     * @type {SessionPersistenceStrategy}
     */
    var _this = possibleConstructorReturn(this, (SmartClient.__proto__ || Object.getPrototypeOf(SmartClient)).call(this, {
      apiUrl: apiUrl,
      sandboxId: sandboxId,
      authentication: authentication,
      forceHttps: forceHttps,
      resource: resource,
      transports: transports
    }));

    _this.persistence = persistence;
    /**
     * @access protected
     * @type {Object}
     */
    _this.credentials = {};
    /**
     * Handle connection lifecycle events
     * @access protected
     * @type {Object}
     */
    _this.lifeCycleConnectionHandler = _this.addConnectionStatusListener({
      onConnectionClosed: function onConnectionClosed() {
        persistence.set({});
      },
      onSuccessfulHandshake: function onSuccessfulHandshake(session) {
        if (session.token) {
          persistence.set(session);
        }
      }
    });
    // Properly disconnect client to avoir ghost connections
    /*
    window.addEventListener('beforeunload', () => {
      this.removeConnectionStatusListener(this.lifeCycleConnectionHandler)
      super.disconnect()
    })
    */
    return _this;
  }
  /**
   * Disconnect client from ZetaPush backend
   */


  createClass(SmartClient, [{
    key: 'disconnect',
    value: function disconnect() {
      get(SmartClient.prototype.__proto__ || Object.getPrototypeOf(SmartClient.prototype), 'disconnect', this).call(this);
    }
    /**
     * @return {Object}
     */

  }, {
    key: 'getCredentials',
    value: function getCredentials() {
      return this.credentials;
    }
    /**
     * @return {Object}
     */

  }, {
    key: 'getSession',
    value: function getSession() {
      return this.persistence.get();
    }
    /**
     * @return {boolean}
     */

  }, {
    key: 'hasCredentials',
    value: function hasCredentials() {
      var _getCredentials = this.getCredentials(),
          login = _getCredentials.login,
          password = _getCredentials.password;

      return login && password;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: 'isStronglyAuthenticated',
    value: function isStronglyAuthenticated() {
      var session = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.persistence.get();

      return !this.isWeaklyAuthenticated(session) && typeof session.token === 'string';
    }
    /**
     * @return {boolean}
     */

  }, {
    key: 'isWeaklyAuthenticated',
    value: function isWeaklyAuthenticated() {
      var session = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.persistence.get();

      return typeof session.publicToken === 'string';
    }
    /**
     * @param {{login: string, password: string}} parameters
     */

  }, {
    key: 'setCredentials',
    value: function setCredentials(_ref2) {
      var login = _ref2.login,
          password = _ref2.password;

      this.credentials = { login: login, password: password };
    }
  }]);
  return SmartClient;
}(Client);

/**
 * WeakClient config object.
 * @typedef {Object} WeakClientConfig
 * @property {string} apiUrl - Api Url
 * @property {string} deploymentId - Authentication deployment id, default value is 'weak_0'
 * @property {string} sandboxId - Sandbox id
 * @property {boolean} forceHttps - Force end to end HTTPS connection
 * @property {string} resource - Client resource id
 * @property {Array} transports - Client transports list
 */

/**
 * @access public
 * @extends {Client}
 * @example
 * // Create a new WeakClient
 * const client = new ZetaPush.WeakClient({
 *   sandboxId: '<YOUR-SANDBOX-ID>'
 * })
 * @example
 * // Explicit deploymentId
 * // WeakClient provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`
 * // deploymentId default value is weak_0
 * const client = new ZetaPush.WeakClient({
 *   deploymentId: 'weak_0',
 *   sandboxId: '<YOUR-SANDBOX-ID>'
 * })
 */
var WeakClient = function (_Client) {
  inherits(WeakClient, _Client);

  /**
   * Create a new ZetaPush WeakClient
   * @param {WeakClientConfig} config
   */
  function WeakClient(_ref) {
    var apiUrl = _ref.apiUrl,
        sandboxId = _ref.sandboxId,
        deploymentId = _ref.deploymentId,
        forceHttps = _ref.forceHttps,
        resource = _ref.resource,
        transports = _ref.transports;
    classCallCheck(this, WeakClient);

    var authentication = function authentication() {
      var token = _this.getToken();
      var handshake = Authentication.weak({
        deploymentId: deploymentId,
        token: token
      });
      return handshake;
    };
    /**
     * Call Client constructor with specific parameters
     */

    // Handle successful handshake
    var _this = possibleConstructorReturn(this, (WeakClient.__proto__ || Object.getPrototypeOf(WeakClient)).call(this, {
      apiUrl: apiUrl,
      sandboxId: sandboxId,
      forceHttps: forceHttps,
      authentication: authentication,
      resource: resource,
      transports: transports
    }));

    var onSuccessfulHandshake = function onSuccessfulHandshake(_ref2) {
      var publicToken = _ref2.publicToken,
          userId = _ref2.userId,
          token = _ref2.token;

      if (token) {
        _this.strategy.set({ publicToken: publicToken, userId: userId, token: token });
      }
    };
    _this.addConnectionStatusListener({ onSuccessfulHandshake: onSuccessfulHandshake });
    /**
     * @access private
     * @type {SessionPersistenceStrategy}
     */
    _this.strategy = new SessionPersistenceStrategy({ sandboxId: sandboxId });
    return _this;
  }
  /**
   * @return {string} The stored token
   */


  createClass(WeakClient, [{
    key: 'getToken',
    value: function getToken() {
      var _strategy$get = this.strategy.get(),
          token = _strategy$get.token;

      return token;
    }
  }]);
  return WeakClient;
}(Client);

var ServerClient = function (_Client) {
  inherits(ServerClient, _Client);

  function ServerClient(_ref) {
    var apiUrl = _ref.apiUrl,
        sandboxId = _ref.sandboxId,
        forceHttps = _ref.forceHttps,
        transports = _ref.transports,
        login = _ref.login,
        password = _ref.password;
    classCallCheck(this, ServerClient);

    var authentication = function authentication() {
      return Authentication.developer({
        login: login,
        password: password
      });
    };
    var resource = uuid();
    /**
     * Call Client constructor with specific parameters
     */
    return possibleConstructorReturn(this, (ServerClient.__proto__ || Object.getPrototypeOf(ServerClient)).call(this, {
      apiUrl: apiUrl,
      sandboxId: sandboxId,
      forceHttps: forceHttps,
      authentication: authentication,
      resource: resource,
      transports: transports
    }));
  }

  createClass(ServerClient, [{
    key: 'disconnect',
    value: function disconnect() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var handlers = [];
        if (_this2.isConnected()) {
          var onConnectionClosed = function onConnectionClosed() {
            // Remove connection status listener
            handlers.forEach(function (handler) {
              _this2.removeConnectionStatusListener(handler);
            });
            // Resolve disconnection
            resolve();
          };
          handlers.push(_this2.onConnectionClosed(onConnectionClosed));
          // Disconnect client
          get(ServerClient.prototype.__proto__ || Object.getPrototypeOf(ServerClient.prototype), 'disconnect', _this2).call(_this2);
        } else {
          // Resolve disconnection
          resolve();
        }
      });
    }
  }, {
    key: 'connect',
    value: function connect() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var handlers = [];
        _this3.disconnect().then(function () {
          var onFailedHandshake = function onFailedHandshake(error) {
            // Remove connection status listener
            handlers.forEach(function (handler) {
              _this3.removeConnectionStatusListener(handler);
            });
            // Reconnect client via weak auth
            get(ServerClient.prototype.__proto__ || Object.getPrototypeOf(ServerClient.prototype), 'connect', _this3).call(_this3);
            // Reject connection
            reject(error);
          };
          var onConnectionEstablished = function onConnectionEstablished() {
            // Remove connection status listener
            handlers.forEach(function (handler) {
              _this3.removeConnectionStatusListener(handler);
            });
            // Resolve connection success
            resolve();
          };
          // Handle connection success and fail
          handlers.push(_this3.onConnectionEstablished(onConnectionEstablished));
          handlers.push(_this3.onFailedHandshake(onFailedHandshake));
          // Connect client to ZetaPush backend
          get(ServerClient.prototype.__proto__ || Object.getPrototypeOf(ServerClient.prototype), 'connect', _this3).call(_this3);
        });
      });
    }
  }, {
    key: 'subscribeTaskServer',
    value: function subscribeTaskServer(Worker) {
      var deploymentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Queue.DEFAULT_DEPLOYMENT_ID;

      console.log('subscribeTaskServer', Worker, deploymentId);
      var queue = this.createService({
        deploymentId: deploymentId,
        listener: {
          dispatch: function () {
            var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {
              var _ref2$data = _ref2.data,
                  request = _ref2$data.request,
                  taskId = _ref2$data.taskId;
              var data, requestId, name, namespace, parameters, result;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      console.log('dispatch', { request: request, taskId: taskId });
                      data = request.data, requestId = request.requestId;
                      name = data.name, namespace = data.namespace, parameters = data.parameters;

                      console.log('Queue::dispatch', {
                        name: name,
                        namespace: namespace,
                        parameters: parameters,
                        requestId: requestId,
                        taskId: taskId
                      });
                      _context.prev = 4;
                      _context.next = 7;
                      return Worker[name](parameters);

                    case 7:
                      result = _context.sent;

                      console.log('result', result);
                      queue.done({
                        result: result,
                        taskId: taskId,
                        requestId: requestId,
                        success: true
                      });
                      _context.next = 16;
                      break;

                    case 12:
                      _context.prev = 12;
                      _context.t0 = _context['catch'](4);

                      console.log('error', _context.t0);
                      queue.done({
                        result: { code: '', message: '' },
                        taskId: taskId,
                        requestId: requestId,
                        success: false
                      });

                    case 16:
                    case 'end':
                      return _context.stop();
                  }
                }
              }, _callee, this, [[4, 12]]);
            }));

            function dispatch(_x2) {
              return _ref3.apply(this, arguments);
            }

            return dispatch;
          }()
        },
        Type: Queue
      });
      queue.register({
        capacity: 100
      });
    }
  }]);
  return ServerClient;
}(Client);

/**
 * SDK Version
 * @type {string}
 */
var VERSION = '3.4.0-alpha.2';

exports.VERSION = VERSION;
exports.Authentication = Authentication;
exports.ConnectionStatusListener = ConnectionStatusListener;
exports.Client = Client;
exports.SmartClient = SmartClient;
exports.WeakClient = WeakClient;
exports.ServerClient = ServerClient;
exports.services = services;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=zetapush.js.map
