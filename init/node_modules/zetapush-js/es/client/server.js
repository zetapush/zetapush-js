'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerClient = undefined;

var _basic = require('./basic');

var _handshake = require('../authentication/handshake');

var _utils = require('../utils');

var _services = require('../mapping/services');

class ServerClient extends _basic.Client {
  constructor({ apiUrl, sandboxId, forceHttps, transports, login, password }) {
    const authentication = () => _handshake.Authentication.developer({
      login,
      password
    });
    const resource = (0, _utils.uuid)();
    /**
     * Call Client constructor with specific parameters
     */
    super({
      apiUrl,
      sandboxId,
      forceHttps,
      authentication,
      resource,
      transports
    });
  }
  disconnect() {
    return new Promise((resolve, reject) => {
      const handlers = [];
      if (this.isConnected()) {
        const onConnectionClosed = () => {
          // Remove connection status listener
          handlers.forEach(handler => {
            this.removeConnectionStatusListener(handler);
          });
          // Resolve disconnection
          resolve();
        };
        handlers.push(this.onConnectionClosed(onConnectionClosed));
        // Disconnect client
        super.disconnect();
      } else {
        // Resolve disconnection
        resolve();
      }
    });
  }
  connect() {
    return new Promise((resolve, reject) => {
      const handlers = [];
      this.disconnect().then(() => {
        const onFailedHandshake = error => {
          // Remove connection status listener
          handlers.forEach(handler => {
            this.removeConnectionStatusListener(handler);
          });
          // Reconnect client via weak auth
          super.connect();
          // Reject connection
          reject(error);
        };
        const onConnectionEstablished = () => {
          // Remove connection status listener
          handlers.forEach(handler => {
            this.removeConnectionStatusListener(handler);
          });
          // Resolve connection success
          resolve();
        };
        // Handle connection success and fail
        handlers.push(this.onConnectionEstablished(onConnectionEstablished));
        handlers.push(this.onFailedHandshake(onFailedHandshake));
        // Connect client to ZetaPush backend
        super.connect();
      });
    });
  }
  subscribeTaskServer(Worker, deploymentId = _services.Queue.DEFAULT_DEPLOYMENT_ID) {
    console.log('subscribeTaskServer', Worker, deploymentId);
    const queue = this.createService({
      deploymentId,
      listener: {
        async dispatch({ data: { request, taskId } }) {
          console.log('dispatch', { request, taskId });
          const { data, requestId } = request;
          const { name, namespace, parameters } = data;
          console.log('Queue::dispatch', {
            name,
            namespace,
            parameters,
            requestId,
            taskId
          });
          try {
            const result = await Worker[name](parameters);
            console.log('result', result);
            queue.done({
              result,
              taskId,
              requestId,
              success: true
            });
          } catch (error) {
            console.log('error', error);
            queue.done({
              result: { code: '', message: '' },
              taskId,
              requestId,
              success: false
            });
          }
        }
      },
      Type: _services.Queue
    });
    queue.register({
      capacity: 100
    });
  }
}
exports.ServerClient = ServerClient;