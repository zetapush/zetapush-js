import { Service } from './core'
/**
 * Delegating authentication
 *
 * This authentication delegates authentication to an external auth provider
 * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL
 * <br>The response must be in JSON format
 *  Each key of the response will be considered a user information field name
 * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)
 * */
/**
 * End-user API for the delegating authentication
 *
 * Provisionning verbs.
 * @access public
 * */
export class Delegating extends Service {
	/**
	 * Get default deployment id associated to Delegating service
	 * @return {string}
	 */
	static get DEFAULT_DEPLOYMENT_ID() {
		return 'delegating_0'
	}
}
/**
 * Local authentication
 *
 * Zetapush local authentication
 *  The configurer can choose the primary key and mandatory user fields for account creation
 *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)
 * */
/**
 * End-user API for the simple local authentication
 *
 * These API verbs allow end-users to manage their account.
 * @access public
 * */
export class Simple extends Service {
	/**
	 * Get default deployment id associated to Simple service
	 * @return {string}
	 */
	static get DEFAULT_DEPLOYMENT_ID() {
		return 'simple_0'
	}
}
/**
 * Weak authentication
 *
 * The weak authentication allows for anonymous authentication of devices
 *  Such devices can display a qrcode to allow regular users to take control of them
 * */
/**
 * User API for weak devices control
 *
 * User API for control and release of weakly authenticated user sessions.
 * @access public
 * */
export class Weak extends Service {
	/**
	 * Get default deployment id associated to Weak service
	 * @return {string}
	 */
	static get DEFAULT_DEPLOYMENT_ID() {
		return 'weak_0'
	}
	/**
	 * Controls a session
	 *
	 * Takes control of a weak user session, identified by the given public token.
	 * The public token has been previously made available by the controlled device, for example by displaying a QRCode.
	 * Upon control notification, the client SDK of the controlled session is expected to re-handshake.
	 * */
	control({publicToken,fullRights}) { return this.$publish('control', {publicToken,fullRights})}
	/**
	 * Returns the current token
	 *
	 * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.
	 * The token can be used to log in as the same weak user another time.
	 * */
	getToken() { return this.$publish('getToken', {})}
	/**
	 * Releases a session
	 *
	 * Releases control of a weak user session, identified by the given public token.
	 * The weak user session must have been previously controlled by a call to 'control'.
	 * */
	release({publicToken,fullRights}) { return this.$publish('release', {publicToken,fullRights})}
}
