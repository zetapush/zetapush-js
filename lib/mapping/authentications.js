'use strict';

exports.__esModule = true;
exports.Weak = exports.Simple = exports.Delegating = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('./core');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Delegating authentication
 *
 * This authentication delegates authentication to an external auth provider
 * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL
 * <br>The response must be in JSON format
 *  Each key of the response will be considered a user information field name
 * <br>The handshake from the server will return the primary key in a field named 'login' (regardless of the actual key name you might have chosen)
 * */
/**
 * End-user API for the delegating authentication
 *
 * Provisionning verbs.
 * @access public
 * */
var Delegating = exports.Delegating = function (_Service) {
	_inherits(Delegating, _Service);

	function Delegating() {
		_classCallCheck(this, Delegating);

		return _possibleConstructorReturn(this, _Service.apply(this, arguments));
	}

	_createClass(Delegating, null, [{
		key: 'DEFAULT_DEPLOYMENT_ID',

		/**
   * Get default deployment id associated to Delegating service
   * @return {string}
   */
		get: function get() {
			return 'delegating_0';
		}
	}]);

	return Delegating;
}(_core.Service);
/**
 * Local authentication
 *
 * Zetapush local authentication
 *  The configurer can choose the primary key and mandatory user fields for account creation
 *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)
 * */
/**
 * End-user API for the simple local authentication
 *
 * These API verbs allow end-users to manage their account.
 * @access public
 * */


var Simple = exports.Simple = function (_Service2) {
	_inherits(Simple, _Service2);

	function Simple() {
		_classCallCheck(this, Simple);

		return _possibleConstructorReturn(this, _Service2.apply(this, arguments));
	}

	_createClass(Simple, null, [{
		key: 'DEFAULT_DEPLOYMENT_ID',

		/**
   * Get default deployment id associated to Simple service
   * @return {string}
   */
		get: function get() {
			return 'simple_0';
		}
	}]);

	return Simple;
}(_core.Service);
/**
 * Weak authentication
 *
 * The weak authentication allows for anonymous authentication of devices
 *  Such devices can display a qrcode to allow regular users to take control of them
 * */
/**
 * User API for weak devices control
 *
 * User API for control and release of weakly authenticated user sessions.
 * @access public
 * */


var Weak = exports.Weak = function (_Service3) {
	_inherits(Weak, _Service3);

	function Weak() {
		_classCallCheck(this, Weak);

		return _possibleConstructorReturn(this, _Service3.apply(this, arguments));
	}

	/**
  * Controls a session
  *
  * Takes control of a weak user session, identified by the given public token.
  * The public token has been previously made available by the controlled device, for example by displaying a QRCode.
  * Upon control notification, the client SDK of the controlled session is expected to re-handshake.
  * */
	Weak.prototype.control = function control(_ref) {
		var publicToken = _ref.publicToken,
		    fullRights = _ref.fullRights;
		return this.$publish('control', { publicToken: publicToken, fullRights: fullRights });
	};
	/**
  * Returns the current token
  *
  * Returns your current session's private token. The token field may be null, if you did not log in with this authentication.
  * The token can be used to log in as the same weak user another time.
  * */


	Weak.prototype.getToken = function getToken() {
		return this.$publish('getToken', {});
	};
	/**
  * Releases a session
  *
  * Releases control of a weak user session, identified by the given public token.
  * The weak user session must have been previously controlled by a call to 'control'.
  * */


	Weak.prototype.release = function release(_ref2) {
		var publicToken = _ref2.publicToken,
		    fullRights = _ref2.fullRights;
		return this.$publish('release', { publicToken: publicToken, fullRights: fullRights });
	};

	_createClass(Weak, null, [{
		key: 'DEFAULT_DEPLOYMENT_ID',

		/**
   * Get default deployment id associated to Weak service
   * @return {string}
   */
		get: function get() {
			return 'weak_0';
		}
	}]);

	return Weak;
}(_core.Service);